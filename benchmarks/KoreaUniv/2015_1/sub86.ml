(* Problem 1 *)let pascal : int * int -> int=fun (x,y) -> 1 let rec pascal (x, y) =if (x>1) && (y>0) && (y<x) then pascal (x-1, y-1) + pascal (x-1, y) else 1(* Problem 2 *)let rec sigma : (int -> int) -> int -> int -> int=fun f a b -> 1 let rec sigma f a b = if (a=b) then f a else f b + sigma f a (b-1) (* Problem 3 *)let rec max : int list -> int=fun l -> 1 let rec max l = match l with [] -> 1(*empty list를 받으면 1을 반환*) |hd::tl -> if (tl=[]) then hd else if (hd>max tl) then hd else max tl let rec min : int list -> int=fun l -> 1 let rec min l = match l with [] -> 1(*empty list를 받으면 1을 반환*) |hd::tl -> if (tl=[]) then hd else if (hd<min tl) then hd else min tl (* Problem 4 *)type formula =True| False| Neg of formula| Or of formula * formula| And of formula * formula| Imply of formula * formula| Equiv of formula * formula let rec eval : formula -> bool=fun f -> true let rec eval formula = match formula with True -> True|False -> False|Neg True -> False|Neg _ -> True|Or (False, False) -> False|Or (_, _) -> True|And(True, True) -> True|And (_, _) -> False|Imply (True, False) -> False|Imply (_, _) -> True|Equiv (True, True) -> True|Equiv (False, False) -> True|Equiv (_, _) -> False (* Problem 5 *)type nat = ZERO | SUCC of nat let rec natadd : nat -> nat -> nat=fun n1 n2 -> ZERO let rec natadd n1 n2 = match n2 with ZERO -> n1|SUCC (nat) -> SUCC (natadd n1 nat) let rec natmul : nat -> nat -> nat=fun n1 n2 -> ZERO let rec natmul n1 n2 = match n2 with ZERO -> ZERO|SUCC (nat) -> natadd n1 (natmul n1 nat)
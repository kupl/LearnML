../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub1.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not a -> not (eval (a))
|AndAlso (a, b) -> (eval (a) && eval (b))
|OrElse (a, b) -> (eval (a) || eval (b))
|Imply (a, b) -> if eval (a) then eval (b)
 else true
|Equal (a, b) -> (a = b))

let rec expr  = 
fun e -> 
 (match e with 
|Num n -> n
|Plus (e1, e2) -> (expr (e1) + expr (e2))
|Minus (e1, e2) -> (expr (e1) - expr (e2)))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub106.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> true

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub108.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval f  = 
 (match f with 
|True -> true
|False -> false
|Not a -> if eval (a) then false
 else true
|AndAlso (left, right) -> if (eval (left) && eval (right)) then true
 else false
|OrElse (left, right) -> if (eval (left) || eval (right)) then true
 else false
|Imply (left, right) -> if (eval (left) && eval (right)) then true
 else if ((eval (left) = true) && (eval (right) = false)) then true
 else false
|Equal (left, right) -> 
let rec env v  = 
 (match v with 
|Num a -> a
|Plus (a, b) -> (env (a) + env (b))
|Minus (a, b) -> (env (a) - env (b)))
 in 
if (env (left) = env (right)) then true
 else false)

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval f  = 
 (match f with 
|True -> true
|False -> false
|Not a -> if eval (a) then false
 else true
|AndAlso (left, right) -> if (eval (left) && eval (right)) then true
 else false
|OrElse (left, right) -> if (eval (left) || eval (right)) then true
 else false
|Imply (left, right) -> if (eval (left) && eval (right)) then true
 else if ((eval (left) = false) && (eval (right) = false)) then true
 else false
|Equal (left, right) -> 
let rec env v  = 
 (match v with 
|Num a -> a
|Plus (a, b) -> (env (a) + env (b))
|Minus (a, b) -> (env (a) - env (b)))
 in 
if (env (left) = env (right)) then true
 else false)

Total time :0.070257
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub110.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> true

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub112.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval_exp  : (exp -> int) = 
fun e -> 
 (match e with 
|Num num -> num
|Plus (n1, n2) -> (eval_exp (n1) + eval_exp (n2))
|Minus (n1, n2) -> (eval_exp (n1) - eval_exp (n2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not v -> not (eval (v))
|AndAlso (v1, v2) -> (eval (v1) && eval (v2))
|OrElse (v1, v2) -> (eval (v1) || eval (v2))
|Imply (v1, v2) -> if (v1 = False) then true
 else eval (v2)
|Equal (e1, e2) -> if (eval_exp (e1) = eval_exp (e2)) then true
 else false)

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval_exp  : (exp -> int) = 
fun e -> 
 (match e with 
|Num num -> num
|Plus (n1, n2) -> (eval_exp (n1) + eval_exp (n2))
|Minus (n1, n2) -> (eval_exp (n1) - eval_exp (n2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not v -> not (eval (v))
|AndAlso (v1, v2) -> (eval (v1) && eval (v2))
|OrElse (v1, v2) -> (eval (v1) || eval (v2))
|Imply (v1, v2) -> if not (eval (v1)) then true
 else eval (v2)
|Equal (e1, e2) -> if (eval_exp (e1) = eval_exp (e2)) then true
 else false)

Total time :0.727691
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub113.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec cal  : (exp -> int) = 
fun e -> 
 (match e with 
|Num n -> n
|Plus (e1, e2) -> (cal (e1) + cal (e2))
|Minus (e1, e2) -> (cal (e1) - cal (e2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f1 -> not (eval (f1))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> (eval (Not (f1)) && eval (f2))
|Equal (e1, e2) -> 
let rec cal  : (exp -> int) = 
fun e -> 
 (match e with 
|Num n -> n
|Plus (x, y) -> (cal (x) + cal (y))
|Minus (x, y) -> (cal (x) - cal (y)))
 in 
(cal (e1) = cal (e2)))

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec cal  : (exp -> int) = 
fun e -> 
 (match e with 
|Num n -> n
|Plus (e1, e2) -> (cal (e1) + cal (e2))
|Minus (e1, e2) -> (cal (e1) - cal (e2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f1 -> not (eval (f1))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> (eval (f1) = eval (f2))
|Equal (e1, e2) -> 
let rec cal  : (exp -> int) = 
fun e -> 
 (match e with 
|Num n -> n
|Plus (x, y) -> (cal (x) + cal (y))
|Minus (x, y) -> (cal (x) - cal (y)))
 in 
(cal (e1) = cal (e2)))

Total time :0.379605
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub115.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not p -> not (eval (p))
|AndAlso (p, q) -> (eval (p) && eval (q))
|OrElse (p, q) -> (eval (p) || eval (q))
|Imply (p, q) -> (not (eval (p)) || eval (q))
|Equal (p, q) -> (p = q))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub118.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> true

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub119.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec trans  : (exp -> exp) = 
fun e1 -> 
 (match e1 with 
|Plus (Num a, Num b) -> Num ((a + b))
|Plus (Num a, e3) -> Plus ((Num (a), trans (e3)))
|Plus (e2, Num b) -> Plus ((trans (e2), Num (b)))
|Plus (e2, e3) -> Plus ((trans (e2), trans (e3)))
|Minus (Num a, Num b) -> Num ((a - b))
|Minus (Num a, e3) -> Minus ((Num (a), trans (e3)))
|Minus (e2, Num b) -> Minus ((trans (e2), Num (b)))
|Minus (e2, e3) -> Minus ((trans (e2), trans (e3)))
|Num a -> Num (a))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f1 -> if (f1 = True) then false
 else true
|AndAlso (f1, f2) -> if ((f1 = True) && (f2 = True)) then true
 else false
|OrElse (f1, f2) -> if ((f1 = False) && (f2 = False)) then false
 else true
|Imply (f1, f2) -> if ((f1 = True) && (f2 = False)) then false
 else true
|Equal (e1, e2) -> if (trans (e1) = trans (e2)) then true
 else false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub12.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> true

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub120.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not a -> if (eval (a) = true) then true
 else false
|AndAlso (a, b) -> if ((eval (a) = true) && (eval (b) = true)) then true
 else false
|OrElse (a, b) -> if ((eval (a) = false) && (eval (b) = false)) then false
 else true
|Imply (a, b) -> if ((eval (a) = true) && (eval (b) = false)) then false
 else true
|Equal (a, b) -> 
let rec eq  : (exp -> int) = 
fun e -> 
 (match e with 
|Num a -> a
|Plus (a, b) -> (eq (a) + eq (b))
|Minus (a, b) -> (eq (a) - eq (b)))
 in 
if (eq (a) = eq (b)) then true
 else false)

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not a -> if (eval (a) = false) then true
 else false
|AndAlso (a, b) -> if ((eval (a) = true) && (eval (b) = true)) then true
 else false
|OrElse (a, b) -> if ((eval (a) = false) && (eval (b) = false)) then false
 else true
|Imply (a, b) -> if ((eval (a) = true) && (eval (b) = false)) then false
 else true
|Equal (a, b) -> 
let rec eq  : (exp -> int) = 
fun e -> 
 (match e with 
|Num a -> a
|Plus (a, b) -> (eq (a) + eq (b))
|Minus (a, b) -> (eq (a) - eq (b)))
 in 
if (eq (a) = eq (b)) then true
 else false)

Total time :0.110925
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub123.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
let rec evalexp  : (exp -> int) = 
fun f1 -> 
 (match f1 with 
|Num a -> a
|Plus (a, b) -> (evalexp (a) + evalexp (b))
|Minus (a, b) -> (evalexp (a) - evalexp (b)))
 in 

 (match f with 
|True -> true
|False -> false
|Not f1 -> if (f1 = True) then false
 else true
|AndAlso (f1, f2) -> if (f1 = False) then false
 else if (f2 = True) then true
 else false
|OrElse (f1, f2) -> if (f1 = True) then true
 else if (f2 = True) then true
 else false
|Imply (f1, f2) -> if ((f1 = True) && (f2 = False)) then false
 else true
|Equal (a, b) -> if (evalexp (a) = evalexp (b)) then true
 else false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub125.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec exptoint  : (exp -> int) = 
fun e -> 
 (match e with 
|Num a -> a
|Plus (a, b) -> (exptoint (a) + exptoint (b))
|Minus (a, b) -> (exptoint (a) - exptoint (b)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f1 -> if (f1 = True) then false
 else true
|AndAlso (f1, f2) -> if ((f1 = True) && (f2 = True)) then true
 else false
|OrElse (f1, f2) -> if (AndAlso ((f1, f2)) = False) then false
 else true
|Imply (f1, f2) -> if ((Not (f1) = True) || (AndAlso ((f1, f2)) = True)) then true
 else false
|Equal (e1, e2) -> if (exptoint (e1) = exptoint (e2)) then true
 else false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub129.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec expfun  : (exp -> int) = 
fun q -> 
 (match q with 
|Num i -> i
|Plus (i, k) -> (expfun (i) + expfun (k))
|Minus (i, k) -> (expfun (i) - expfun (k)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f1 -> if (f1 = True) then false
 else true
|AndAlso (f1, f2) -> if ((f1 = True) && (f2 = True)) then true
 else false
|OrElse (f1, f2) -> if ((f1 = False) && (f2 = False)) then false
 else true
|Imply (f1, f2) -> if ((f1 = True) && (f2 = False)) then false
 else true
|Equal (q1, q2) -> if (expfun (q1) = expfun (q2)) then true
 else false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub139.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
let rec foldeval b  = 
 (match b with 
|Num i -> i
|Plus (l, m) -> (foldeval (l) + foldeval (m))
|Minus (l, m) -> (foldeval (l) - foldeval (m)))
 in 

let rec fold a  = 
 (match a with 
|True -> True
|False -> False
|Not x1 -> if (fold (x1) = True) then False
 else True
|AndAlso (x2, y2) -> if ((fold (x2) = True) && (fold (y2) = True)) then True
 else False
|OrElse (x3, y3) -> if ((fold (x3) = True) || (fold (y3) = True)) then True
 else False
|Imply (x4, y4) -> if (fold (x4) = False) then True
 else if (y4 = True) then True
 else False
|Equal (l5, m5) -> if (foldeval (l5) = foldeval (m5)) then True
 else False)
 in 
if (fold (f) = True) then true
 else false

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
let rec foldeval b  = 
 (match b with 
|Num i -> i
|Plus (l, m) -> (foldeval (l) + foldeval (m))
|Minus (l, m) -> (foldeval (l) - foldeval (m)))
 in 

let rec fold a  = 
 (match a with 
|True -> True
|False -> False
|Not x1 -> if (fold (x1) = True) then False
 else True
|AndAlso (x2, y2) -> if ((fold (x2) = True) && (fold (y2) = True)) then True
 else False
|OrElse (x3, y3) -> if ((fold (x3) = True) || (fold (y3) = True)) then True
 else False
|Imply (x4, y4) -> if (fold (x4) = False) then True
 else if (y4 = x4) then True
 else False
|Equal (l5, m5) -> if (foldeval (l5) = foldeval (m5)) then True
 else False)
 in 
if (fold (f) = True) then true
 else false

Total time :0.047642
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub140.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalexp f  = 
 (match f with 
|Num x -> x
|Plus (x, y) -> (evalexp (x) + evalexp (y))
|Minus (x, y) -> (evalexp (x) + evalexp (y)))

let rec eval f  = 
 (match f with 
|True -> true
|False -> false
|Not p -> if (eval (p) = true) then false
 else true
|AndAlso (p, q) -> if ((eval (p) = true) && (eval (q) = true)) then true
 else false
|OrElse (p, q) -> if ((eval (p) = true) || (eval (q) = true)) then true
 else false
|Imply (p, q) -> if (eval (q) = true) then true
 else false
|Equal (p, q) -> if (evalexp (p) = evalexp (q)) then true
 else false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub141.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> true

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub15.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not b -> if (b = True) then eval (True)
 else eval (False)
|AndAlso (a, b) -> if (a = False) then eval (False)
 else if (b = False) then eval (False)
 else eval (True)
|OrElse (a, b) -> if (a = True) then eval (True)
 else if (b = True) then eval (True)
 else eval (False)
|Imply (a, b) -> if (a = False) then eval (True)
 else if (b = True) then eval (True)
 else eval (False)
|Equal (a, b) -> if (a = b) then eval (True)
 else eval (False))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub20.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|Not True -> false
|Not False -> true
|AndAlso (a, b) -> (eval (a) && eval (b))
|OrElse (a, b) -> (eval (a) || eval (b)))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub23.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not a -> not (eval (a))
|AndAlso (a, b) -> (eval (a) && eval (b))
|OrElse (a, b) -> (eval (a) || eval (b))
|Imply (a, b) -> if eval (a) then eval (b)
 else true
|Equal (a, b) -> 
let rec _eval x  = 
 (match x with 
|Num n -> n
|Plus (n1, n2) -> (_eval (n1) + _eval (n2))
|Minus (n1, n2) -> (_eval (n1) - _eval (n2)))
 in 
if (_eval (a) < _eval (b)) then true
 else false)

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not a -> not (eval (a))
|AndAlso (a, b) -> (eval (a) && eval (b))
|OrElse (a, b) -> (eval (a) || eval (b))
|Imply (a, b) -> if eval (a) then eval (b)
 else true
|Equal (a, b) -> 
let rec _eval x  = 
 (match x with 
|Num n -> n
|Plus (n1, n2) -> (_eval (n1) + _eval (n2))
|Minus (n1, n2) -> (_eval (n1) - _eval (n2)))
 in 
(_eval (a) = _eval (b)))

Total time :7.234684
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub24.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval_op op  = 
 (match op with 
|Num a -> a
|Minus (exp1, exp2) -> (eval_op (exp1) - eval_op (exp2))
|Plus (exp1, exp2) -> (eval_op (exp1) + eval_op (exp2)))
and eval f  = 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> (not (eval (f1)) && eval (f2))
|Equal (exp1, exp2) -> if (eval_op (exp1) = eval_op (exp2)) then true
 else false)

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval_op op  = 
 (match op with 
|Num a -> a
|Minus (exp1, exp2) -> (eval_op (exp1) - eval_op (exp2))
|Plus (exp1, exp2) -> (eval_op (exp1) + eval_op (exp2)))
and eval f  = 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> (eval (f2) = eval (f1))
|Equal (exp1, exp2) -> if (eval_op (exp1) = eval_op (exp2)) then true
 else false)

Total time :0.419481
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub27.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not a -> if (a = True) then false
 else true
|AndAlso (a, b) -> if ((a = True) && (b = True)) then true
 else false
|OrElse (a, b) -> if ((a = True) || (b = True)) then true
 else false
|Imply (a, b) -> if ((Not (a) = True) || (b = True)) then true
 else false
|Equal (a, b) -> 
let rec evalexp e  = 
 (match e with 
|Num a -> a
|Plus (a, b) -> (evalexp (a) + evalexp (b))
|Minus (a, b) -> (evalexp (a) - evalexp (b)))
 in 
if (evalexp (a) = evalexp (b)) then true
 else false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub32.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
let rec calculate f2  = 
 (match f2 with 
|Num i -> i
|Plus (e1, e2) -> (calculate (e1) + calculate (e2))
|Minus (e1, e2) -> (calculate (e1) - calculate (e2)))
 in 

 (match f with 
|True -> true
|False -> false
|Not f -> if (f = True) then false
 else true
|AndAlso (f1, f2) -> if ((f1 = True) && (f2 = True)) then true
 else false
|OrElse (f1, f2) -> if ((f1 = True) || (f2 = True)) then true
 else false
|Imply (f1, f2) -> if ((f1 = True) && (f2 = False)) then false
 else true
|Equal (e1, e2) -> if (calculate (e1) = calculate (e2)) then true
 else false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub33.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec expfun e  = 
 (match e with 
|Num n -> n
|Plus (e1, e2) -> (expfun (e1) + expfun (e2))
|Minus (e1, e2) -> (expfun (e1) - expfun (e2)))

let rec eval f  = 
 (match f with 
|True -> true
|False -> false
|Not f1 -> if (f1 = True) then false
 else true
|AndAlso (f1, f2) -> if ((f1 = True) && (f2 = True)) then true
 else false
|OrElse (f1, f2) -> if ((f1 = True) || (f2 = True)) then true
 else false
|Imply (f1, f2) -> if ((f1 = True) && (f2 = False)) then false
 else true
|Equal (e1, e2) -> if (expfun (e1) = expfun (e2)) then true
 else false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub36.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not x -> not (eval (x))
|AndAlso (x, y) -> (eval (x) && eval (y))
|OrElse (x, y) -> (eval (x) || eval (y))
|Imply (x, y) -> (not (eval (x)) || eval (y))
|Equal (x, y) -> (x = y))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub38.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec getInt  : (exp -> int) = 
fun number -> 
 (match number with 
|Num x -> x
|Plus (a, b) -> (getInt (a) + getInt (b))
|Minus (a, b) -> (getInt (a) - getInt (b)))

let rec getExpression  : (exp -> exp) = 
fun f -> 
 (match f with 
|Num x -> Num (x)
|Plus (a, b) -> Num (getInt (Plus ((a, b))))
|Minus (a, b) -> Num (getInt (Minus ((a, b)))))

let rec getValue  : (formula -> formula) = 
fun f -> 
 (match f with 
|True -> True
|False -> False
|Not x -> if (x = True) then False
 else if (x = False) then True
 else getValue (Not (getValue (x)))
|AndAlso (x, y) -> if ((x = True) && (y = True)) then True
 else if ((x = False) || (y = False)) then False
 else getValue (AndAlso ((getValue (x), getValue (y))))
|OrElse (x, y) -> if ((x = True) && (y = False)) then True
 else if ((x = False) && (y = True)) then True
 else if ((x = False) && (y = False)) then False
 else if ((x = True) && (y = True)) then False
 else getValue (OrElse ((getValue (x), getValue (y))))
|Imply (x, y) -> if (x = False) then True
 else if ((x = True) && (y = True)) then True
 else if ((x = True) && (y = False)) then False
 else getValue (Imply ((getValue (x), getValue (y))))
|Equal (ex1, ex2) -> if (getExpression (ex1) = getExpression (ex2)) then True
 else False)

let rec eval  : (formula -> bool) = 
fun f -> if (f = True) then true
 else if (f = False) then false
 else eval (getValue (f))

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec getInt  : (exp -> int) = 
fun number -> 
 (match number with 
|Num x -> x
|Plus (a, b) -> (getInt (a) + getInt (b))
|Minus (a, b) -> (getInt (a) - getInt (b)))

let rec getExpression  : (exp -> exp) = 
fun f -> 
 (match f with 
|Num x -> Num (x)
|Plus (a, b) -> Num (getInt (Plus ((a, b))))
|Minus (a, b) -> Num (getInt (Minus ((a, b)))))

let rec getValue  : (formula -> formula) = 
fun f -> 
 (match f with 
|True -> True
|False -> False
|Not x -> if (x = True) then False
 else if (x = False) then True
 else getValue (Not (getValue (x)))
|AndAlso (x, y) -> if ((x = True) && (y = True)) then True
 else if ((x = False) || (y = False)) then False
 else getValue (AndAlso ((getValue (x), getValue (y))))
|OrElse (x, y) -> if ((x = True) && (y = False)) then True
 else if ((x = False) && (y = True)) then True
 else if ((x = False) && (y = False)) then False
 else if ((x = True) && (y = True)) then y
 else getValue (OrElse ((getValue (x), getValue (y))))
|Imply (x, y) -> if (x = False) then True
 else if ((x = True) && (y = True)) then True
 else if ((x = True) && (y = False)) then False
 else getValue (Imply ((getValue (x), getValue (y))))
|Equal (ex1, ex2) -> if (getExpression (ex1) = getExpression (ex2)) then True
 else False)

let rec eval  : (formula -> bool) = 
fun f -> if (f = True) then true
 else if (f = False) then false
 else eval (getValue (f))

Total time :0.066783
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub41.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let andAlso  : ((bool * bool) -> bool) = 
fun f -> 
 (match f with 
|(true, true) -> true
|_ -> false)

let orElse  : ((bool * bool) -> bool) = 
fun f -> 
 (match f with 
|(false, false) -> false
|_ -> true)

let imply  : ((bool * bool) -> bool) = 
fun f -> 
 (match f with 
|(frue, false) -> false
|_ -> true)

let rec ca  : (exp -> int) = 
fun f -> 
 (match f with 
|Num a -> a
|Plus (a, b) -> (ca (a) + ca (b))
|Minus (a, b) -> (ca (a) - ca (b)))

let equal  : ((exp * exp) -> bool) = 
fun f -> 
 (match f with 
|(a, b) -> if (ca (a) = ca (b)) then true
 else false)

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|AndAlso (a, b) -> andAlso ((eval (a), eval (b)))
|OrElse (a, b) -> orElse ((eval (a), eval (b)))
|Imply (a, b) -> imply ((eval (a), eval (b)))
|Equal (a, b) -> equal ((a, b))
|_ -> raise Failure ("eval requires formula"))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub44.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> true

let rec eval f  = 
let rec expin f  = 
 (match f with 
|Num n -> n
|Plus (e1, e2) -> (expin (e1) + expin (e2))
|Minus (e1, e2) -> (expin (e1) - expin (e2)))
 in 

 (match f with 
|True -> true
|False -> false
|Not f1 -> if (f1 = True) then false
 else true
|AndAlso (f1, f2) -> if ((f1 = True) && (f2 = True)) then true
 else false
|OrElse (f1, f2) -> if ((f1 = True) || (f2 = True)) then true
 else false
|Imply (f1, f2) -> if ((f1 = True) && (f2 = False)) then false
 else true
|Equal (e1, e2) -> if (expin (e1) = expin (e2)) then true
 else false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub45.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------
type exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int
type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True

let rec eval_exp a  = 
 (match a with 
|Num n -> n
|Plus (n1, n2) -> (eval_exp (n1) + eval_exp (n2))
|Minus (n1, n2) -> (eval_exp (n1) + eval_exp (n2)))

let rec eval thing  = 
 (match thing with 
|True -> true
|False -> false
|Not a -> if eval (a) then false
 else true
|AndAlso (a, b) -> (eval (a) && eval (b))
|OrElse (a, b) -> (eval (a) || eval (b))
|Imply (a, b) -> if ((eval (a) = true) && (eval (b) = false)) then false
 else true
|Equal (a, b) -> if (eval_exp (a) = eval_exp (b)) then true
 else false)

-----------------------------
result
-----------------------------
type exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int
type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True

let rec eval_exp a  = 
 (match a with 
|Num n -> n
|Plus (n1, n2) -> (eval_exp (n1) + eval_exp (n2))
|Minus (n1, n2) -> (eval_exp (n1) - eval_exp (n2)))

let rec eval thing  = 
 (match thing with 
|True -> true
|False -> false
|Not a -> if eval (a) then false
 else true
|AndAlso (a, b) -> (eval (a) && eval (b))
|OrElse (a, b) -> (eval (a) || eval (b))
|Imply (a, b) -> if ((eval (a) = true) && (eval (b) = false)) then false
 else true
|Equal (a, b) -> if (eval_exp (a) = eval_exp (b)) then true
 else false)

Total time :2.822247
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub46.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not ev -> if (ev = True) then false
 else true
|AndAlso (ev1, ev2) -> if ((ev1 = True) && (ev2 = True)) then true
 else false
|OrElse (ev1, ev2) -> if ((ev1 = False) && (ev2 = False)) then false
 else true
|Imply (ev1, ev2) -> if ((ev1 = True) && (ev2 = False)) then false
 else true
|Equal (in1, in2) -> 
let rec pl_mi x  = 
 (match x with 
|Num n -> n
|Plus (n1, n2) -> (pl_mi (n1) + pl_mi (n2))
|Minus (n1, n2) -> (pl_mi (n1) - pl_mi (n2)))
 in 
if (pl_mi (in1) = pl_mi (in2)) then true
 else false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub47.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> true

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub48.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalexp exp  = 
 (match exp with 
|Num n -> n
|Plus (n1, n2) -> 
 (match (n1, n2) with 
|(_, _) -> (evalexp (n1) + evalexp (n2)))
|Minus (n1, n2) -> 
 (match (n1, n2) with 
|(_, _) -> (evalexp (n1) - evalexp (n2))))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f' -> 
 (match f' with 
|True -> false
|False -> true
|_ -> eval (f'))
|AndAlso (f1', f2') -> 
 (match (f1', f2') with 
|(True, True) -> true
|(False, _) -> false
|(_, False) -> false
|(_, _) -> (eval (f1') && eval (f2')))
|OrElse (f1', f2') -> 
 (match (f1', f2') with 
|(True, True) -> true
|(True, False) -> true
|(False, True) -> true
|(False, False) -> false
|(_, _) -> (eval (f1') || eval (f2')))
|Imply (f1', f2') -> 
 (match (f1', f2') with 
|(True, True) -> true
|(True, False) -> false
|(False, True) -> true
|(False, False) -> true
|(_, _) -> (eval (Not (f1')) || eval (f2')))
|Equal (exp1, exp2) -> 
 (match (evalexp (exp1), evalexp (exp2)) with 
|(a, b) -> if (a = b) then true
 else false))

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalexp exp  = 
 (match exp with 
|Num n -> n
|Plus (n1, n2) -> 
 (match (n1, n2) with 
|(_, _) -> (evalexp (n1) + evalexp (n2)))
|Minus (n1, n2) -> 
 (match (n1, n2) with 
|(_, _) -> (evalexp (n1) - evalexp (n2))))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f' -> 
 (match f' with 
|True -> false
|False -> true
|_ -> not (eval (f')))
|AndAlso (f1', f2') -> 
 (match (f1', f2') with 
|(True, True) -> true
|(False, _) -> false
|(_, False) -> false
|(_, _) -> (eval (f1') && eval (f2')))
|OrElse (f1', f2') -> 
 (match (f1', f2') with 
|(True, True) -> true
|(True, False) -> true
|(False, True) -> true
|(False, False) -> false
|(_, _) -> (eval (f1') || eval (f2')))
|Imply (f1', f2') -> 
 (match (f1', f2') with 
|(True, True) -> true
|(True, False) -> false
|(False, True) -> true
|(False, False) -> true
|(_, _) -> (eval (Not (f1')) || eval (f2')))
|Equal (exp1, exp2) -> 
 (match (evalexp (exp1), evalexp (exp2)) with 
|(a, b) -> if (a = b) then true
 else false))

Total time :0.312661
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub51.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let imply v  = 
 (match v with 
|(true, x) -> x
|(false, x) -> true)

let rec calc e  = 
 (match e with 
|Num n -> n
|Plus (e1, e2) -> (calc (e1) + calc (e2))
|Minus (e1, e2) -> (calc (e1) - calc (e2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not fm -> not (eval (fm))
|AndAlso (fm1, fm2) -> (eval (fm1) && eval (fm2))
|OrElse (fm1, fm2) -> (eval (fm2) || eval (fm2))
|Imply (fm1, fm2) -> imply ((eval (fm1), eval (fm2)))
|Equal (e1, e2) -> (calc (e1) = calc (e2)))

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let imply v  = 
 (match v with 
|(true, x) -> x
|(false, x) -> true)

let rec calc e  = 
 (match e with 
|Num n -> n
|Plus (e1, e2) -> (calc (e1) + calc (e2))
|Minus (e1, e2) -> (calc (e1) - calc (e2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not fm -> not (eval (fm))
|AndAlso (fm1, fm2) -> (eval (fm1) && eval (fm2))
|OrElse (fm1, fm2) -> (eval (fm2) || eval (fm1))
|Imply (fm1, fm2) -> imply ((eval (fm1), eval (fm2)))
|Equal (e1, e2) -> (calc (e1) = calc (e2)))

Total time :0.040655
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub52.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec arithmetic  = 
fun f -> 
 (match f with 
|Num num -> num
|Plus (num1, num2) -> (arithmetic (num1) + arithmetic (num2))
|Minus (num1, num2) -> (arithmetic (num1) - arithmetic (num2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not fm -> if eval (fm) then false
 else true
|AndAlso (fm1, fm2) -> (eval (fm1) && eval (fm2))
|OrElse (fm1, fm2) -> (eval (fm1) || eval (fm2))
|Imply (fm1, fm2) -> if eval (fm1) then if eval (fm2) then true
 else false
 else false
|Equal (exp1, exp2) -> (arithmetic (exp1) = arithmetic (exp2)))

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec arithmetic  = 
fun f -> 
 (match f with 
|Num num -> num
|Plus (num1, num2) -> (arithmetic (num1) + arithmetic (num2))
|Minus (num1, num2) -> (arithmetic (num1) - arithmetic (num2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not fm -> if eval (fm) then false
 else true
|AndAlso (fm1, fm2) -> (eval (fm1) && eval (fm2))
|OrElse (fm1, fm2) -> (eval (fm1) || eval (fm2))
|Imply (fm1, fm2) -> if eval (fm1) then if eval (fm2) then true
 else false
 else true
|Equal (exp1, exp2) -> (arithmetic (exp1) = arithmetic (exp2)))

Total time :0.029606
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub61.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalHelper1  : (exp -> int) = 
fun f -> 
 (match f with 
|Num a -> a
|Minus (a, b) -> (evalHelper1 (a) - evalHelper1 (b))
|Plus (a, b) -> (evalHelper1 (a) + evalHelper1 (b)))

let rec evalHelper  : (formula -> formula) = 
fun f -> 
 (match f with 
|True -> True
|False -> False
|Not a -> if (a = True) then False
 else True
|AndAlso (a, b) -> if ((evalHelper (a) = True) && (evalHelper (b) = True)) then True
 else False
|OrElse (a, b) -> if ((evalHelper (a) = False) && (evalHelper (b) = False)) then False
 else True
|Imply (a, b) -> if ((evalHelper (a) = True) && (evalHelper (b) = False)) then False
 else True
|Equal (a, b) -> if (evalHelper1 (a) = evalHelper1 (b)) then True
 else False)

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|f -> eval (evalHelper (f)))

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalHelper1  : (exp -> int) = 
fun f -> 
 (match f with 
|Num a -> a
|Minus (a, b) -> (evalHelper1 (a) - evalHelper1 (b))
|Plus (a, b) -> (evalHelper1 (a) + evalHelper1 (b)))

let rec evalHelper  : (formula -> formula) = 
fun f -> 
 (match f with 
|True -> True
|False -> False
|Not a -> if (evalHelper (a) = True) then False
 else True
|AndAlso (a, b) -> if ((evalHelper (a) = True) && (evalHelper (b) = True)) then True
 else False
|OrElse (a, b) -> if ((evalHelper (a) = False) && (evalHelper (b) = False)) then False
 else True
|Imply (a, b) -> if ((evalHelper (a) = True) && (evalHelper (b) = False)) then False
 else True
|Equal (a, b) -> if (evalHelper1 (a) = evalHelper1 (b)) then True
 else False)

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|f -> eval (evalHelper (f)))

Total time :0.045993
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub64.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> true

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub65.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec exp_to_int  : (exp -> int) = 
fun e -> 
 (match e with 
|Num n -> n
|Plus (n1, n2) -> (exp_to_int (n1) + exp_to_int (n2))
|Minus (n1, n2) -> (exp_to_int (n1) - exp_to_int (n2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f1 -> not (eval (f1))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> 
 (match (f1, f2) with 
|(True, False) -> false
|_ -> true)
|Equal (e1, e2) -> (exp_to_int (e1) = exp_to_int (e2)))

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec exp_to_int  : (exp -> int) = 
fun e -> 
 (match e with 
|Num n -> n
|Plus (n1, n2) -> (exp_to_int (n1) + exp_to_int (n2))
|Minus (n1, n2) -> (exp_to_int (n1) - exp_to_int (n2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f1 -> not (eval (f1))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> 
 (match (f1, f2) with 
|(True, False) -> false
|_ -> (eval (f2) = eval (f1)))
|Equal (e1, e2) -> (exp_to_int (e1) = exp_to_int (e2)))

Total time :0.28281
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub66.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------
type exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int
type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True

let rec exptoint  = 
fun f -> 
 (match f with 
|Num n -> Num (n)
|Plus (n1, n2) -> 
 (match (n1, n2) with 
|(Num e1, Num e2) -> Num ((e1 + e2))
|(n1, n2) -> Plus ((exptoint (n1), exptoint (n2))))
|Minus (n1, n2) -> 
 (match (n1, n2) with 
|(Num e1, Num e2) -> Num ((e1 - e2))
|(n1, n2) -> Minus ((exptoint (n1), exptoint (n2)))))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not a -> not (eval (a))
|AndAlso (b1, b2) -> (eval (b1) && eval (b2))
|OrElse (b1, b2) -> (eval (b1) || eval (b2))
|Equal (e1, e2) -> if (exptoint (e1) = exptoint (e2)) then true
 else false
|Imply (b1, b2) -> if ((eval (b1) = true) || (eval (b2) = false)) then false
 else true)

-----------------------------
result
-----------------------------
type exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int
type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True

let rec exptoint  = 
fun f -> 
 (match f with 
|Num n -> Num (n)
|Plus (n1, n2) -> 
 (match (n1, n2) with 
|(Num e1, Num e2) -> Num ((e1 + e2))
|(n1, n2) -> Plus ((exptoint (n1), exptoint (n2))))
|Minus (n1, n2) -> 
 (match (n1, n2) with 
|(Num e1, Num e2) -> Num ((e1 - e2))
|(n1, n2) -> Minus ((exptoint (n1), exptoint (n2)))))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not a -> not (eval (a))
|AndAlso (b1, b2) -> (eval (b1) && eval (b2))
|OrElse (b1, b2) -> (eval (b1) || eval (b2))
|Equal (e1, e2) -> if (exptoint (e1) = exptoint (e2)) then true
 else false
|Imply (b1, b2) -> (eval (b2) = eval (b1)))

Total time :0.65929
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub69.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> true

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub73.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------
type exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int
type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True

let rec eval  : (formula -> bool) = 
fun form -> 
let rec value  : (exp -> int) = 
fun x -> 
 (match x with 
|Num a -> a
|Plus (a, b) -> (value (a) + value (b))
|Minus (a, b) -> (value (a) * value (b)))
 in 

 (match form with 
|True -> true
|False -> false
|Not x -> not (eval (x))
|AndAlso (x, y) -> (eval (x) && eval (y))
|OrElse (x, y) -> (eval (x) || eval (y))
|Imply (x, y) -> (not (eval (x)) || eval (y))
|Equal (x, y) -> (value (x) = value (y)))

-----------------------------
result
-----------------------------
type exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int
type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True

let rec eval  : (formula -> bool) = 
fun form -> 
let rec value  : (exp -> int) = 
fun x -> 
 (match x with 
|Num a -> a
|Plus (a, b) -> (value (a) + value (b))
|Minus (a, b) -> (value (a) - value (b)))
 in 

 (match form with 
|True -> true
|False -> false
|Not x -> not (eval (x))
|AndAlso (x, y) -> (eval (x) && eval (y))
|OrElse (x, y) -> (eval (x) || eval (y))
|Imply (x, y) -> (not (eval (x)) || eval (y))
|Equal (x, y) -> (value (x) = value (y)))

Total time :2.330675
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub75.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> true

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub79.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> true

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub81.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> true

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub82.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec getInt  : (exp -> int) = 
fun number -> 
 (match number with 
|Num x -> x
|Plus (a, b) -> (getInt (a) + getInt (b))
|Minus (a, b) -> (getInt (a) - getInt (b)))

let rec getExpression  : (exp -> exp) = 
fun f -> 
 (match f with 
|Num x -> Num (x)
|Plus (a, b) -> Num (getInt (Plus ((a, b))))
|Minus (a, b) -> Num (getInt (Minus ((a, b)))))

let rec getValue  : (formula -> formula) = 
fun f -> 
 (match f with 
|True -> True
|False -> False
|Not x -> if (x = True) then False
 else if (x = False) then True
 else getValue (Not (getValue (x)))
|AndAlso (x, y) -> if ((x = True) && (y = True)) then True
 else if ((x = False) || (y = False)) then False
 else getValue (AndAlso ((getValue (x), getValue (y))))
|OrElse (x, y) -> if ((x = True) && (y = False)) then True
 else if ((x = False) && (y = True)) then True
 else if ((x = False) && (y = False)) then False
 else if ((x = True) && (y = True)) then False
 else getValue (OrElse ((getValue (x), getValue (y))))
|Imply (x, y) -> if (x = False) then True
 else if ((x = True) && (y = True)) then True
 else if ((x = True) && (y = False)) then False
 else getValue (Imply ((getValue (x), getValue (y))))
|Equal (ex1, ex2) -> if (getExpression (ex1) = getExpression (ex2)) then True
 else False)

let rec eval  : (formula -> bool) = 
fun f -> if (f = True) then true
 else if (f = False) then false
 else eval (getValue (f))

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec getInt  : (exp -> int) = 
fun number -> 
 (match number with 
|Num x -> x
|Plus (a, b) -> (getInt (a) + getInt (b))
|Minus (a, b) -> (getInt (a) - getInt (b)))

let rec getExpression  : (exp -> exp) = 
fun f -> 
 (match f with 
|Num x -> Num (x)
|Plus (a, b) -> Num (getInt (Plus ((a, b))))
|Minus (a, b) -> Num (getInt (Minus ((a, b)))))

let rec getValue  : (formula -> formula) = 
fun f -> 
 (match f with 
|True -> True
|False -> False
|Not x -> if (x = True) then False
 else if (x = False) then True
 else getValue (Not (getValue (x)))
|AndAlso (x, y) -> if ((x = True) && (y = True)) then True
 else if ((x = False) || (y = False)) then False
 else getValue (AndAlso ((getValue (x), getValue (y))))
|OrElse (x, y) -> if ((x = True) && (y = False)) then True
 else if ((x = False) && (y = True)) then True
 else if ((x = False) && (y = False)) then False
 else if ((x = True) && (y = True)) then y
 else getValue (OrElse ((getValue (x), getValue (y))))
|Imply (x, y) -> if (x = False) then True
 else if ((x = True) && (y = True)) then True
 else if ((x = True) && (y = False)) then False
 else getValue (Imply ((getValue (x), getValue (y))))
|Equal (ex1, ex2) -> if (getExpression (ex1) = getExpression (ex2)) then True
 else False)

let rec eval  : (formula -> bool) = 
fun f -> if (f = True) then true
 else if (f = False) then false
 else eval (getValue (f))

Total time :0.060757
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub83.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> true

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub88.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not a -> if (a = True) then false
 else true
|OrElse (a, b) -> if ((a = True) || (b = True)) then true
 else false
|AndAlso (a, b) -> if ((a = True) && (b = True)) then true
 else false
|Imply (a, b) -> if ((a = True) && (b = False)) then false
 else true
|Equal (a, b) -> if (a = b) then true
 else false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub9.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f1 -> if eval (f1) then false
 else true
|AndAlso (f1, f2) -> if eval (f1) then eval (f2)
 else false
|OrElse (f1, f2) -> if eval (f1) then true
 else eval (f2)
|Imply (f1, f2) -> if eval (f1) then eval (f2)
 else true
|Equal (exp1, exp2) -> 
let rec e2i exp  = 
 (match exp with 
|Num i -> i
|Plus (e1, e2) -> (e2i (e1) + e2i (e1))
|Minus (e1, e2) -> (e2i (e1) - e2i (e2)))
 in 
(e2i (exp1) = e2i (exp2)))

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f1 -> if eval (f1) then false
 else true
|AndAlso (f1, f2) -> if eval (f1) then eval (f2)
 else false
|OrElse (f1, f2) -> if eval (f1) then true
 else eval (f2)
|Imply (f1, f2) -> if eval (f1) then eval (f2)
 else true
|Equal (exp1, exp2) -> 
let rec e2i exp  = 
 (match exp with 
|Num i -> i
|Plus (e1, e2) -> (e2i (e2) + e2i (e1))
|Minus (e1, e2) -> (e2i (e1) - e2i (e2)))
 in 
(e2i (exp1) = e2i (exp2)))

Total time :0.436054
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub93.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
let rec exptoint  : (exp -> int) = 
fun f1 -> 
 (match f1 with 
|Num fs -> fs
|Plus (fs, ls) -> (exptoint (fs) + exptoint (ls))
|Minus (fs, ls) -> (exptoint (fs) - exptoint (ls)))
 in 

 (match f with 
|True -> true
|False -> false
|AndAlso (fs, ls) -> if (fs = False) then false
 else if (ls = False) then false
 else true
|OrElse (fst, lst) -> if (fst = True) then true
 else if (lst = True) then true
 else false
|Imply (fst, lst) -> if ((fst = True) && (lst = False)) then false
 else true
|Equal (fs, ls) -> if (exptoint (fs) = exptoint (ls)) then true
 else false
|Not a1 -> not (eval (a1)))

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
let rec exptoint  : (exp -> int) = 
fun f1 -> 
 (match f1 with 
|Num fs -> fs
|Plus (fs, ls) -> (exptoint (fs) + exptoint (ls))
|Minus (fs, ls) -> (exptoint (fs) - exptoint (ls)))
 in 

 (match f with 
|True -> true
|False -> false
|AndAlso (fs, ls) -> if (fs = False) then false
 else if (ls = False) then false
 else true
|OrElse (fst, lst) -> if (fst = True) then true
 else if (lst = True) then true
 else false
|Imply (fst, lst) -> if (lst = AndAlso ((True, False))) then false
 else true
|Equal (fs, ls) -> if (exptoint (fs) = exptoint (ls)) then true
 else false
|Not a1 -> not (eval (a1)))

Total time :20.721036
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub1.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|_ -> eval (f))

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub11.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not p -> if (p = True) then false
 else true
|AndAlso (p, q) -> if (p = False) then false
 else if (q = False) then false
 else true
|OrElse (p, q) -> if (p = True) then true
 else if (q = True) then true
 else false
|Imply (p, q) -> if (q = True) then true
 else if (p = False) then true
 else false
|Equal (n1, n2) -> 
let rec exp_to_int  : (exp -> int) = 
fun e -> 
 (match e with 
|Num n -> n
|Plus (n1, n2) -> (exp_to_int (n1) + exp_to_int (n2))
|Minus (n1, n2) -> (exp_to_int (n1) - exp_to_int (n2)))
 in 
if (exp_to_int (n1) = exp_to_int (n2)) then true
 else false)

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub14.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
let rec exptoint  : (exp -> int) = 
fun e -> 
 (match e with 
|Num a -> a
|Plus (a, b) -> (exptoint (a) + exptoint (b))
|Minus (a, b) -> (exptoint (a) - exptoint (b)))
 in 

 (match f with 
|True -> true
|False -> false
|Not x -> if (x = True) then false
 else true
|AndAlso (x, y) -> (eval (x) && eval (y))
|OrElse (x, y) -> (eval (x) || eval (y))
|Imply (x, y) -> 
let imply  : (bool -> (bool -> bool)) = 
fun a b -> if ((a = true) && (b = false)) then false
 else true
 in 
imply (eval (x)) (eval (y))
|Equal (x, y) -> if (exptoint (x) = exptoint (y)) then true
 else false)

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
let rec exptoint  : (exp -> int) = 
fun e -> 
 (match e with 
|Num a -> a
|Plus (a, b) -> (exptoint (a) + exptoint (b))
|Minus (a, b) -> (exptoint (a) - exptoint (b)))
 in 

 (match f with 
|True -> true
|False -> false
|Not x -> if (x = True) then false
 else not (eval (x))
|AndAlso (x, y) -> (eval (x) && eval (y))
|OrElse (x, y) -> (eval (x) || eval (y))
|Imply (x, y) -> 
let imply  : (bool -> (bool -> bool)) = 
fun a b -> if ((a = true) && (b = false)) then false
 else true
 in 
imply (eval (x)) (eval (y))
|Equal (x, y) -> if (exptoint (x) = exptoint (y)) then true
 else false)

Total time :0.038032
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub15.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec value  : (exp -> int) = 
fun n -> 
 (match n with 
|Num h -> h
|Plus (x, y) -> (value (x) + value (y))
|Minus (x, y) -> (value (x) * value (y)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not h -> not (eval (h))
|AndAlso (x, y) -> (eval (x) && eval (y))
|OrElse (x, y) -> (eval (x) || eval (y))
|Imply (x, y) -> if (eval (x) = true) then eval (y)
 else true
|Equal (x, y) -> if (value (x) = value (y)) then true
 else false)

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec value  : (exp -> int) = 
fun n -> 
 (match n with 
|Num h -> h
|Plus (x, y) -> (value (x) + value (y))
|Minus (x, y) -> (value (x) - value (y)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not h -> not (eval (h))
|AndAlso (x, y) -> (eval (x) && eval (y))
|OrElse (x, y) -> (eval (x) || eval (y))
|Imply (x, y) -> if (eval (x) = true) then eval (y)
 else true
|Equal (x, y) -> if (value (x) = value (y)) then true
 else false)

Total time :2.570141
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub16.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec calc  : (exp -> int) = 
fun e -> 
 (match e with 
|Num n -> n
|Plus (n1, n2) -> (calc (n1) + calc (n2))
|Minus (n1, n2) -> (calc (n1) - calc (n2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not b1 -> if eval (b1) then false
 else true
|AndAlso (b1, b2) -> (eval (b1) && eval (b2))
|OrElse (b1, b2) -> (eval (b1) || eval (b2))
|Imply (b1, b2) -> if ((eval (b1) = false) && (eval (b2) = true)) then false
 else true
|Equal (e1, e2) -> (calc (e1) = calc (e2)))

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec calc  : (exp -> int) = 
fun e -> 
 (match e with 
|Num n -> n
|Plus (n1, n2) -> (calc (n1) + calc (n2))
|Minus (n1, n2) -> (calc (n1) - calc (n2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not b1 -> if eval (b1) then false
 else true
|AndAlso (b1, b2) -> (eval (b1) && eval (b2))
|OrElse (b1, b2) -> (eval (b1) || eval (b2))
|Imply (b1, b2) -> (eval (b2) = eval (b1))
|Equal (e1, e2) -> (calc (e1) = calc (e2)))

Total time :0.69901
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub18.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
let pre a  = if (eval (a) = true) then True
 else False
 in 

let rec prem a  = 
 (match a with 
|Num b -> Num (b)
|Plus (Num b, Num c) -> Num ((b + c))
|Minus (Num b, Num c) -> Num ((b - c))
|Plus (b, c) -> prem (Plus ((prem (b), prem (c))))
|Minus (b, c) -> prem (Minus ((prem (b), prem (c)))))
 in 

 (match f with 
|True -> true
|False -> false
|Not a -> if (a = True) then false
 else if (a = False) then true
 else not (eval (a))
|AndAlso (a, b) -> if ((a = True) && (b = True)) then true
 else if ((a = False) && (b = True)) then false
 else if ((a = True) && (b = False)) then false
 else if ((a = False) && (b = False)) then false
 else eval (AndAlso ((pre (a), pre (b))))
|OrElse (a, b) -> if ((a = True) && (b = True)) then true
 else if ((a = False) && (b = True)) then true
 else if ((a = True) && (b = False)) then true
 else if ((a = False) && (b = False)) then false
 else eval (AndAlso ((pre (a), pre (b))))
|Imply (a, b) -> if ((a = True) && (b = True)) then true
 else if ((a = False) && (b = True)) then true
 else if ((a = True) && (b = False)) then false
 else if ((a = False) && (b = False)) then true
 else eval (Imply ((pre (a), pre (b))))
|Equal (a, b) -> if (prem (a) = prem (b)) then true
 else false)

let _  = eval (Not (Not (Not (False))))

let _  = eval (AndAlso ((True, Not (False))))

let _  = eval (AndAlso ((False, False)))

let _  = eval (AndAlso ((True, False)))

let _  = eval (OrElse ((True, Not (False))))

let _  = eval (OrElse ((False, False)))

let _  = eval (OrElse ((True, False)))

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (1))))))

let _  = eval (Equal ((Num (2), Minus ((Num (3), Num (1))))))

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
let pre a  = if (eval (a) = true) then True
 else False
 in 

let rec prem a  = 
 (match a with 
|Num b -> Num (b)
|Plus (Num b, Num c) -> Num ((b + c))
|Minus (Num b, Num c) -> Num ((b - c))
|Plus (b, c) -> prem (Plus ((prem (b), prem (c))))
|Minus (b, c) -> prem (Minus ((prem (b), prem (c)))))
 in 

 (match f with 
|True -> true
|False -> false
|Not a -> if (a = True) then true
 else if (a = False) then true
 else not (eval (a))
|AndAlso (a, b) -> if ((a = True) && (b = True)) then true
 else if ((a = False) && (b = True)) then false
 else if ((a = True) && (b = False)) then false
 else if ((a = False) && (b = False)) then false
 else eval (AndAlso ((pre (a), pre (b))))
|OrElse (a, b) -> if ((a = True) && (b = True)) then true
 else if ((a = False) && (b = True)) then true
 else if ((a = True) && (b = False)) then true
 else if ((a = False) && (b = False)) then false
 else eval (AndAlso ((pre (a), pre (b))))
|Imply (a, b) -> if ((a = True) && (b = True)) then true
 else if ((a = False) && (b = True)) then true
 else if ((a = True) && (b = False)) then false
 else if ((a = False) && (b = False)) then true
 else eval (Imply ((pre (a), pre (b))))
|Equal (a, b) -> if (prem (a) = prem (b)) then true
 else false)

let _  = eval (Not (Not (Not (False))))

let _  = eval (AndAlso ((True, Not (False))))

let _  = eval (AndAlso ((False, False)))

let _  = eval (AndAlso ((True, False)))

let _  = eval (OrElse ((True, Not (False))))

let _  = eval (OrElse ((False, False)))

let _  = eval (OrElse ((True, False)))

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (1))))))

let _  = eval (Equal ((Num (2), Minus ((Num (3), Num (1))))))

Total time :0.257949
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub2.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eq  : (exp -> int) = 
fun f -> 
 (match f with 
|Num a -> a
|Plus (a, b) -> eq (Num ((eq (a) + eq (b))))
|Minus (a, b) -> eq (Num ((eq (a) - eq (b)))))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not True -> false
|Not False -> true
|Not a -> eval (a)
|Equal (a, b) -> if (eq (a) = eq (b)) then true
 else false
|Imply (a, b) -> 
 (match (a, b) with 
|(True, True) -> true
|(True, False) -> false
|(False, True) -> true
|(False, False) -> true
|(_, _) -> eval (Imply ((if (eval (a) = true) then True
 else False, if (eval (b) = true) then True
 else False))))
|AndAlso (a, b) -> 
 (match (a, b) with 
|(True, True) -> true
|(True, False) -> false
|(False, True) -> false
|(False, False) -> false
|(_, _) -> eval (AndAlso ((if (eval (a) = true) then True
 else False, if (eval (b) = true) then True
 else False))))
|OrElse (a, b) -> 
 (match (a, b) with 
|(True, True) -> true
|(True, False) -> true
|(False, True) -> true
|(False, False) -> false
|(_, _) -> eval (OrElse ((if (eval (a) = true) then True
 else False, if (eval (b) = true) then True
 else False)))))

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eq  : (exp -> int) = 
fun f -> 
 (match f with 
|Num a -> a
|Plus (a, b) -> eq (Num ((eq (a) + eq (b))))
|Minus (a, b) -> eq (Num ((eq (a) - eq (b)))))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not True -> false
|Not False -> true
|Not a -> not (eval (a))
|Equal (a, b) -> if (eq (a) = eq (b)) then true
 else false
|Imply (a, b) -> 
 (match (a, b) with 
|(True, True) -> true
|(True, False) -> false
|(False, True) -> true
|(False, False) -> true
|(_, _) -> eval (Imply ((if (eval (a) = true) then True
 else False, if (eval (b) = true) then True
 else False))))
|AndAlso (a, b) -> 
 (match (a, b) with 
|(True, True) -> true
|(True, False) -> false
|(False, True) -> false
|(False, False) -> false
|(_, _) -> eval (AndAlso ((if (eval (a) = true) then True
 else False, if (eval (b) = true) then True
 else False))))
|OrElse (a, b) -> 
 (match (a, b) with 
|(True, True) -> true
|(True, False) -> true
|(False, True) -> true
|(False, False) -> false
|(_, _) -> eval (OrElse ((if (eval (a) = true) then True
 else False, if (eval (b) = true) then True
 else False)))))

Total time :0.37029
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub20.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not x -> if (x = True) then false
 else true
|AndAlso (x, y) -> if ((x = True) && (y = True)) then true
 else false
|OrElse (x, y) -> if ((x = False) && (y = False)) then false
 else true
|Imply (x, y) -> if ((x = True) && (y = False)) then false
 else true
|Equal (x, y) -> if (x = y) then true
 else false)

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub22.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
let rec exp f  = 
 (match f with 
|Num x -> x
|Plus (x, y) -> (exp (x) + exp (y))
|Minus (x, y) -> (exp (x) - exp (y)))
 in 

 (match f with 
|True -> true
|False -> false
|Not x -> if (eval (x) = true) then false
 else true
|AndAlso (x, y) -> if ((eval (x) = true) || (eval (y) = true)) then true
 else false
|OrElse (x, y) -> if ((eval (x) = false) && (eval (y) = false)) then false
 else true
|Imply (x, y) -> if ((eval (x) = true) && (eval (y) = false)) then false
 else true
|Equal (x, y) -> if (exp (x) = exp (y)) then true
 else false)

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
let rec exp f  = 
 (match f with 
|Num x -> x
|Plus (x, y) -> (exp (x) + exp (y))
|Minus (x, y) -> (exp (x) - exp (y)))
 in 

 (match f with 
|True -> true
|False -> false
|Not x -> if (eval (x) = true) then false
 else true
|AndAlso (x, y) -> if ((eval (x) = true) || (eval (y) = true)) then (eval (y) && eval (x))
 else false
|OrElse (x, y) -> if ((eval (x) = false) && (eval (y) = false)) then false
 else true
|Imply (x, y) -> if ((eval (x) = true) && (eval (y) = false)) then false
 else true
|Equal (x, y) -> if (exp (x) = exp (y)) then true
 else false)

Total time :1.077977
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub24.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let eval  : (formula -> bool) = 
fun f -> 
let rec eval' e  = 
 (match e with 
|Num _ -> 0
|Plus (e1, e2) -> (eval' (e1) + eval' (e2))
|Minus (e1, e2) -> (eval' (e1) - eval' (e2)))
 in 

 (match f with 
|Equal (e1, e2) -> if (eval' (e1) = eval' (e2)) then true
 else false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub26.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec math  : (exp -> int) = 
fun e -> 
 (match e with 
|Num e1 -> e1
|Plus (e1, e2) -> (math (e1) + math (e2))
|Minus (e1, e2) -> (math (e1) - math (e2)))

let eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f1 -> if (f1 = True) then false
 else true
|AndAlso (f1, f2) -> if ((f1 = True) && (f2 = True)) then true
 else false
|OrElse (f1, f2) -> if ((f1 = False) && (f2 = False)) then false
 else true
|Imply (f1, f2) -> if (f1 = False) then true
 else if (f2 = True) then true
 else false
|Equal (e1, e2) -> if (math (e1) = math (e2)) then true
 else false)

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub29.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
let rec op  : (exp -> int) = 
fun e -> 
 (match e with 
|Num i -> i
|Plus (e1, e2) -> (op (e1) + op (e2))
|Minus (e1, e2) -> (op (e1) - op (e2)))
 in 

 (match f with 
|True -> true
|False -> false
|Not f -> (eval (f) = false)
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> ((eval (f1) && eval (f2)) || (eval (f2) = false))
|Equal (e1, e2) -> (op (e1) = op (e2)))

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
let rec op  : (exp -> int) = 
fun e -> 
 (match e with 
|Num i -> i
|Plus (e1, e2) -> (op (e1) + op (e2))
|Minus (e1, e2) -> (op (e1) - op (e2)))
 in 

 (match f with 
|True -> true
|False -> false
|Not f -> (eval (f) = false)
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> ((eval (f1) && eval (f2)) || (eval (f1) = false))
|Equal (e1, e2) -> (op (e1) = op (e2)))

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

Total time :0.146906
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub31.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let eval  : (formula -> bool) = 
fun x -> 
 (match x with 
|True -> true
|False -> false
|Not x -> if (x = True) then false
 else true
|AndAlso (x, y) -> if ((x = True) && (y = True)) then true
 else false
|OrElse (x, y) -> if ((x = True) || (y = True)) then true
 else false
|Imply (x, y) -> if ((x = True) && (y = False)) then false
 else true
|Equal (x, y) -> if (x = y) then true
 else false)

let rec cal  : (exp -> int) = 
fun x -> 
 (match x with 
|Num x -> x
|Plus (x, y) -> (cal (x) + cal (y))
|Minus (x, y) -> (cal (x) - cal (y)))

let _  = eval (True)

let _  = eval (AndAlso ((True, False)))

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub37.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval_exp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num a -> a
|Plus (a, b) -> (eval_exp (a) + eval_exp (b))
|Minus (a, b) -> (eval_exp (a) - eval_exp (b)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not a -> if (a = True) then eval (False)
 else eval (True)
|AndAlso (a, b) -> (eval (a) && eval (b))
|OrElse (a, b) -> (eval (a) || eval (b))
|Imply (a, b) -> (eval (Not (a)) || eval (b))
|Equal (a, b) -> if (eval_exp (a) = eval_exp (b)) then true
 else false)

let _  = eval (True)

let _  = eval (Equal ((Num (4), Plus ((Num (1), Num (2))))))

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval_exp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num a -> a
|Plus (a, b) -> (eval_exp (a) + eval_exp (b))
|Minus (a, b) -> (eval_exp (a) - eval_exp (b)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not a -> if eval (a) then eval (False)
 else eval (True)
|AndAlso (a, b) -> (eval (a) && eval (b))
|OrElse (a, b) -> (eval (a) || eval (b))
|Imply (a, b) -> (eval (Not (a)) || eval (b))
|Equal (a, b) -> if (eval_exp (a) = eval_exp (b)) then true
 else false)

let _  = eval (True)

let _  = eval (Equal ((Num (4), Plus ((Num (1), Num (2))))))

Total time :0.309536
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub39.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> 
 (match f with 
|True -> false
|False -> true
|AndAlso (a, b) -> if (eval (a) = eval (b)) then true
 else false
|OrElse (a, b) -> if (eval (a) = eval (b)) then false
 else true
|Imply (a, b) -> if (b = True) then true
 else false
|Equal (a, b) -> if (a = b) then true
 else false))

let _  = eval (Not (True))

let _  = eval (Not (False))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub4.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> if (eval (f) = true) then false
 else true
|AndAlso (f1, f2) -> if (eval (f1) = false) then false
 else eval (f2)
|OrElse (f1, f2) -> if (eval (f1) = true) then true
 else eval (f2)
|Imply (f1, f2) -> if ((eval (f1) = true) && (eval (f2) = false)) then false
 else true
|Equal (e1, e2) -> if (e1 = e2) then true
 else false)

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

let _  = eval (Imply ((Imply ((False, True)), False)))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub40.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec js  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (a1, a2) -> (js (a1) + js (a2))
|Minus (a1, a2) -> (js (a1) - js (a2)))

let eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not a -> if (a = True) then false
 else true
|AndAlso (a1, a2) -> if ((a1 = True) && (a2 = True)) then true
 else false
|OrElse (a1, a2) -> if ((a1 = True) || (a2 = True)) then true
 else false
|Imply (a1, a2) -> if ((a1 = True) && (a2 = False)) then false
 else true
|Equal (a1, a2) -> if (js (a1) = js (a2)) then true
 else false)

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

let _  = eval (Equal ((Num (3), Plus ((Num (1), Num (2))))))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub46.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec calc  : (exp -> int) = 
fun f -> 
 (match f with 
|Num x -> x
|Plus (x, y) -> (calc (x) + calc (y))
|Minus (x, y) -> (calc (x) - calc (y)))

let eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not x -> if (x = True) then false
 else true
|AndAlso (x, y) -> if ((x = True) && (y = True)) then true
 else false
|OrElse (x, y) -> if ((x = True) || (y = False)) then true
 else false
|Imply (x, y) -> if ((x = True) && (y = False)) then false
 else true
|Equal (x, y) -> if (calc (x) = calc (y)) then true
 else false)

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub49.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f0 -> if (f0 = True) then false
 else true
|AndAlso (f1, f2) -> if ((f1 = True) && (f2 = True)) then true
 else false
|OrElse (f1, f2) -> if ((f1 = False) && (f2 = False)) then false
 else true
|Imply (f1, f2) -> if ((f1 = True) && (f2 = False)) then false
 else true
|Equal (e1, e2) -> if (e1 = e2) then true
 else false)

let _  = eval (Imply ((Imply ((True, False)), True)))

let rec num  : (exp -> int) = 
fun n -> 
 (match n with 
|Num i -> i
|Plus (e1, e2) -> (num (e1) + num (e2))
|Minus (e1, e2) -> (num (e1) - num (e2)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub6.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let andAlso (x, y)  = if ((x = true) && (y = true)) then true
 else false

let orElse (x, y)  = if ((x = false) && (y = false)) then false
 else true

let imply (x, y)  = if ((x = false) && (y = true)) then true
 else if ((x = false) && (y = false)) then true
 else if ((x = true) && (y = false)) then false
 else true

let rec equal (x, y)  = if (x = y) then true
 else false

let cal (x : exp)  = 
 (match x with 
|Num n -> n
|Plus (Num a, Num b) -> (a + b)
|Minus (Num a, Num b) -> (a - b))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|AndAlso (x, y) -> if ((x = True) && (y = True)) then true
 else if ((x = False) || (y = False)) then false
 else andAlso ((eval (x), eval (y)))
|OrElse (x, y) -> if ((x = False) && (y = False)) then false
 else if ((x = True) || (y = True)) then true
 else orElse ((eval (x), eval (y)))
|Imply (x, y) -> if ((x = False) && (y = True)) then false
 else if ((x = False) && (y = False)) then true
 else if ((x = True) && (y = False)) then false
 else if ((x = True) && (y = True)) then true
 else imply ((eval (x), eval (y)))
|Not x -> if (x = True) then false
 else if (x = False) then true
 else not (eval (x))
|True -> true
|False -> false
|Equal (x, y) -> if (x = y) then true
 else equal ((cal (x), cal (y))))

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub7.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval_exp  : (exp -> int) = 
fun e -> 
 (match e with 
|Num n -> n
|Plus (e1, e2) -> (eval_exp (e1) + eval_exp (e2))
|Minus (e1, e2) -> (eval_exp (e1) - eval_exp (e2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not b -> not (eval (b))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) && eval (f2)) then false
 else true
|Equal (e1, e2) -> (eval_exp (e1) = eval_exp (e2)))

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval_exp  : (exp -> int) = 
fun e -> 
 (match e with 
|Num n -> n
|Plus (e1, e2) -> (eval_exp (e1) + eval_exp (e2))
|Minus (e1, e2) -> (eval_exp (e1) - eval_exp (e2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not b -> not (eval (b))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) && eval (f2)) then false
 else (eval (f1) = eval (f2))
|Equal (e1, e2) -> (eval_exp (e1) = eval_exp (e2)))

Total time :0.610605
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub70.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec cal  : (exp -> int) = 
fun e -> 
 (match e with 
|Num a -> a
|Plus (a, b) -> (cal (a) + cal (b))
|Minus (a, b) -> (cal (a) - cal (b)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not temp -> eval (temp)
|AndAlso (a, b) -> (eval (a) && eval (b))
|OrElse (a, b) -> (eval (a) || eval (b))
|Imply (a, b) -> if ((eval (a) = true) && (eval (b) = false)) then false
 else true
|Equal (a, b) -> if (cal (a) = cal (b)) then true
 else false)

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

let _  = eval (Imply ((Imply ((True, False)), True)))

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec cal  : (exp -> int) = 
fun e -> 
 (match e with 
|Num a -> a
|Plus (a, b) -> (cal (a) + cal (b))
|Minus (a, b) -> (cal (a) - cal (b)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not temp -> not (eval (temp))
|AndAlso (a, b) -> (eval (a) && eval (b))
|OrElse (a, b) -> (eval (a) || eval (b))
|Imply (a, b) -> if ((eval (a) = true) && (eval (b) = false)) then false
 else true
|Equal (a, b) -> if (cal (a) = cal (b)) then true
 else false)

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

let _  = eval (Imply ((Imply ((True, False)), True)))

Total time :0.329424
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub71.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (exp -> int) = 
fun f -> 
 (match f with 
|Num x -> x
|Plus (x, y) -> (eval (x) + eval (y))
|Minus (x, y) -> (eval (x) - eval (y)))

let eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not x -> if (x = True) then false
 else true
|AndAlso (x, y) -> if ((x = True) && (y = True)) then true
 else false
|OrElse (x, y) -> if ((x = True) || (y = False)) then true
 else false
|Imply (x, y) -> if ((x = True) && (y = False)) then false
 else true
|Equal (x, y) -> if (eval (x) = eval (y)) then true
 else false)

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub73.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec cal  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (g, h) -> (cal (g) + cal (h))
|Minus (g, h) -> (cal (g) - cal (h)))

let eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not h -> if (h = True) then false
 else true
|AndAlso (g, h) -> if ((g = True) && (h = True)) then true
 else false
|OrElse (g, h) -> if ((g = False) && (h = False)) then false
 else true
|Imply (g, h) -> if ((g = True) && (h = False)) then false
 else true
|Equal (g, h) -> if (cal (g) = cal (h)) then true
 else false)

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub8.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec chlwhd  : (exp -> int) = 
fun e -> 
 (match e with 
|Num a -> a
|Plus (a, b) -> (chlwhd (a) + chlwhd (b))
|Minus (a, b) -> (chlwhd (a) - chlwhd (b)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f', f) -> (eval (f') && eval (f))
|OrElse (f', f) -> (eval (f') || eval (f))
|Imply (f', f) -> if ((eval (f') = true) && (eval (f) = false)) then false
 else if ((eval (f') = true) && (eval (f) = true)) then true
 else if ((eval (f') = false) && (eval (f) = true)) then true
 else false
|Equal (a, b) -> if (chlwhd (a) = chlwhd (b)) then true
 else false)

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec chlwhd  : (exp -> int) = 
fun e -> 
 (match e with 
|Num a -> a
|Plus (a, b) -> (chlwhd (a) + chlwhd (b))
|Minus (a, b) -> (chlwhd (a) - chlwhd (b)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f', f) -> (eval (f') && eval (f))
|OrElse (f', f) -> (eval (f') || eval (f))
|Imply (f', f) -> if ((eval (f') = true) && (eval (f) = false)) then false
 else if ((eval (f') = true) && (eval (f) = true)) then true
 else true
|Equal (a, b) -> if (chlwhd (a) = chlwhd (b)) then true
 else false)

Total time :0.063992
../engine/main.native -fix -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub9.ml -solution ../benchmarks_correct/KoreaUniv_formula_16/sol.ml -entry eval -testcases ../testcases/formula_testcases
-----------------------------
original
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not b -> if (eval (b) = true) then true
 else false
|Imply (a, b) -> if (eval (a) = false) then true
 else if (eval (b) = true) then true
 else false
|AndAlso (a, b) -> if ((eval (a) = true) && (eval (b) = true)) then true
 else false
|OrElse (a, b) -> if (eval (a) = true) then true
 else if (eval (b) = true) then true
 else false
|Equal (a, b) -> 
let rec eval_exp  : (exp -> int) = 
fun e -> 
 (match e with 
|Num n -> n
|Plus (n1, n2) -> (eval_exp (n1) + eval_exp (n2))
|Minus (n1, n2) -> (eval_exp (n1) - eval_exp (n2)))
 in 
if (eval_exp (a) = eval_exp (b)) then true
 else false)

-----------------------------
result
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not b -> if (eval (b) = false) then true
 else false
|Imply (a, b) -> if (eval (a) = false) then true
 else if (eval (b) = true) then true
 else false
|AndAlso (a, b) -> if ((eval (a) = true) && (eval (b) = true)) then true
 else false
|OrElse (a, b) -> if (eval (a) = true) then true
 else if (eval (b) = true) then true
 else false
|Equal (a, b) -> 
let rec eval_exp  : (exp -> int) = 
fun e -> 
 (match e with 
|Num n -> n
|Plus (n1, n2) -> (eval_exp (n1) + eval_exp (n2))
|Minus (n1, n2) -> (eval_exp (n1) - eval_exp (n2)))
 in 
if (eval_exp (a) = eval_exp (b)) then true
 else false)

Total time :0.101096

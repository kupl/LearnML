../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub123.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
let rec evalexp  : (exp -> int) = 
fun f1 -> 
 (match f1 with 
|Num a -> a
|Plus (a, b) -> (evalexp (a) + evalexp (b))
|Minus (a, b) -> (evalexp (a) - evalexp (b)))
 in 

 (match f with 
|True -> true
|False -> false
|Not f1 -> if (f1 = True) then false
 else true
|AndAlso (f1, f2) -> if (f1 = False) then false
 else if (f2 = True) then true
 else false
|OrElse (f1, f2) -> if (f1 = True) then true
 else if (f2 = True) then true
 else false
|Imply (f1, f2) -> if ((f1 = True) && (f2 = False)) then false
 else true
|Equal (a, b) -> if (evalexp (a) = evalexp (b)) then true
 else false)

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
evalexp -> evalExp}
------Remainings in solution ------
{}
Fail to Repair

(* Type error *)
Error occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub125.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases

../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub129.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec expfun  : (exp -> int) = 
fun q -> 
 (match q with 
|Num i -> i
|Plus (i, k) -> (expfun (i) + expfun (k))
|Minus (i, k) -> (expfun (i) - expfun (k)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f1 -> if (f1 = True) then false
 else true
|AndAlso (f1, f2) -> if ((f1 = True) && (f2 = True)) then true
 else false
|OrElse (f1, f2) -> if ((f1 = False) && (f2 = False)) then false
 else true
|Imply (f1, f2) -> if ((f1 = True) && (f2 = False)) then false
 else true
|Equal (q1, q2) -> if (expfun (q1) = expfun (q2)) then true
 else false)

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
expfun -> evalExp}
------Remainings in solution ------
{}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub139.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
let rec foldeval b  = 
 (match b with 
|Num i -> i
|Plus (l, m) -> (foldeval (l) + foldeval (m))
|Minus (l, m) -> (foldeval (l) - foldeval (m)))
 in 

let rec fold a  = 
 (match a with 
|True -> True
|False -> False
|Not x1 -> if (fold (x1) = True) then False
 else True
|AndAlso (x2, y2) -> if ((fold (x2) = True) && (fold (y2) = True)) then True
 else False
|OrElse (x3, y3) -> if ((fold (x3) = True) || (fold (y3) = True)) then True
 else False
|Imply (x4, y4) -> if (fold (x4) = False) then True
 else if (y4 = True) then True
 else False
|Equal (l5, m5) -> if (foldeval (l5) = foldeval (m5)) then True
 else False)
 in 
if (fold (f) = True) then true
 else false

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
foldeval -> evalExp}
------Remainings in solution ------
{}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
let rec foldeval b  = 
 (match b with 
|Num i -> i
|Plus (l, m) -> (foldeval (l) + foldeval (m))
|Minus (l, m) -> (foldeval (l) - foldeval (m)))
 in 

let rec fold a  = 
 (match a with 
|True -> True
|False -> False
|Not x1 -> if (fold (x1) = True) then False
 else True
|AndAlso (x2, y2) -> if ((fold (x2) = True) && (fold (y2) = True)) then True
 else False
|OrElse (x3, y3) -> if ((fold (x3) = True) || (fold (y3) = True)) then True
 else False
|Imply (x4, y4) -> if (fold (x4) = False) then True
 else if (y4 = True) then True
 else False
|Equal (l5, m5) -> if (foldeval (l5) = foldeval (m5)) then True
 else False)
 in 

 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f1))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (foldeval (exp1) = foldeval (exp2)))

Time : 1.19085907936
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub140.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalexp f  = 
 (match f with 
|Num x -> x
|Plus (x, y) -> (evalexp (x) + evalexp (y))
|Minus (x, y) -> (evalexp (x) + evalexp (y)))

let rec eval f  = 
 (match f with 
|True -> true
|False -> false
|Not p -> if (eval (p) = true) then false
 else true
|AndAlso (p, q) -> if ((eval (p) = true) && (eval (q) = true)) then true
 else false
|OrElse (p, q) -> if ((eval (p) = true) || (eval (q) = true)) then true
 else false
|Imply (p, q) -> if (eval (q) = true) then true
 else false
|Equal (p, q) -> if (evalexp (p) = evalexp (q)) then true
 else false)

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
evalexp -> evalExp}
------Remainings in solution ------
{}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalexp f  = 
 (match f with 
|Num x -> x
|Plus (x, y) -> (evalexp (x) + evalexp (y))
|Minus (x, y) -> (evalexp (x) - evalexp (y)))

let rec eval f  = 
 (match f with 
|True -> true
|False -> false
|Not p -> if (eval (p) = true) then false
 else true
|AndAlso (p, q) -> if ((eval (p) = true) && (eval (q) = true)) then true
 else false
|OrElse (p, q) -> if ((eval (p) = true) || (eval (q) = true)) then true
 else false
|Imply (p, q) -> if ((eval (p) = false) || (eval (q) = true)) then true
 else false
|Equal (p, q) -> if (evalexp (p) = evalexp (q)) then true
 else false)

Time : 0.224416017532
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub141.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> true

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 0
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval}
------Remainings in solution ------
{evalExp}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp (f : exp)  : int = 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f1))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

Time : 0.771132946014
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub15.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not b -> if (b = True) then eval (True)
 else eval (False)
|AndAlso (a, b) -> if (a = False) then eval (False)
 else if (b = False) then eval (False)
 else eval (True)
|OrElse (a, b) -> if (a = True) then eval (True)
 else if (b = True) then eval (True)
 else eval (False)
|Imply (a, b) -> if (a = False) then eval (True)
 else if (b = True) then eval (True)
 else eval (False)
|Equal (a, b) -> if (a = b) then eval (True)
 else eval (False))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 0
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval}
------Remainings in solution ------
{evalExp}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp (f : exp)  : int = 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not b -> not (eval (b))
|AndAlso (a, b) -> if (a = False) then eval (False)
 else if (b = False) then eval (False)
 else eval (True)
|OrElse (a, b) -> if (a = True) then eval (True)
 else if (b = True) then eval (True)
 else eval (False)
|Imply (a, b) -> if ((eval (a) = false) || (eval (b) = true)) then eval (True)
 else if (b = True) then eval (True)
 else eval (False)
|Equal (a, b) -> (evalExp (a) = evalExp (b)))

Time : 1.09101819992
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub20.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|Not True -> false
|Not False -> true
|AndAlso (a, b) -> (eval (a) && eval (b))
|OrElse (a, b) -> (eval (a) || eval (b)))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 0
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval}
------Remainings in solution ------
{evalExp}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub23.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not a -> not (eval (a))
|AndAlso (a, b) -> (eval (a) && eval (b))
|OrElse (a, b) -> (eval (a) || eval (b))
|Imply (a, b) -> if eval (a) then eval (b)
 else true
|Equal (a, b) -> 
let rec _eval x  = 
 (match x with 
|Num n -> n
|Plus (n1, n2) -> (_eval (n1) + _eval (n2))
|Minus (n1, n2) -> (_eval (n1) - _eval (n2)))
 in 
if (_eval (a) < _eval (b)) then true
 else false)

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{_eval -> evalExp,
eval -> eval}
------Remainings in solution ------
{}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not a -> not (eval (a))
|AndAlso (a, b) -> (eval (a) && eval (b))
|OrElse (a, b) -> (eval (a) || eval (b))
|Imply (a, b) -> if eval (a) then eval (b)
 else true
|Equal (a, b) -> 
let rec _eval x  = 
 (match x with 
|Num n -> n
|Plus (n1, n2) -> (_eval (n1) + _eval (n2))
|Minus (n1, n2) -> (_eval (n1) - _eval (n2)))
 in 
(_eval (a) = _eval (b)))

Time : 1.01945900917
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub24.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval_op op  = 
 (match op with 
|Num a -> a
|Minus (exp1, exp2) -> (eval_op (exp1) - eval_op (exp2))
|Plus (exp1, exp2) -> (eval_op (exp1) + eval_op (exp2)))
and eval f  = 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> (not (eval (f1)) && eval (f2))
|Equal (exp1, exp2) -> if (eval_op (exp1) = eval_op (exp2)) then true
 else false)

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
eval_op -> evalExp}
------Remainings in solution ------
{}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval_op op  = 
 (match op with 
|Num a -> a
|Minus (exp1, exp2) -> (eval_op (exp1) - eval_op (exp2))
|Plus (exp1, exp2) -> (eval_op (exp1) + eval_op (exp2)))
and eval f  = 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> if (eval_op (exp1) = eval_op (exp2)) then true
 else false)

Time : 0.0140569210052
Error occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub27.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub32.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
let rec calculate f2  = 
 (match f2 with 
|Num i -> i
|Plus (e1, e2) -> (calculate (e1) + calculate (e2))
|Minus (e1, e2) -> (calculate (e1) - calculate (e2)))
 in 

 (match f with 
|True -> true
|False -> false
|Not f -> if (f = True) then false
 else true
|AndAlso (f1, f2) -> if ((f1 = True) && (f2 = True)) then true
 else false
|OrElse (f1, f2) -> if ((f1 = True) || (f2 = True)) then true
 else false
|Imply (f1, f2) -> if ((f1 = True) && (f2 = False)) then false
 else true
|Equal (e1, e2) -> if (calculate (e1) = calculate (e2)) then true
 else false)

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{calculate -> evalExp,
eval -> eval}
------Remainings in solution ------
{}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub33.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec expfun e  = 
 (match e with 
|Num n -> n
|Plus (e1, e2) -> (expfun (e1) + expfun (e2))
|Minus (e1, e2) -> (expfun (e1) - expfun (e2)))

let rec eval f  = 
 (match f with 
|True -> true
|False -> false
|Not f1 -> if (f1 = True) then false
 else true
|AndAlso (f1, f2) -> if ((f1 = True) && (f2 = True)) then true
 else false
|OrElse (f1, f2) -> if ((f1 = True) || (f2 = True)) then true
 else false
|Imply (f1, f2) -> if ((f1 = True) && (f2 = False)) then false
 else true
|Equal (e1, e2) -> if (expfun (e1) = expfun (e2)) then true
 else false)

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
expfun -> evalExp}
------Remainings in solution ------
{}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub36.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not x -> not (eval (x))
|AndAlso (x, y) -> (eval (x) && eval (y))
|OrElse (x, y) -> (eval (x) || eval (y))
|Imply (x, y) -> (not (eval (x)) || eval (y))
|Equal (x, y) -> (x = y))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 0
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval}
------Remainings in solution ------
{evalExp}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp (f : exp)  : int = 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not x -> not (eval (x))
|AndAlso (x, y) -> (eval (x) && eval (y))
|OrElse (x, y) -> (eval (x) || eval (y))
|Imply (x, y) -> (not (eval (x)) || eval (y))
|Equal (x, y) -> (evalExp (x) = evalExp (y)))

Time : 0.0442380905151
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub38.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec getInt  : (exp -> int) = 
fun number -> 
 (match number with 
|Num x -> x
|Plus (a, b) -> (getInt (a) + getInt (b))
|Minus (a, b) -> (getInt (a) - getInt (b)))

let rec getExpression  : (exp -> exp) = 
fun f -> 
 (match f with 
|Num x -> Num (x)
|Plus (a, b) -> Num (getInt (Plus ((a, b))))
|Minus (a, b) -> Num (getInt (Minus ((a, b)))))

let rec getValue  : (formula -> formula) = 
fun f -> 
 (match f with 
|True -> True
|False -> False
|Not x -> if (x = True) then False
 else if (x = False) then True
 else getValue (Not (getValue (x)))
|AndAlso (x, y) -> if ((x = True) && (y = True)) then True
 else if ((x = False) || (y = False)) then False
 else getValue (AndAlso ((getValue (x), getValue (y))))
|OrElse (x, y) -> if ((x = True) && (y = False)) then True
 else if ((x = False) && (y = True)) then True
 else if ((x = False) && (y = False)) then False
 else if ((x = True) && (y = True)) then False
 else getValue (OrElse ((getValue (x), getValue (y))))
|Imply (x, y) -> if (x = False) then True
 else if ((x = True) && (y = True)) then True
 else if ((x = True) && (y = False)) then False
 else getValue (Imply ((getValue (x), getValue (y))))
|Equal (ex1, ex2) -> if (getExpression (ex1) = getExpression (ex2)) then True
 else False)

let rec eval  : (formula -> bool) = 
fun f -> if (f = True) then true
 else if (f = False) then false
 else eval (getValue (f))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
getInt -> evalExp}
------Remainings in solution ------
{}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec getInt  : (exp -> int) = 
fun number -> 
 (match number with 
|Num x -> x
|Plus (a, b) -> (getInt (a) + getInt (b))
|Minus (a, b) -> (getInt (a) - getInt (b)))

let rec getExpression  : (exp -> exp) = 
fun f -> 
 (match f with 
|Num x -> Num (x)
|Plus (a, b) -> Num (getInt (Plus ((a, b))))
|Minus (a, b) -> Num (getInt (Minus ((a, b)))))

let rec getValue  : (formula -> formula) = 
fun f -> 
 (match f with 
|True -> True
|False -> False
|Not x -> if (x = True) then False
 else if (x = False) then True
 else getValue (Not (getValue (x)))
|AndAlso (x, y) -> if ((x = True) && (y = True)) then True
 else if ((x = False) || (y = False)) then False
 else getValue (AndAlso ((getValue (x), getValue (y))))
|OrElse (x, y) -> if ((x = True) && (y = False)) then True
 else if ((x = False) && (y = True)) then True
 else if ((x = False) && (y = False)) then False
 else if ((x = True) && (y = True)) then False
 else getValue (OrElse ((getValue (x), getValue (y))))
|Imply (x, y) -> if (x = False) then True
 else if ((x = True) && (y = True)) then True
 else if ((x = True) && (y = False)) then False
 else getValue (Imply ((getValue (x), getValue (y))))
|Equal (ex1, ex2) -> if (getExpression (ex1) = getExpression (ex2)) then True
 else False)

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f1))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (getExpression (exp1) = getExpression (exp2)))

Time : 1.97615885735
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub41.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let andAlso  : ((bool * bool) -> bool) = 
fun f -> 
 (match f with 
|(true, true) -> true
|_ -> false)

let orElse  : ((bool * bool) -> bool) = 
fun f -> 
 (match f with 
|(false, false) -> false
|_ -> true)

let imply  : ((bool * bool) -> bool) = 
fun f -> 
 (match f with 
|(frue, false) -> false
|_ -> true)

let rec ca  : (exp -> int) = 
fun f -> 
 (match f with 
|Num a -> a
|Plus (a, b) -> (ca (a) + ca (b))
|Minus (a, b) -> (ca (a) - ca (b)))

let equal  : ((exp * exp) -> bool) = 
fun f -> 
 (match f with 
|(a, b) -> if (ca (a) = ca (b)) then true
 else false)

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|AndAlso (a, b) -> andAlso ((eval (a), eval (b)))
|OrElse (a, b) -> orElse ((eval (a), eval (b)))
|Imply (a, b) -> imply ((eval (a), eval (b)))
|Equal (a, b) -> equal ((a, b))
|_ -> raise Failure ("eval requires formula"))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{ca -> evalExp,
eval -> eval}
------Remainings in solution ------
{}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub44.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> true

let rec eval f  = 
let rec expin f  = 
 (match f with 
|Num n -> n
|Plus (e1, e2) -> (expin (e1) + expin (e2))
|Minus (e1, e2) -> (expin (e1) - expin (e2)))
 in 

 (match f with 
|True -> true
|False -> false
|Not f1 -> if (f1 = True) then false
 else true
|AndAlso (f1, f2) -> if ((f1 = True) && (f2 = True)) then true
 else false
|OrElse (f1, f2) -> if ((f1 = True) || (f2 = True)) then true
 else false
|Imply (f1, f2) -> if ((f1 = True) && (f2 = False)) then false
 else true
|Equal (e1, e2) -> if (expin (e1) = expin (e2)) then true
 else false)

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
expin -> evalExp}
------Remainings in solution ------
{}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub45.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------
type exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int
type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True

let rec eval_exp a  = 
 (match a with 
|Num n -> n
|Plus (n1, n2) -> (eval_exp (n1) + eval_exp (n2))
|Minus (n1, n2) -> (eval_exp (n1) + eval_exp (n2)))

let rec eval thing  = 
 (match thing with 
|True -> true
|False -> false
|Not a -> if eval (a) then false
 else true
|AndAlso (a, b) -> (eval (a) && eval (b))
|OrElse (a, b) -> (eval (a) || eval (b))
|Imply (a, b) -> if ((eval (a) = true) && (eval (b) = false)) then false
 else true
|Equal (a, b) -> if (eval_exp (a) = eval_exp (b)) then true
 else false)

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
eval_exp -> evalExp}
------Remainings in solution ------
{}
-----------------------------
Patch
-----------------------------
type exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int
type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True

let rec eval_exp a  = 
 (match a with 
|Num n -> n
|Plus (n1, n2) -> (eval_exp (n1) + eval_exp (n2))
|Minus (n1, n2) -> (eval_exp (n1) - eval_exp (n2)))

let rec eval thing  = 
 (match thing with 
|True -> true
|False -> false
|Not a -> if eval (a) then false
 else true
|AndAlso (a, b) -> (eval (a) && eval (b))
|OrElse (a, b) -> (eval (a) || eval (b))
|Imply (a, b) -> if ((eval (a) = true) && (eval (b) = false)) then false
 else true
|Equal (a, b) -> if (eval_exp (a) = eval_exp (b)) then true
 else false)

Time : 0.0121440887451
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub46.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not ev -> if (ev = True) then false
 else true
|AndAlso (ev1, ev2) -> if ((ev1 = True) && (ev2 = True)) then true
 else false
|OrElse (ev1, ev2) -> if ((ev1 = False) && (ev2 = False)) then false
 else true
|Imply (ev1, ev2) -> if ((ev1 = True) && (ev2 = False)) then false
 else true
|Equal (in1, in2) -> 
let rec pl_mi x  = 
 (match x with 
|Num n -> n
|Plus (n1, n2) -> (pl_mi (n1) + pl_mi (n2))
|Minus (n1, n2) -> (pl_mi (n1) - pl_mi (n2)))
 in 
if (pl_mi (in1) = pl_mi (in2)) then true
 else false)

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
pl_mi -> evalExp}
------Remainings in solution ------
{}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub47.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> true

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 0
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval}
------Remainings in solution ------
{evalExp}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp (f : exp)  : int = 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f1))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

Time : 0.784984111786
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub48.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalexp exp  = 
 (match exp with 
|Num n -> n
|Plus (n1, n2) -> 
 (match (n1, n2) with 
|(_, _) -> (evalexp (n1) + evalexp (n2)))
|Minus (n1, n2) -> 
 (match (n1, n2) with 
|(_, _) -> (evalexp (n1) - evalexp (n2))))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f' -> 
 (match f' with 
|True -> false
|False -> true
|_ -> eval (f'))
|AndAlso (f1', f2') -> 
 (match (f1', f2') with 
|(True, True) -> true
|(False, _) -> false
|(_, False) -> false
|(_, _) -> (eval (f1') && eval (f2')))
|OrElse (f1', f2') -> 
 (match (f1', f2') with 
|(True, True) -> true
|(True, False) -> true
|(False, True) -> true
|(False, False) -> false
|(_, _) -> (eval (f1') || eval (f2')))
|Imply (f1', f2') -> 
 (match (f1', f2') with 
|(True, True) -> true
|(True, False) -> false
|(False, True) -> true
|(False, False) -> true
|(_, _) -> (eval (Not (f1')) || eval (f2')))
|Equal (exp1, exp2) -> 
 (match (evalexp (exp1), evalexp (exp2)) with 
|(a, b) -> if (a = b) then true
 else false))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
evalexp -> evalExp}
------Remainings in solution ------
{}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalexp exp  = 
 (match exp with 
|Num n -> n
|Plus (n1, n2) -> 
 (match (n1, n2) with 
|(_, _) -> (evalexp (n1) + evalexp (n2)))
|Minus (n1, n2) -> 
 (match (n1, n2) with 
|(_, _) -> (evalexp (n1) - evalexp (n2))))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f' -> not (eval (f'))
|AndAlso (f1', f2') -> 
 (match (f1', f2') with 
|(True, True) -> true
|(False, _) -> false
|(_, False) -> false
|(_, _) -> (eval (f1') && eval (f2')))
|OrElse (f1', f2') -> 
 (match (f1', f2') with 
|(True, True) -> true
|(True, False) -> true
|(False, True) -> true
|(False, False) -> false
|(_, _) -> (eval (f1') || eval (f2')))
|Imply (f1', f2') -> 
 (match (f1', f2') with 
|(True, True) -> true
|(True, False) -> false
|(False, True) -> true
|(False, False) -> true
|(_, _) -> (eval (Not (f1')) || eval (f2')))
|Equal (exp1, exp2) -> 
 (match (evalexp (exp1), evalexp (exp2)) with 
|(a, b) -> if (a = b) then true
 else false))

Time : 0.00444984436035
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub51.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let imply v  = 
 (match v with 
|(true, x) -> x
|(false, x) -> true)

let rec calc e  = 
 (match e with 
|Num n -> n
|Plus (e1, e2) -> (calc (e1) + calc (e2))
|Minus (e1, e2) -> (calc (e1) - calc (e2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not fm -> not (eval (fm))
|AndAlso (fm1, fm2) -> (eval (fm1) && eval (fm2))
|OrElse (fm1, fm2) -> (eval (fm2) || eval (fm2))
|Imply (fm1, fm2) -> imply ((eval (fm1), eval (fm2)))
|Equal (e1, e2) -> (calc (e1) = calc (e2)))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{calc -> evalExp,
eval -> eval}
------Remainings in solution ------
{}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let imply v  = 
 (match v with 
|(true, x) -> x
|(false, x) -> true)

let rec calc e  = 
 (match e with 
|Num n -> n
|Plus (e1, e2) -> (calc (e1) + calc (e2))
|Minus (e1, e2) -> (calc (e1) - calc (e2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not fm -> not (eval (fm))
|AndAlso (fm1, fm2) -> (eval (fm1) && eval (fm2))
|OrElse (fm1, fm2) -> (eval (fm2) || eval (fm1))
|Imply (fm1, fm2) -> imply ((eval (fm1), eval (fm2)))
|Equal (e1, e2) -> (calc (e1) = calc (e2)))

Time : 0.00558495521545
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub52.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec arithmetic  = 
fun f -> 
 (match f with 
|Num num -> num
|Plus (num1, num2) -> (arithmetic (num1) + arithmetic (num2))
|Minus (num1, num2) -> (arithmetic (num1) - arithmetic (num2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not fm -> if eval (fm) then false
 else true
|AndAlso (fm1, fm2) -> (eval (fm1) && eval (fm2))
|OrElse (fm1, fm2) -> (eval (fm1) || eval (fm2))
|Imply (fm1, fm2) -> if eval (fm1) then if eval (fm2) then true
 else false
 else false
|Equal (exp1, exp2) -> (arithmetic (exp1) = arithmetic (exp2)))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{arithmetic -> evalExp,
eval -> eval}
------Remainings in solution ------
{}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec arithmetic  = 
fun f -> 
 (match f with 
|Num num -> num
|Plus (num1, num2) -> (arithmetic (num1) + arithmetic (num2))
|Minus (num1, num2) -> (arithmetic (num1) - arithmetic (num2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not fm -> if eval (fm) then false
 else true
|AndAlso (fm1, fm2) -> (eval (fm1) && eval (fm2))
|OrElse (fm1, fm2) -> (eval (fm1) || eval (fm2))
|Imply (fm1, fm2) -> if ((eval (fm1) = false) || (eval (fm2) = true)) then true
 else false
|Equal (exp1, exp2) -> (arithmetic (exp1) = arithmetic (exp2)))

Time : 0.248811006546
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub61.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalHelper1  : (exp -> int) = 
fun f -> 
 (match f with 
|Num a -> a
|Minus (a, b) -> (evalHelper1 (a) - evalHelper1 (b))
|Plus (a, b) -> (evalHelper1 (a) + evalHelper1 (b)))

let rec evalHelper  : (formula -> formula) = 
fun f -> 
 (match f with 
|True -> True
|False -> False
|Not a -> if (a = True) then False
 else True
|AndAlso (a, b) -> if ((evalHelper (a) = True) && (evalHelper (b) = True)) then True
 else False
|OrElse (a, b) -> if ((evalHelper (a) = False) && (evalHelper (b) = False)) then False
 else True
|Imply (a, b) -> if ((evalHelper (a) = True) && (evalHelper (b) = False)) then False
 else True
|Equal (a, b) -> if (evalHelper1 (a) = evalHelper1 (b)) then True
 else False)

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|f -> eval (evalHelper (f)))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
evalHelper1 -> evalExp}
------Remainings in solution ------
{}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub64.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> true

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 0
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval}
------Remainings in solution ------
{evalExp}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp (f : exp)  : int = 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f1))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

Time : 0.778472900391
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub65.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec exp_to_int  : (exp -> int) = 
fun e -> 
 (match e with 
|Num n -> n
|Plus (n1, n2) -> (exp_to_int (n1) + exp_to_int (n2))
|Minus (n1, n2) -> (exp_to_int (n1) - exp_to_int (n2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f1 -> not (eval (f1))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> 
 (match (f1, f2) with 
|(True, False) -> false
|_ -> true)
|Equal (e1, e2) -> (exp_to_int (e1) = exp_to_int (e2)))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
exp_to_int -> evalExp}
------Remainings in solution ------
{}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec exp_to_int  : (exp -> int) = 
fun e -> 
 (match e with 
|Num n -> n
|Plus (n1, n2) -> (exp_to_int (n1) + exp_to_int (n2))
|Minus (n1, n2) -> (exp_to_int (n1) - exp_to_int (n2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f1 -> not (eval (f1))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (e1, e2) -> (exp_to_int (e1) = exp_to_int (e2)))

Time : 0.0144391059875
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub66.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------
type exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int
type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True

let rec exptoint  = 
fun f -> 
 (match f with 
|Num n -> Num (n)
|Plus (n1, n2) -> 
 (match (n1, n2) with 
|(Num e1, Num e2) -> Num ((e1 + e2))
|(n1, n2) -> Plus ((exptoint (n1), exptoint (n2))))
|Minus (n1, n2) -> 
 (match (n1, n2) with 
|(Num e1, Num e2) -> Num ((e1 - e2))
|(n1, n2) -> Minus ((exptoint (n1), exptoint (n2)))))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not a -> not (eval (a))
|AndAlso (b1, b2) -> (eval (b1) && eval (b2))
|OrElse (b1, b2) -> (eval (b1) || eval (b2))
|Equal (e1, e2) -> if (exptoint (e1) = exptoint (e2)) then true
 else false
|Imply (b1, b2) -> if ((eval (b1) = true) || (eval (b2) = false)) then false
 else true)

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/16/sub72.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec cal num  = 
 (match num with 
|Num i -> Num (i)
|Plus (a, b) -> 
 (match (a, b) with 
|(Num a2, Num b2) -> Num ((a2 + b2))
|(_, _) -> Plus ((cal (a), cal (b))))
|Minus (a, b) -> 
 (match (a, b) with 
|(Num a2, Num b2) -> Num ((a2 - b2))
|(_, _) -> Minus ((cal (a), cal (b)))))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not x -> if (eval (x) = true) then false
 else true
|AndAlso (x, y) -> (eval (x) && eval (y))
|OrElse (x, y) -> (eval (x) || eval (y))
|Imply (x, y) -> if ((eval (x) = true) && (eval (y) = false)) then false
 else true
|Equal (x, y) -> 
 (match (x, y) with 
|(Num x2, Num y2) -> if (x2 = y2) then true
 else false
|(_, _) -> eval (Equal ((cal (x), cal (y))))))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
exptoint -> cal}
------Remainings in solution ------
{}
-----------------------------
Patch
-----------------------------
type exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int
type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True

let rec exptoint  = 
fun f -> 
 (match f with 
|Num n -> Num (n)
|Plus (n1, n2) -> 
 (match (n1, n2) with 
|(Num e1, Num e2) -> Num ((e1 + e2))
|(n1, n2) -> Plus ((exptoint (n1), exptoint (n2))))
|Minus (n1, n2) -> 
 (match (n1, n2) with 
|(Num e1, Num e2) -> Num ((e1 - e2))
|(n1, n2) -> Minus ((exptoint (n1), exptoint (n2)))))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not a -> not (eval (a))
|AndAlso (b1, b2) -> (eval (b1) && eval (b2))
|OrElse (b1, b2) -> (eval (b1) || eval (b2))
|Equal (e1, e2) -> if (exptoint (e1) = exptoint (e2)) then true
 else false
|Imply (b1, b2) -> if ((eval (b1) = true) && (eval (b2) = false)) then false
 else true)

Time : 0.0205931663513
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub69.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> true

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 0
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval}
------Remainings in solution ------
{evalExp}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp (f : exp)  : int = 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f1))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

Time : 0.773571014404
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub73.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------
type exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int
type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True

let rec eval  : (formula -> bool) = 
fun form -> 
let rec value  : (exp -> int) = 
fun x -> 
 (match x with 
|Num a -> a
|Plus (a, b) -> (value (a) + value (b))
|Minus (a, b) -> (value (a) * value (b)))
 in 

 (match form with 
|True -> true
|False -> false
|Not x -> not (eval (x))
|AndAlso (x, y) -> (eval (x) && eval (y))
|OrElse (x, y) -> (eval (x) || eval (y))
|Imply (x, y) -> (not (eval (x)) || eval (y))
|Equal (x, y) -> (value (x) = value (y)))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
value -> evalExp}
------Remainings in solution ------
{}
-----------------------------
Patch
-----------------------------
type exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int
type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True

let rec eval  : (formula -> bool) = 
fun form -> 
let rec value  : (exp -> int) = 
fun x -> 
 (match x with 
|Num a -> a
|Plus (a, b) -> (value (a) + value (b))
|Minus (a, b) -> (value (a) - value (b)))
 in 

 (match form with 
|True -> true
|False -> false
|Not x -> not (eval (x))
|AndAlso (x, y) -> (eval (x) && eval (y))
|OrElse (x, y) -> (eval (x) || eval (y))
|Imply (x, y) -> (not (eval (x)) || eval (y))
|Equal (x, y) -> (value (x) = value (y)))

Time : 0.816799163818
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub75.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> true

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 0
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval}
------Remainings in solution ------
{evalExp}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp (f : exp)  : int = 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f1))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

Time : 0.771863937378
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub79.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> true

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 0
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval}
------Remainings in solution ------
{evalExp}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp (f : exp)  : int = 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f1))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

Time : 0.777481079102
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub81.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> true

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 0
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval}
------Remainings in solution ------
{evalExp}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp (f : exp)  : int = 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f1))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

Time : 0.779575109482
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub82.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec getInt  : (exp -> int) = 
fun number -> 
 (match number with 
|Num x -> x
|Plus (a, b) -> (getInt (a) + getInt (b))
|Minus (a, b) -> (getInt (a) - getInt (b)))

let rec getExpression  : (exp -> exp) = 
fun f -> 
 (match f with 
|Num x -> Num (x)
|Plus (a, b) -> Num (getInt (Plus ((a, b))))
|Minus (a, b) -> Num (getInt (Minus ((a, b)))))

let rec getValue  : (formula -> formula) = 
fun f -> 
 (match f with 
|True -> True
|False -> False
|Not x -> if (x = True) then False
 else if (x = False) then True
 else getValue (Not (getValue (x)))
|AndAlso (x, y) -> if ((x = True) && (y = True)) then True
 else if ((x = False) || (y = False)) then False
 else getValue (AndAlso ((getValue (x), getValue (y))))
|OrElse (x, y) -> if ((x = True) && (y = False)) then True
 else if ((x = False) && (y = True)) then True
 else if ((x = False) && (y = False)) then False
 else if ((x = True) && (y = True)) then False
 else getValue (OrElse ((getValue (x), getValue (y))))
|Imply (x, y) -> if (x = False) then True
 else if ((x = True) && (y = True)) then True
 else if ((x = True) && (y = False)) then False
 else getValue (Imply ((getValue (x), getValue (y))))
|Equal (ex1, ex2) -> if (getExpression (ex1) = getExpression (ex2)) then True
 else False)

let rec eval  : (formula -> bool) = 
fun f -> if (f = True) then true
 else if (f = False) then false
 else eval (getValue (f))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
getInt -> evalExp}
------Remainings in solution ------
{}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec getInt  : (exp -> int) = 
fun number -> 
 (match number with 
|Num x -> x
|Plus (a, b) -> (getInt (a) + getInt (b))
|Minus (a, b) -> (getInt (a) - getInt (b)))

let rec getExpression  : (exp -> exp) = 
fun f -> 
 (match f with 
|Num x -> Num (x)
|Plus (a, b) -> Num (getInt (Plus ((a, b))))
|Minus (a, b) -> Num (getInt (Minus ((a, b)))))

let rec getValue  : (formula -> formula) = 
fun f -> 
 (match f with 
|True -> True
|False -> False
|Not x -> if (x = True) then False
 else if (x = False) then True
 else getValue (Not (getValue (x)))
|AndAlso (x, y) -> if ((x = True) && (y = True)) then True
 else if ((x = False) || (y = False)) then False
 else getValue (AndAlso ((getValue (x), getValue (y))))
|OrElse (x, y) -> if ((x = True) && (y = False)) then True
 else if ((x = False) && (y = True)) then True
 else if ((x = False) && (y = False)) then False
 else if ((x = True) && (y = True)) then False
 else getValue (OrElse ((getValue (x), getValue (y))))
|Imply (x, y) -> if (x = False) then True
 else if ((x = True) && (y = True)) then True
 else if ((x = True) && (y = False)) then False
 else getValue (Imply ((getValue (x), getValue (y))))
|Equal (ex1, ex2) -> if (getExpression (ex1) = getExpression (ex2)) then True
 else False)

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f1))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (getExpression (exp1) = getExpression (exp2)))

Time : 1.97452497482
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub83.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> true

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 0
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval}
------Remainings in solution ------
{evalExp}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp (f : exp)  : int = 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f1))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

Time : 0.79854798317
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub88.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not a -> if (a = True) then false
 else true
|OrElse (a, b) -> if ((a = True) || (b = True)) then true
 else false
|AndAlso (a, b) -> if ((a = True) && (b = True)) then true
 else false
|Imply (a, b) -> if ((a = True) && (b = False)) then false
 else true
|Equal (a, b) -> if (a = b) then true
 else false)

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 0
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval}
------Remainings in solution ------
{evalExp}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub9.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f1 -> if eval (f1) then false
 else true
|AndAlso (f1, f2) -> if eval (f1) then eval (f2)
 else false
|OrElse (f1, f2) -> if eval (f1) then true
 else eval (f2)
|Imply (f1, f2) -> if eval (f1) then eval (f2)
 else true
|Equal (exp1, exp2) -> 
let rec e2i exp  = 
 (match exp with 
|Num i -> i
|Plus (e1, e2) -> (e2i (e1) + e2i (e1))
|Minus (e1, e2) -> (e2i (e1) - e2i (e2)))
 in 
(e2i (exp1) = e2i (exp2)))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{e2i -> evalExp,
eval -> eval}
------Remainings in solution ------
{}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f1 -> if eval (f1) then false
 else true
|AndAlso (f1, f2) -> if eval (f1) then eval (f2)
 else false
|OrElse (f1, f2) -> if eval (f1) then true
 else eval (f2)
|Imply (f1, f2) -> if eval (f1) then eval (f2)
 else true
|Equal (exp1, exp2) -> 
let rec e2i exp  = 
 (match exp with 
|Num i -> i
|Plus (e1, e2) -> (e2i (e2) + e2i (e1))
|Minus (e1, e2) -> (e2i (e1) - e2i (e2)))
 in 
(e2i (exp1) = e2i (exp2)))

Time : 0.832955121994
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/16/sub93.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
let rec exptoint  : (exp -> int) = 
fun f1 -> 
 (match f1 with 
|Num fs -> fs
|Plus (fs, ls) -> (exptoint (fs) + exptoint (ls))
|Minus (fs, ls) -> (exptoint (fs) - exptoint (ls)))
 in 

 (match f with 
|True -> true
|False -> false
|AndAlso (fs, ls) -> if (fs = False) then false
 else if (ls = False) then false
 else true
|OrElse (fst, lst) -> if (fst = True) then true
 else if (lst = True) then true
 else false
|Imply (fst, lst) -> if ((fst = True) && (lst = False)) then false
 else true
|Equal (fs, ls) -> if (exptoint (fs) = exptoint (ls)) then true
 else false
|Not a1 -> not (eval (a1)))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
exptoint -> evalExp}
------Remainings in solution ------
{}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub1.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|_ -> eval (f))

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 0
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval}
------Remainings in solution ------
{evalExp}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub11.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not p -> if (p = True) then false
 else true
|AndAlso (p, q) -> if (p = False) then false
 else if (q = False) then false
 else true
|OrElse (p, q) -> if (p = True) then true
 else if (q = True) then true
 else false
|Imply (p, q) -> if (q = True) then true
 else if (p = False) then true
 else false
|Equal (n1, n2) -> 
let rec exp_to_int  : (exp -> int) = 
fun e -> 
 (match e with 
|Num n -> n
|Plus (n1, n2) -> (exp_to_int (n1) + exp_to_int (n2))
|Minus (n1, n2) -> (exp_to_int (n1) - exp_to_int (n2)))
 in 
if (exp_to_int (n1) = exp_to_int (n2)) then true
 else false)

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
exp_to_int -> evalExp}
------Remainings in solution ------
{}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not p -> not (eval (p))
|AndAlso (p, q) -> if (p = False) then false
 else if (q = False) then false
 else true
|OrElse (p, q) -> if (p = True) then true
 else if (q = True) then true
 else false
|Imply (p, q) -> if ((eval (p) = false) || (eval (q) = true)) then true
 else if (p = False) then true
 else false
|Equal (n1, n2) -> 
let rec exp_to_int  : (exp -> int) = 
fun e -> 
 (match e with 
|Num n -> n
|Plus (n1, n2) -> (exp_to_int (n1) + exp_to_int (n2))
|Minus (n1, n2) -> (exp_to_int (n1) - exp_to_int (n2)))
 in 
if (exp_to_int (n1) = exp_to_int (n2)) then true
 else false)

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

Time : 30.709649086
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub14.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
let rec exptoint  : (exp -> int) = 
fun e -> 
 (match e with 
|Num a -> a
|Plus (a, b) -> (exptoint (a) + exptoint (b))
|Minus (a, b) -> (exptoint (a) - exptoint (b)))
 in 

 (match f with 
|True -> true
|False -> false
|Not x -> if (x = True) then false
 else true
|AndAlso (x, y) -> (eval (x) && eval (y))
|OrElse (x, y) -> (eval (x) || eval (y))
|Imply (x, y) -> 
let imply  : (bool -> (bool -> bool)) = 
fun a b -> if ((a = true) && (b = false)) then false
 else true
 in 
imply (eval (x)) (eval (y))
|Equal (x, y) -> if (exptoint (x) = exptoint (y)) then true
 else false)

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
exptoint -> evalExp}
------Remainings in solution ------
{}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
let rec exptoint  : (exp -> int) = 
fun e -> 
 (match e with 
|Num a -> a
|Plus (a, b) -> (exptoint (a) + exptoint (b))
|Minus (a, b) -> (exptoint (a) - exptoint (b)))
 in 

 (match f with 
|True -> true
|False -> false
|Not x -> not (eval (x))
|AndAlso (x, y) -> (eval (x) && eval (y))
|OrElse (x, y) -> (eval (x) || eval (y))
|Imply (x, y) -> 
let imply  : (bool -> (bool -> bool)) = 
fun a b -> if ((a = true) && (b = false)) then false
 else true
 in 
imply (eval (x)) (eval (y))
|Equal (x, y) -> if (exptoint (x) = exptoint (y)) then true
 else false)

Time : 0.414303064346
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub15.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec value  : (exp -> int) = 
fun n -> 
 (match n with 
|Num h -> h
|Plus (x, y) -> (value (x) + value (y))
|Minus (x, y) -> (value (x) * value (y)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not h -> not (eval (h))
|AndAlso (x, y) -> (eval (x) && eval (y))
|OrElse (x, y) -> (eval (x) || eval (y))
|Imply (x, y) -> if (eval (x) = true) then eval (y)
 else true
|Equal (x, y) -> if (value (x) = value (y)) then true
 else false)

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
value -> evalExp}
------Remainings in solution ------
{}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec value  : (exp -> int) = 
fun n -> 
 (match n with 
|Num h -> h
|Plus (x, y) -> (value (x) + value (y))
|Minus (x, y) -> (value (x) - value (y)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not h -> not (eval (h))
|AndAlso (x, y) -> (eval (x) && eval (y))
|OrElse (x, y) -> (eval (x) || eval (y))
|Imply (x, y) -> if (eval (x) = true) then eval (y)
 else true
|Equal (x, y) -> if (value (x) = value (y)) then true
 else false)

Time : 0.0143649578094
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub16.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec calc  : (exp -> int) = 
fun e -> 
 (match e with 
|Num n -> n
|Plus (n1, n2) -> (calc (n1) + calc (n2))
|Minus (n1, n2) -> (calc (n1) - calc (n2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not b1 -> if eval (b1) then false
 else true
|AndAlso (b1, b2) -> (eval (b1) && eval (b2))
|OrElse (b1, b2) -> (eval (b1) || eval (b2))
|Imply (b1, b2) -> if ((eval (b1) = false) && (eval (b2) = true)) then false
 else true
|Equal (e1, e2) -> (calc (e1) = calc (e2)))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{calc -> evalExp,
eval -> eval}
------Remainings in solution ------
{}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec calc  : (exp -> int) = 
fun e -> 
 (match e with 
|Num n -> n
|Plus (n1, n2) -> (calc (n1) + calc (n2))
|Minus (n1, n2) -> (calc (n1) - calc (n2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not b1 -> if eval (b1) then false
 else true
|AndAlso (b1, b2) -> (eval (b1) && eval (b2))
|OrElse (b1, b2) -> (eval (b1) || eval (b2))
|Imply (b1, b2) -> if ((eval (b1) = false) || (eval (b2) = true)) then true
 else false
|Equal (e1, e2) -> (calc (e1) = calc (e2)))

Time : 5.22206616402
Error occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub18.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub2.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eq  : (exp -> int) = 
fun f -> 
 (match f with 
|Num a -> a
|Plus (a, b) -> eq (Num ((eq (a) + eq (b))))
|Minus (a, b) -> eq (Num ((eq (a) - eq (b)))))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not True -> false
|Not False -> true
|Not a -> eval (a)
|Equal (a, b) -> if (eq (a) = eq (b)) then true
 else false
|Imply (a, b) -> 
 (match (a, b) with 
|(True, True) -> true
|(True, False) -> false
|(False, True) -> true
|(False, False) -> true
|(_, _) -> eval (Imply ((if (eval (a) = true) then True
 else False, if (eval (b) = true) then True
 else False))))
|AndAlso (a, b) -> 
 (match (a, b) with 
|(True, True) -> true
|(True, False) -> false
|(False, True) -> false
|(False, False) -> false
|(_, _) -> eval (AndAlso ((if (eval (a) = true) then True
 else False, if (eval (b) = true) then True
 else False))))
|OrElse (a, b) -> 
 (match (a, b) with 
|(True, True) -> true
|(True, False) -> true
|(False, True) -> true
|(False, False) -> false
|(_, _) -> eval (OrElse ((if (eval (a) = true) then True
 else False, if (eval (b) = true) then True
 else False)))))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eq -> evalExp,
eval -> eval}
------Remainings in solution ------
{}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eq  : (exp -> int) = 
fun f -> 
 (match f with 
|Num a -> a
|Plus (a, b) -> eq (Num ((eq (a) + eq (b))))
|Minus (a, b) -> eq (Num ((eq (a) - eq (b)))))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not True -> false
|Not False -> true
|Not a -> not (eval (a))
|Equal (a, b) -> if (eq (a) = eq (b)) then true
 else false
|Imply (a, b) -> 
 (match (a, b) with 
|(True, True) -> true
|(True, False) -> false
|(False, True) -> true
|(False, False) -> true
|(_, _) -> eval (Imply ((if (eval (a) = true) then True
 else False, if (eval (b) = true) then True
 else False))))
|AndAlso (a, b) -> 
 (match (a, b) with 
|(True, True) -> true
|(True, False) -> false
|(False, True) -> false
|(False, False) -> false
|(_, _) -> eval (AndAlso ((if (eval (a) = true) then True
 else False, if (eval (b) = true) then True
 else False))))
|OrElse (a, b) -> 
 (match (a, b) with 
|(True, True) -> true
|(True, False) -> true
|(False, True) -> true
|(False, False) -> false
|(_, _) -> eval (OrElse ((if (eval (a) = true) then True
 else False, if (eval (b) = true) then True
 else False)))))

Time : 0.00464391708374
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub20.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not x -> if (x = True) then false
 else true
|AndAlso (x, y) -> if ((x = True) && (y = True)) then true
 else false
|OrElse (x, y) -> if ((x = False) && (y = False)) then false
 else true
|Imply (x, y) -> if ((x = True) && (y = False)) then false
 else true
|Equal (x, y) -> if (x = y) then true
 else false)

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 0
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval}
------Remainings in solution ------
{evalExp}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub22.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
let rec exp f  = 
 (match f with 
|Num x -> x
|Plus (x, y) -> (exp (x) + exp (y))
|Minus (x, y) -> (exp (x) - exp (y)))
 in 

 (match f with 
|True -> true
|False -> false
|Not x -> if (eval (x) = true) then false
 else true
|AndAlso (x, y) -> if ((eval (x) = true) || (eval (y) = true)) then true
 else false
|OrElse (x, y) -> if ((eval (x) = false) && (eval (y) = false)) then false
 else true
|Imply (x, y) -> if ((eval (x) = true) && (eval (y) = false)) then false
 else true
|Equal (x, y) -> if (exp (x) = exp (y)) then true
 else false)

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
exp -> evalExp}
------Remainings in solution ------
{}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
let rec exp f  = 
 (match f with 
|Num x -> x
|Plus (x, y) -> (exp (x) + exp (y))
|Minus (x, y) -> (exp (x) - exp (y)))
 in 

 (match f with 
|True -> true
|False -> false
|Not x -> if (eval (x) = true) then false
 else true
|AndAlso (x, y) -> (eval (x) && eval (y))
|OrElse (x, y) -> if ((eval (x) = false) && (eval (y) = false)) then false
 else true
|Imply (x, y) -> if ((eval (x) = true) && (eval (y) = false)) then false
 else true
|Equal (x, y) -> if (exp (x) = exp (y)) then true
 else false)

Time : 0.0121691226959
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub24.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let eval  : (formula -> bool) = 
fun f -> 
let rec eval' e  = 
 (match e with 
|Num _ -> 0
|Plus (e1, e2) -> (eval' (e1) + eval' (e2))
|Minus (e1, e2) -> (eval' (e1) - eval' (e2)))
 in 

 (match f with 
|Equal (e1, e2) -> if (eval' (e1) = eval' (e2)) then true
 else false)

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
eval' -> evalExp}
------Remainings in solution ------
{}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub26.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec math  : (exp -> int) = 
fun e -> 
 (match e with 
|Num e1 -> e1
|Plus (e1, e2) -> (math (e1) + math (e2))
|Minus (e1, e2) -> (math (e1) - math (e2)))

let eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f1 -> if (f1 = True) then false
 else true
|AndAlso (f1, f2) -> if ((f1 = True) && (f2 = True)) then true
 else false
|OrElse (f1, f2) -> if ((f1 = False) && (f2 = False)) then false
 else true
|Imply (f1, f2) -> if (f1 = False) then true
 else if (f2 = True) then true
 else false
|Equal (e1, e2) -> if (math (e1) = math (e2)) then true
 else false)

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
math -> evalExp}
------Remainings in solution ------
{}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub29.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
let rec op  : (exp -> int) = 
fun e -> 
 (match e with 
|Num i -> i
|Plus (e1, e2) -> (op (e1) + op (e2))
|Minus (e1, e2) -> (op (e1) - op (e2)))
 in 

 (match f with 
|True -> true
|False -> false
|Not f -> (eval (f) = false)
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> ((eval (f1) && eval (f2)) || (eval (f2) = false))
|Equal (e1, e2) -> (op (e1) = op (e2)))

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
op -> evalExp}
------Remainings in solution ------
{}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
let rec op  : (exp -> int) = 
fun e -> 
 (match e with 
|Num i -> i
|Plus (e1, e2) -> (op (e1) + op (e2))
|Minus (e1, e2) -> (op (e1) - op (e2)))
 in 

 (match f with 
|True -> true
|False -> false
|Not f -> (eval (f) = false)
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (e1, e2) -> (op (e1) = op (e2)))

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

Time : 0.418130874634
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub31.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let eval  : (formula -> bool) = 
fun x -> 
 (match x with 
|True -> true
|False -> false
|Not x -> if (x = True) then false
 else true
|AndAlso (x, y) -> if ((x = True) && (y = True)) then true
 else false
|OrElse (x, y) -> if ((x = True) || (y = True)) then true
 else false
|Imply (x, y) -> if ((x = True) && (y = False)) then false
 else true
|Equal (x, y) -> if (x = y) then true
 else false)

let rec cal  : (exp -> int) = 
fun x -> 
 (match x with 
|Num x -> x
|Plus (x, y) -> (cal (x) + cal (y))
|Minus (x, y) -> (cal (x) - cal (y)))

let _  = eval (True)

let _  = eval (AndAlso ((True, False)))

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 0
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval}
------Remainings in solution ------
{evalExp}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub37.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval_exp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num a -> a
|Plus (a, b) -> (eval_exp (a) + eval_exp (b))
|Minus (a, b) -> (eval_exp (a) - eval_exp (b)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not a -> if (a = True) then eval (False)
 else eval (True)
|AndAlso (a, b) -> (eval (a) && eval (b))
|OrElse (a, b) -> (eval (a) || eval (b))
|Imply (a, b) -> (eval (Not (a)) || eval (b))
|Equal (a, b) -> if (eval_exp (a) = eval_exp (b)) then true
 else false)

let _  = eval (True)

let _  = eval (Equal ((Num (4), Plus ((Num (1), Num (2))))))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
eval_exp -> evalExp}
------Remainings in solution ------
{}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval_exp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num a -> a
|Plus (a, b) -> (eval_exp (a) + eval_exp (b))
|Minus (a, b) -> (eval_exp (a) - eval_exp (b)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not a -> not (eval (a))
|AndAlso (a, b) -> (eval (a) && eval (b))
|OrElse (a, b) -> (eval (a) || eval (b))
|Imply (a, b) -> (eval (Not (a)) || eval (b))
|Equal (a, b) -> if (eval_exp (a) = eval_exp (b)) then true
 else false)

let _  = eval (True)

let _  = eval (Equal ((Num (4), Plus ((Num (1), Num (2))))))

Time : 0.0117900371552
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub39.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> 
 (match f with 
|True -> false
|False -> true
|AndAlso (a, b) -> if (eval (a) = eval (b)) then true
 else false
|OrElse (a, b) -> if (eval (a) = eval (b)) then false
 else true
|Imply (a, b) -> if (b = True) then true
 else false
|Equal (a, b) -> if (a = b) then true
 else false))

let _  = eval (Not (True))

let _  = eval (Not (False))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 0
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval}
------Remainings in solution ------
{evalExp}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp (f : exp)  : int = 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|OrElse (f1, f2) -> (eval (f1) || eval (f1)))

let _  = eval (Not (True))

let _  = eval (Not (False))

Time : 11.812169075
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub4.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> if (eval (f) = true) then false
 else true
|AndAlso (f1, f2) -> if (eval (f1) = false) then false
 else eval (f2)
|OrElse (f1, f2) -> if (eval (f1) = true) then true
 else eval (f2)
|Imply (f1, f2) -> if ((eval (f1) = true) && (eval (f2) = false)) then false
 else true
|Equal (e1, e2) -> if (e1 = e2) then true
 else false)

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

let _  = eval (Imply ((Imply ((False, True)), False)))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 0
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval}
------Remainings in solution ------
{evalExp}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp (f : exp)  : int = 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> if (eval (f) = true) then false
 else true
|AndAlso (f1, f2) -> if (eval (f1) = false) then false
 else eval (f2)
|OrElse (f1, f2) -> if (eval (f1) = true) then true
 else eval (f2)
|Imply (f1, f2) -> if ((eval (f1) = true) && (eval (f2) = false)) then false
 else true
|Equal (e1, e2) -> (evalExp (e1) = evalExp (e2)))

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

let _  = eval (Imply ((Imply ((False, True)), False)))

Time : 0.00977897644043
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub40.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec js  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (a1, a2) -> (js (a1) + js (a2))
|Minus (a1, a2) -> (js (a1) - js (a2)))

let eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not a -> if (a = True) then false
 else true
|AndAlso (a1, a2) -> if ((a1 = True) && (a2 = True)) then true
 else false
|OrElse (a1, a2) -> if ((a1 = True) || (a2 = True)) then true
 else false
|Imply (a1, a2) -> if ((a1 = True) && (a2 = False)) then false
 else true
|Equal (a1, a2) -> if (js (a1) = js (a2)) then true
 else false)

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

let _  = eval (Equal ((Num (3), Plus ((Num (1), Num (2))))))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
js -> evalExp}
------Remainings in solution ------
{}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub46.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec calc  : (exp -> int) = 
fun f -> 
 (match f with 
|Num x -> x
|Plus (x, y) -> (calc (x) + calc (y))
|Minus (x, y) -> (calc (x) - calc (y)))

let eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not x -> if (x = True) then false
 else true
|AndAlso (x, y) -> if ((x = True) && (y = True)) then true
 else false
|OrElse (x, y) -> if ((x = True) || (y = False)) then true
 else false
|Imply (x, y) -> if ((x = True) && (y = False)) then false
 else true
|Equal (x, y) -> if (calc (x) = calc (y)) then true
 else false)

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{calc -> evalExp,
eval -> eval}
------Remainings in solution ------
{}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub49.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f0 -> if (f0 = True) then false
 else true
|AndAlso (f1, f2) -> if ((f1 = True) && (f2 = True)) then true
 else false
|OrElse (f1, f2) -> if ((f1 = False) && (f2 = False)) then false
 else true
|Imply (f1, f2) -> if ((f1 = True) && (f2 = False)) then false
 else true
|Equal (e1, e2) -> if (e1 = e2) then true
 else false)

let _  = eval (Imply ((Imply ((True, False)), True)))

let rec num  : (exp -> int) = 
fun n -> 
 (match n with 
|Num i -> i
|Plus (e1, e2) -> (num (e1) + num (e2))
|Minus (e1, e2) -> (num (e1) - num (e2)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 0
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval}
------Remainings in solution ------
{evalExp}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub6.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let andAlso (x, y)  = if ((x = true) && (y = true)) then true
 else false

let orElse (x, y)  = if ((x = false) && (y = false)) then false
 else true

let imply (x, y)  = if ((x = false) && (y = true)) then true
 else if ((x = false) && (y = false)) then true
 else if ((x = true) && (y = false)) then false
 else true

let rec equal (x, y)  = if (x = y) then true
 else false

let cal (x : exp)  = 
 (match x with 
|Num n -> n
|Plus (Num a, Num b) -> (a + b)
|Minus (Num a, Num b) -> (a - b))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|AndAlso (x, y) -> if ((x = True) && (y = True)) then true
 else if ((x = False) || (y = False)) then false
 else andAlso ((eval (x), eval (y)))
|OrElse (x, y) -> if ((x = False) && (y = False)) then false
 else if ((x = True) || (y = True)) then true
 else orElse ((eval (x), eval (y)))
|Imply (x, y) -> if ((x = False) && (y = True)) then false
 else if ((x = False) && (y = False)) then true
 else if ((x = True) && (y = False)) then false
 else if ((x = True) && (y = True)) then true
 else imply ((eval (x), eval (y)))
|Not x -> if (x = True) then false
 else if (x = False) then true
 else not (eval (x))
|True -> true
|False -> false
|Equal (x, y) -> if (x = y) then true
 else equal ((cal (x), cal (y))))

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 0
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval}
------Remainings in solution ------
{evalExp}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let andAlso (x, y)  = if ((x = true) && (y = true)) then true
 else false

let orElse (x, y)  = if ((x = false) && (y = false)) then false
 else true

let imply (x, y)  = if ((x = false) && (y = true)) then true
 else if ((x = false) && (y = false)) then true
 else if ((x = true) && (y = false)) then false
 else true

let rec equal (x, y)  = if (x = y) then true
 else false

let cal (x : exp)  = 
 (match x with 
|Num n -> n
|Plus (Num a, Num b) -> (a + b)
|Minus (Num a, Num b) -> (a - b))

let rec evalExp (f : exp)  : int = 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|AndAlso (x, y) -> if ((x = True) && (y = True)) then true
 else if ((x = False) || (y = False)) then false
 else andAlso ((eval (x), eval (y)))
|OrElse (x, y) -> if ((x = False) && (y = False)) then false
 else if ((x = True) || (y = True)) then true
 else orElse ((eval (x), eval (y)))
|Imply (x, y) -> if ((x = False) && (y = True)) then false
 else if ((x = False) && (y = False)) then true
 else if ((x = True) && (y = False)) then false
 else if ((x = True) && (y = True)) then true
 else imply ((eval (x), eval (y)))
|Not x -> if (x = True) then false
 else if (x = False) then true
 else not (eval (x))
|True -> true
|False -> false
|Equal (x, y) -> (evalExp (x) = evalExp (y)))

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

Time : 0.020828962326
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub7.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval_exp  : (exp -> int) = 
fun e -> 
 (match e with 
|Num n -> n
|Plus (e1, e2) -> (eval_exp (e1) + eval_exp (e2))
|Minus (e1, e2) -> (eval_exp (e1) - eval_exp (e2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not b -> not (eval (b))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) && eval (f2)) then false
 else true
|Equal (e1, e2) -> (eval_exp (e1) = eval_exp (e2)))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
eval_exp -> evalExp}
------Remainings in solution ------
{}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval_exp  : (exp -> int) = 
fun e -> 
 (match e with 
|Num n -> n
|Plus (e1, e2) -> (eval_exp (e1) + eval_exp (e2))
|Minus (e1, e2) -> (eval_exp (e1) - eval_exp (e2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not b -> not (eval (b))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (e1, e2) -> (eval_exp (e1) = eval_exp (e2)))

Time : 4.87725687027
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub70.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec cal  : (exp -> int) = 
fun e -> 
 (match e with 
|Num a -> a
|Plus (a, b) -> (cal (a) + cal (b))
|Minus (a, b) -> (cal (a) - cal (b)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not temp -> eval (temp)
|AndAlso (a, b) -> (eval (a) && eval (b))
|OrElse (a, b) -> (eval (a) || eval (b))
|Imply (a, b) -> if ((eval (a) = true) && (eval (b) = false)) then false
 else true
|Equal (a, b) -> if (cal (a) = cal (b)) then true
 else false)

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

let _  = eval (Imply ((Imply ((True, False)), True)))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{cal -> evalExp,
eval -> eval}
------Remainings in solution ------
{}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec cal  : (exp -> int) = 
fun e -> 
 (match e with 
|Num a -> a
|Plus (a, b) -> (cal (a) + cal (b))
|Minus (a, b) -> (cal (a) - cal (b)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not temp -> not (eval (temp))
|AndAlso (a, b) -> (eval (a) && eval (b))
|OrElse (a, b) -> (eval (a) || eval (b))
|Imply (a, b) -> if ((eval (a) = true) && (eval (b) = false)) then false
 else true
|Equal (a, b) -> if (cal (a) = cal (b)) then true
 else false)

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

let _  = eval (Imply ((Imply ((True, False)), True)))

Time : 0.0133471488953
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub71.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (exp -> int) = 
fun f -> 
 (match f with 
|Num x -> x
|Plus (x, y) -> (eval (x) + eval (y))
|Minus (x, y) -> (eval (x) - eval (y)))

let eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not x -> if (x = True) then false
 else true
|AndAlso (x, y) -> if ((x = True) && (y = True)) then true
 else false
|OrElse (x, y) -> if ((x = True) || (y = False)) then true
 else false
|Imply (x, y) -> if ((x = True) && (y = False)) then false
 else true
|Equal (x, y) -> if (eval (x) = eval (y)) then true
 else false)

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 0
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval}
------Remainings in solution ------
{evalExp}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub73.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec cal  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (g, h) -> (cal (g) + cal (h))
|Minus (g, h) -> (cal (g) - cal (h)))

let eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not h -> if (h = True) then false
 else true
|AndAlso (g, h) -> if ((g = True) && (h = True)) then true
 else false
|OrElse (g, h) -> if ((g = False) && (h = False)) then false
 else true
|Imply (g, h) -> if ((g = True) && (h = False)) then false
 else true
|Equal (g, h) -> if (cal (g) = cal (h)) then true
 else false)

let _  = eval (Imply ((Imply ((True, False)), True)))

let _  = eval (Equal ((Num (1), Plus ((Num (1), Num (2))))))

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{cal -> evalExp,
eval -> eval}
------Remainings in solution ------
{}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub8.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec chlwhd  : (exp -> int) = 
fun e -> 
 (match e with 
|Num a -> a
|Plus (a, b) -> (chlwhd (a) + chlwhd (b))
|Minus (a, b) -> (chlwhd (a) - chlwhd (b)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f', f) -> (eval (f') && eval (f))
|OrElse (f', f) -> (eval (f') || eval (f))
|Imply (f', f) -> if ((eval (f') = true) && (eval (f) = false)) then false
 else if ((eval (f') = true) && (eval (f) = true)) then true
 else if ((eval (f') = false) && (eval (f) = true)) then true
 else false
|Equal (a, b) -> if (chlwhd (a) = chlwhd (b)) then true
 else false)

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{chlwhd -> evalExp,
eval -> eval}
------Remainings in solution ------
{}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec chlwhd  : (exp -> int) = 
fun e -> 
 (match e with 
|Num a -> a
|Plus (a, b) -> (chlwhd (a) + chlwhd (b))
|Minus (a, b) -> (chlwhd (a) - chlwhd (b)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f', f) -> (eval (f') && eval (f))
|OrElse (f', f) -> (eval (f') || eval (f))
|Imply (f', f) -> if ((eval (f') = false) || (eval (f) = true)) then true
 else if ((eval (f') = true) && (eval (f) = true)) then true
 else if ((eval (f') = false) && (eval (f) = true)) then true
 else false
|Equal (a, b) -> if (chlwhd (a) = chlwhd (b)) then true
 else false)

Time : 0.287071943283
../engine/main.native -dd -submission ../benchmarks_incorrect/KoreaUniv_formula_16/18/sub9.ml -solutions ../benchmarks_correct/KoreaUniv_formula_16 -entry eval -testcases ../testcases/formula_testcases
-----------------------------
Submission
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not b -> if (eval (b) = true) then true
 else false
|Imply (a, b) -> if (eval (a) = false) then true
 else if (eval (b) = true) then true
 else false
|AndAlso (a, b) -> if ((eval (a) = true) && (eval (b) = true)) then true
 else false
|OrElse (a, b) -> if (eval (a) = true) then true
 else if (eval (b) = true) then true
 else false
|Equal (a, b) -> 
let rec eval_exp  : (exp -> int) = 
fun e -> 
 (match e with 
|Num n -> n
|Plus (n1, n2) -> (eval_exp (n1) + eval_exp (n2))
|Minus (n1, n2) -> (eval_exp (n1) - eval_exp (n2)))
 in 
if (eval_exp (a) = eval_exp (b)) then true
 else false)

-----------------------------
Most Similar Sol ../benchmarks_correct/KoreaUniv_formula_16/18/sub74.ml Score : 2
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec evalExp  : (exp -> int) = 
fun f -> 
 (match f with 
|Num n -> n
|Plus (exp1, exp2) -> (evalExp (exp1) + evalExp (exp2))
|Minus (exp1, exp2) -> (evalExp (exp1) - evalExp (exp2)))

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not f -> not (eval (f))
|AndAlso (f1, f2) -> (eval (f1) && eval (f2))
|OrElse (f1, f2) -> (eval (f1) || eval (f2))
|Imply (f1, f2) -> if ((eval (f1) = false) || (eval (f2) = true)) then true
 else false
|Equal (exp1, exp2) -> (evalExp (exp1) = evalExp (exp2)))

-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{eval -> eval,
eval_exp -> evalExp}
------Remainings in solution ------
{}
-----------------------------
Patch
-----------------------------

type formula =
|Equal of (exp * exp)
|Imply of (formula * formula)
|OrElse of (formula * formula)
|AndAlso of (formula * formula)
|Not of formula
|False
|True
and exp =
|Minus of (exp * exp)
|Plus of (exp * exp)
|Num of int

let rec eval  : (formula -> bool) = 
fun f -> 
 (match f with 
|True -> true
|False -> false
|Not b -> not (eval (b))
|Imply (a, b) -> if (eval (a) = false) then true
 else if (eval (b) = true) then true
 else false
|AndAlso (a, b) -> if ((eval (a) = true) && (eval (b) = true)) then true
 else false
|OrElse (a, b) -> if (eval (a) = true) then true
 else if (eval (b) = true) then true
 else false
|Equal (a, b) -> 
let rec eval_exp  : (exp -> int) = 
fun e -> 
 (match e with 
|Num n -> n
|Plus (n1, n2) -> (eval_exp (n1) + eval_exp (n2))
|Minus (n1, n2) -> (eval_exp (n1) - eval_exp (n2)))
 in 
if (eval_exp (a) = eval_exp (b)) then true
 else false)

Time : 0.00920104980469

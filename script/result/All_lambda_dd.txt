../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/09/sub1.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check (m : lambda)  = 
 (match m with 
|P (a, V b) -> if (a = b) then true
 else false
|P (a, P (b, c)) -> if (a = b) then check (P ((b, c)))
 else if (check (P ((a, c))) = true) then true
 else if (check (P ((b, c))) = true) then true
 else false
|P (a, C (b, c)) -> if (check (P ((a, b))) = true) then if (check (P ((a, c))) = true) then true
 else false
 else false)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check (m : lambda)  = (60605, 
 (match (60546, m with 
|P (a, V b) -> (60552, if (60549, ((60547, a = (60548, b) then (60550, true
 else (60551, false
|P (a, P (b, c)) -> (60583, if (60555, ((60553, a = (60554, b) then (60561, (60556, check ((60560, P ((60559, ((60557, b, (60558, c)))
 else (60582, if (60569, ((60567, (60562, check ((60566, P ((60565, ((60563, a, (60564, c))) = (60568, true) then (60570, true
 else (60581, if (60578, ((60576, (60571, check ((60575, P ((60574, ((60572, b, (60573, c))) = (60577, true) then (60579, true
 else (60580, false
|P (a, C (b, c)) -> (60604, if (60591, ((60589, (60584, check ((60588, P ((60587, ((60585, a, (60586, b))) = (60590, true) then (60602, if (60599, ((60597, (60592, check ((60596, P ((60595, ((60593, a, (60594, c))) = (60598, true) then (60600, true
 else (60601, false
 else (60603, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : (m : lambda) 
Output : bool
Body : 
 (match m with 
|P (a, V b) -> if (a = b) then true
 else false
|P (a, P (b, c)) -> if (a = b) then check (P ((b, c)))
 else if (check (P ((a, c))) = true) then true
 else if (check (P ((b, c))) = true) then true
 else false
|P (a, C (b, c)) -> if (check (P ((a, b))) = true) then if (check (P ((a, c))) = true) then true
 else false
 else false)}
Edge : 
{(45777, 45777) -> }
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60605 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60605 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check (m : lambda)  = checking (m) ([])

Time : 0.00149202346802
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/09/sub15.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check met  = 
let rec checkArea id m  = 
 (match m with 
|V n -> __list_exists__ (
fun x -> (x = n)) (id)
|C (s1, s2) -> (checkArea (id) (s1) && checkArea (id) (s2))
|P (id2, m) -> checkArea ((id2 :: id)) (m))
 in 

 (match met with 
|P (id, m) -> checkArea ([id]) (m)
|_ -> false)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check met  = (60583, 
let rec checkArea id m  = (60573, 
 (match (60546, m with 
|V n -> (60554, (60553, (60547, __list_exists__ ((60551, 
fun x -> (60550, ((60548, x = (60549, n)) ((60552, id)
|C (s1, s2) -> (60565, ((60559, (60558, (60555, checkArea ((60556, id) ((60557, s1) && (60564, (60563, (60560, checkArea ((60561, id) ((60562, s2))
|P (id2, m) -> (60572, (60571, (60566, checkArea ((60569, ((60567, id2 :: (60568, id)) ((60570, m))
 in 
(60582, 
 (match (60574, met with 
|P (id, m) -> (60580, (60579, (60575, checkArea ((60577, [(60576, id]) ((60578, m)
|_ -> (60581, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub55.ml Score : 3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checklambda  : (var list -> (lambda -> bool)) = 
fun lst lam -> 
 (match lam with 
|V x -> __list_mem__ (x) (lst)
|P (x, l) -> checklambda ((x :: lst)) (l)
|C (l1, l2) -> (checklambda (lst) (l1) && checklambda (lst) (l2)))

let check  : (lambda -> bool) = 
fun lam -> checklambda ([]) (lam)

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{__list_exists__ -> (47075 : 
Input : (pred : (#961732 -> bool)) (lst : #961732 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> (pred (hd) || __list_exists__ (pred) (tl))),

check -> (47099 : 
Input : (met : lambda) 
Output : bool
Body : 
 (match met with 
|P (id, m) -> checkArea ([id]) (m)
|_ -> false),

checkArea -> (47100 : 
Input : (id : string list) (m : lambda) 
Output : bool
Body : 
 (match m with 
|V n -> __list_exists__ (
fun (x : string) -> (x = n)) (id)
|C (s1, s2) -> (checkArea (id) (s1) && checkArea (id) (s2))
|P (id2, m) -> checkArea ((id2 :: id)) (m))}
Edge : 
{(47075, 47075) -> ,
(47099, 47100) -> ,
(47100, 47075) -> ,
(47100, 47100) -> }
Starting : 47099
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{__list_mem__ -> (47039 : 
Input : elem (lst : #961019 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (47065 : 
Input : (lam : lambda) 
Output : bool
Body : checklambda ([]) (lam),

checklambda -> (47064 : 
Input : (lst : string list) (lam : lambda) 
Output : bool
Body : 
 (match lam with 
|V x -> __list_mem__ (x) (lst)
|P (x, l) -> checklambda ((x :: lst)) (l)
|C (l1, l2) -> (checklambda (lst) (l1) && checklambda (lst) (l2)))}
Edge : 
{(47039, 47039) -> ,
(47064, 47039) -> ,
(47064, 47064) -> ,
(47065, 47064) -> }
Starting : 47065
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{__list_exists__ -> __list_mem__,
check -> check,
checkArea -> checklambda}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60554 : ? (?) (?))

Decls : 
,Exp : Modify (60559 : ? (?) (?))

Decls : 
,Exp : Modify (60564 : ? (?) (?))

Decls : 
,Exp : Modify (60572 : ? ((? :: ?)) (?))

Decls : 
,Exp : Modify (60582 : ? ([]) (?))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60582 : ? ([]) (?))

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check met  = 
let rec checkArea id m  = 
 (match m with 
|V n -> __list_exists__ (
fun x -> (x = n)) (id)
|C (s1, s2) -> (checkArea (id) (s1) && checkArea (id) (s2))
|P (id2, m) -> checkArea ((id2 :: id)) (m))
 in 
checkArea ([]) (met)

Time : 0.00166893005371
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/09/sub16.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check met  = 
let rec checkArea id m  = 
 (match m with 
|V n -> __list_exists__ (
fun x -> (x = n)) (id)
|C (s1, s2) -> (checkArea (id) (s1) && checkArea (id) (s2))
|P (id2, m) -> checkArea ((id2 :: id)) (m))
 in 

 (match met with 
|P (id, m) -> checkArea ([id]) (m)
|_ -> false)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check met  = (60583, 
let rec checkArea id m  = (60573, 
 (match (60546, m with 
|V n -> (60554, (60553, (60547, __list_exists__ ((60551, 
fun x -> (60550, ((60548, x = (60549, n)) ((60552, id)
|C (s1, s2) -> (60565, ((60559, (60558, (60555, checkArea ((60556, id) ((60557, s1) && (60564, (60563, (60560, checkArea ((60561, id) ((60562, s2))
|P (id2, m) -> (60572, (60571, (60566, checkArea ((60569, ((60567, id2 :: (60568, id)) ((60570, m))
 in 
(60582, 
 (match (60574, met with 
|P (id, m) -> (60580, (60579, (60575, checkArea ((60577, [(60576, id]) ((60578, m)
|_ -> (60581, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub55.ml Score : 3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checklambda  : (var list -> (lambda -> bool)) = 
fun lst lam -> 
 (match lam with 
|V x -> __list_mem__ (x) (lst)
|P (x, l) -> checklambda ((x :: lst)) (l)
|C (l1, l2) -> (checklambda (lst) (l1) && checklambda (lst) (l2)))

let check  : (lambda -> bool) = 
fun lam -> checklambda ([]) (lam)

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{__list_exists__ -> (47075 : 
Input : (pred : (#961732 -> bool)) (lst : #961732 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> (pred (hd) || __list_exists__ (pred) (tl))),

check -> (47099 : 
Input : (met : lambda) 
Output : bool
Body : 
 (match met with 
|P (id, m) -> checkArea ([id]) (m)
|_ -> false),

checkArea -> (47100 : 
Input : (id : string list) (m : lambda) 
Output : bool
Body : 
 (match m with 
|V n -> __list_exists__ (
fun (x : string) -> (x = n)) (id)
|C (s1, s2) -> (checkArea (id) (s1) && checkArea (id) (s2))
|P (id2, m) -> checkArea ((id2 :: id)) (m))}
Edge : 
{(47075, 47075) -> ,
(47099, 47100) -> ,
(47100, 47075) -> ,
(47100, 47100) -> }
Starting : 47099
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{__list_mem__ -> (47039 : 
Input : elem (lst : #961019 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (47065 : 
Input : (lam : lambda) 
Output : bool
Body : checklambda ([]) (lam),

checklambda -> (47064 : 
Input : (lst : string list) (lam : lambda) 
Output : bool
Body : 
 (match lam with 
|V x -> __list_mem__ (x) (lst)
|P (x, l) -> checklambda ((x :: lst)) (l)
|C (l1, l2) -> (checklambda (lst) (l1) && checklambda (lst) (l2)))}
Edge : 
{(47039, 47039) -> ,
(47064, 47039) -> ,
(47064, 47064) -> ,
(47065, 47064) -> }
Starting : 47065
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{__list_exists__ -> __list_mem__,
check -> check,
checkArea -> checklambda}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60554 : ? (?) (?))

Decls : 
,Exp : Modify (60559 : ? (?) (?))

Decls : 
,Exp : Modify (60564 : ? (?) (?))

Decls : 
,Exp : Modify (60572 : ? ((? :: ?)) (?))

Decls : 
,Exp : Modify (60582 : ? ([]) (?))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60582 : ? ([]) (?))

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check met  = 
let rec checkArea id m  = 
 (match m with 
|V n -> __list_exists__ (
fun x -> (x = n)) (id)
|C (s1, s2) -> (checkArea (id) (s1) && checkArea (id) (s2))
|P (id2, m) -> checkArea ((id2 :: id)) (m))
 in 
checkArea ([]) (met)

Time : 0.00165200233459
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/09/sub17.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check m  = 
let rec append m1 m2  = 
 (match m1 with 
|h::t -> if __list_mem__ (h) (m2) then append (t) (m2)
 else append (t) ((h :: m2))
|[] -> m2)
 in 

let rec check2 m l  = 
 (match m with 
|V n -> l
|P (n, m2) -> if __list_mem__ (n) (l) then check2 (m2) (l)
 else check2 (m2) ((n :: l))
|C (m1, m2) -> append (check2 (m1) (l)) (check2 (m2) (l)))
 in 

let rec check3 m l  = 
 (match m with 
|V n -> if __list_mem__ (n) (l) then true
 else false
|P (n, m2) -> check3 (m2) (l)
|C (m1, m2) -> (check3 (m1) (l) && check3 (m2) (l)))
 in 

let l  = check2 (m) ([])
 in 
check3 (m) (l)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check m  = (60640, 
let rec append m1 m2  = (60566, 
 (match (60546, m1 with 
|h::t -> (60564, if (60551, (60550, (60547, __list_mem__ ((60548, h) ((60549, m2) then (60556, (60555, (60552, append ((60553, t) ((60554, m2)
 else (60563, (60562, (60557, append ((60558, t) ((60561, ((60559, h :: (60560, m2))
|[] -> (60565, m2)
 in 
(60639, 
let rec check2 m l  = (60600, 
 (match (60567, m with 
|V n -> (60568, l
|P (n, m2) -> (60586, if (60573, (60572, (60569, __list_mem__ ((60570, n) ((60571, l) then (60578, (60577, (60574, check2 ((60575, m2) ((60576, l)
 else (60585, (60584, (60579, check2 ((60580, m2) ((60583, ((60581, n :: (60582, l))
|C (m1, m2) -> (60599, (60598, (60587, append ((60592, (60591, (60588, check2 ((60589, m1) ((60590, l)) ((60597, (60596, (60593, check2 ((60594, m2) ((60595, l)))
 in 
(60638, 
let rec check3 m l  = (60626, 
 (match (60601, m with 
|V n -> (60609, if (60606, (60605, (60602, __list_mem__ ((60603, n) ((60604, l) then (60607, true
 else (60608, false
|P (n, m2) -> (60614, (60613, (60610, check3 ((60611, m2) ((60612, l)
|C (m1, m2) -> (60625, ((60619, (60618, (60615, check3 ((60616, m1) ((60617, l) && (60624, (60623, (60620, check3 ((60621, m2) ((60622, l)))
 in 
(60637, 
let l  = (60631, (60630, (60627, check2 ((60628, m) ((60629, [])
 in 
(60636, (60635, (60632, check3 ((60633, m) ((60634, l)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/14/sub55.ml Score : 3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check arg1  = 
let rec check2 arg2 my_list  = 
 (match arg2 with 
|V n -> __list_mem__ (n) (my_list)
|P (a, b) -> check2 (b) (__list_append__ (my_list) ((a :: [])))
|C (c, d) -> (check2 (c) (my_list) && check2 (d) (my_list)))
 in 
check2 (arg1) ([])

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{__list_mem__ -> (49718 : 
Input : elem (lst : #998750 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

append -> (49744 : 
Input : (m1 : string list) (m2 : string list) 
Output : string list
Body : 
 (match m1 with 
|h::t -> if __list_mem__ (h) (m2) then append (t) (m2)
 else append (t) ((h :: m2))
|[] -> m2),

check -> (49743 : 
Input : (m : lambda) 
Output : bool
Body : 
let l  : string list = check2 (m) ([])
 in 
check3 (m) (l),

check2 -> (49745 : 
Input : (m : lambda) (l : string list) 
Output : string list
Body : 
 (match m with 
|V n -> l
|P (n, m2) -> if __list_mem__ (n) (l) then check2 (m2) (l)
 else check2 (m2) ((n :: l))
|C (m1, m2) -> append (check2 (m1) (l)) (check2 (m2) (l))),

check3 -> (49746 : 
Input : (m : lambda) (l : string list) 
Output : bool
Body : 
 (match m with 
|V n -> if __list_mem__ (n) (l) then true
 else false
|P (n, m2) -> check3 (m2) (l)
|C (m1, m2) -> (check3 (m1) (l) && check3 (m2) (l)))}
Edge : 
{(49718, 49718) -> ,
(49743, 49745) -> ,
(49743, 49746) -> ,
(49744, 49718) -> ,
(49744, 49744) -> ,
(49745, 49718) -> ,
(49745, 49744) -> ,
(49745, 49745) -> ,
(49746, 49718) -> ,
(49746, 49746) -> }
Starting : 49743
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{__list_append__ -> (49686 : 
Input : (lst1 : #998072 list) (lst2 : #998072 list) 
Output : #998009 list
Body : (lst1 @ lst2),

__list_mem__ -> (49683 : 
Input : elem (lst : #998041 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (49708 : 
Input : (arg1 : lambda) 
Output : bool
Body : check2 (arg1) ([]),

check2 -> (49709 : 
Input : (arg2 : lambda) (my_list : string list) 
Output : bool
Body : 
 (match arg2 with 
|V n -> __list_mem__ (n) (my_list)
|P (a, b) -> check2 (b) (__list_append__ (my_list) ((a :: [])))
|C (c, d) -> (check2 (c) (my_list) && check2 (d) (my_list)))}
Edge : 
{(49683, 49683) -> ,
(49708, 49709) -> ,
(49709, 49683) -> ,
(49709, 49686) -> ,
(49709, 49709) -> }
Starting : 49708
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{__list_mem__ -> __list_mem__,
append -> __list_append__,
check -> check,
check3 -> check2}
------Remainings in submission ------
{check2}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60566 : (? @ ?))

Decls : 
,Exp : Modify (60601 : ?)

Decls : 
,Exp : Modify (60609 : ? (?) (?))

Decls : 
,Exp : Modify (60614 : ? (?) (? (?) ((? :: []))))

Decls : 
,Exp : Modify (60619 : ? (?) (?))

Decls : 
,Exp : Modify (60624 : ? (?) (?))

Decls : 
,Exp : Modify (60637 : ? (?) ([]))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60566 : (? @ ?))

Decls : 
,Exp : Modify (60601 : ?)

Decls : 
,Exp : Modify (60609 : ? (?) (?))

Decls : 
,Exp : Modify (60614 : ? (?) (? (?) ((? :: []))))

Decls : 
,Exp : Modify (60619 : ? (?) (?))

Decls : 
,Exp : Modify (60624 : ? (?) (?))

Decls : 
,Exp : Modify (60637 : ? (?) ([]))

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check m  = 
let rec append m1 m2  = 
 (match m1 with 
|h::t -> if __list_mem__ (h) (m2) then append (t) (m2)
 else append (t) ((h :: m2))
|[] -> m2)
 in 

let rec check2 m l  = 
 (match m with 
|V n -> l
|P (n, m2) -> if __list_mem__ (n) (l) then check2 (m2) (l)
 else check2 (m2) ((n :: l))
|C (m1, m2) -> append (check2 (m1) (l)) (check2 (m2) (l)))
 in 

let rec check3 m l  = 
 (match m with 
|V n -> if __list_mem__ (n) (l) then true
 else false
|P (n, m2) -> check3 (m2) (append (l) ((n :: [])))
|C (m1, m2) -> (check3 (m1) (l) && check3 (m2) (l)))
 in 
check3 (m) ([])

Time : 8.75380897522
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/09/sub19.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check m  = 
let rec make_area_list m  = 
 (match m with 
|V n -> []
|P (n, m1) -> (n :: make_area_list (m1))
|C (m1, m2) -> (make_area_list (m1) @ make_area_list (m2)))
 in 

let rec match_list_with_station m l  = 
 (match m with 
|P (n, m1) -> match_list_with_station (m1) (l)
|C (m1, m2) -> (match_list_with_station (m1) (l) && match_list_with_station (m2) (l))
|V n -> if __list_exists__ (
fun x -> (x = n)) (l) then true
 else false)
 in 
match_list_with_station (m) (make_area_list (m))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check m  = (60598, 
let rec make_area_list m  = (60560, 
 (match (60546, m with 
|V n -> (60547, []
|P (n, m1) -> (60552, ((60548, n :: (60551, (60549, make_area_list ((60550, m1))
|C (m1, m2) -> (60559, ((60555, (60553, make_area_list ((60554, m1) @ (60558, (60556, make_area_list ((60557, m2)))
 in 
(60597, 
let rec match_list_with_station m l  = (60589, 
 (match (60561, m with 
|P (n, m1) -> (60566, (60565, (60562, match_list_with_station ((60563, m1) ((60564, l)
|C (m1, m2) -> (60577, ((60571, (60570, (60567, match_list_with_station ((60568, m1) ((60569, l) && (60576, (60575, (60572, match_list_with_station ((60573, m2) ((60574, l))
|V n -> (60588, if (60585, (60584, (60578, __list_exists__ ((60582, 
fun x -> (60581, ((60579, x = (60580, n)) ((60583, l) then (60586, true
 else (60587, false)
 in 
(60596, (60595, (60590, match_list_with_station ((60591, m) ((60594, (60592, make_area_list ((60593, m))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub6.ml Score : 2
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec find_stack  = 
fun v stack -> 
 (match stack with 
|hd::tl -> if (hd = v) then true
 else find_stack (v) (tl)
|[] -> false)

let rec check_inner  = 
fun lam stack -> 
 (match lam with 
|V v -> if find_stack (v) (stack) then true
 else false
|P (v, l) -> check_inner (l) ((v :: stack))
|C (l1, l2) -> (check_inner (l1) (stack) && check_inner (l2) (stack)))

let check  : (lambda -> bool) = 
fun lam -> check_inner (lam) ([])

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{__list_exists__ -> (48399 : 
Input : (pred : (#973648 -> bool)) (lst : #973648 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> (pred (hd) || __list_exists__ (pred) (tl))),

check -> (48423 : 
Input : (m : lambda) 
Output : bool
Body : match_list_with_station (m) (make_area_list (m)),

make_area_list -> (48424 : 
Input : (m : lambda) 
Output : string list
Body : 
 (match m with 
|V n -> []
|P (n, m1) -> (n :: make_area_list (m1))
|C (m1, m2) -> (make_area_list (m1) @ make_area_list (m2))),

match_list_with_station -> (48425 : 
Input : (m : lambda) (l : string list) 
Output : bool
Body : 
 (match m with 
|P (n, m1) -> match_list_with_station (m1) (l)
|C (m1, m2) -> (match_list_with_station (m1) (l) && match_list_with_station (m2) (l))
|V n -> if __list_exists__ (
fun (x : string) -> (x = n)) (l) then true
 else false)}
Edge : 
{(48399, 48399) -> ,
(48423, 48424) -> ,
(48423, 48425) -> ,
(48424, 48424) -> ,
(48425, 48399) -> ,
(48425, 48425) -> }
Starting : 48423
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (48388 : 
Input : (lam : lambda) 
Output : bool
Body : check_inner (lam) ([]),

check_inner -> (48387 : 
Input : (lam : lambda) (stack : string list) 
Output : bool
Body : 
 (match lam with 
|V v -> if find_stack (v) (stack) then true
 else false
|P (v, l) -> check_inner (l) ((v :: stack))
|C (l1, l2) -> (check_inner (l1) (stack) && check_inner (l2) (stack))),

find_stack -> (48386 : 
Input : v (stack : #973318 list) 
Output : bool
Body : 
 (match stack with 
|hd::tl -> if (hd = v) then true
 else find_stack (v) (tl)
|[] -> false)}
Edge : 
{(48386, 48386) -> ,
(48387, 48386) -> ,
(48387, 48387) -> ,
(48388, 48387) -> }
Starting : 48388
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{__list_exists__ -> find_stack,
check -> check,
match_list_with_station -> check_inner}
------Remainings in submission ------
{make_area_list}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60561 : ?)

Decls : 
,Exp : Modify (60566 : ? (?) ((? :: ?)))

Decls : 
,Exp : Modify (60571 : ? (?) (?))

Decls : 
,Exp : Modify (60576 : ? (?) (?))

Decls : 
,Exp : Modify (60585 : ? (?) (?))

Decls : 
,Exp : Modify (60596 : ? (?) ([]))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60561 : ?)

Decls : 
,Exp : Modify (60566 : ? (?) ((? :: ?)))

Decls : 
,Exp : Modify (60571 : ? (?) (?))

Decls : 
,Exp : Modify (60576 : ? (?) (?))

Decls : 
,Exp : Modify (60585 : ? (?) (?))

Decls : 
,Exp : Modify (60596 : ? (?) ([]))

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check m  = 
let rec make_area_list m  = 
 (match m with 
|V n -> []
|P (n, m1) -> (n :: make_area_list (m1))
|C (m1, m2) -> (make_area_list (m1) @ make_area_list (m2)))
 in 

let rec match_list_with_station m l  = 
 (match m with 
|P (n, m1) -> match_list_with_station (m1) ((n :: l))
|C (m1, m2) -> (match_list_with_station (m1) (l) && match_list_with_station (m2) (l))
|V n -> if __list_exists__ (
fun x -> (x = n)) (l) then true
 else false)
 in 
match_list_with_station (m) ([])

Time : 6.0829949379
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/09/sub20.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

exception Error of string
type lambda =
|V of string
|P of (string * lambda)
|C of (lambda * lambda)

let rec check met  = 
let rec check a me  = 
 (match me with 
|V x -> if (x = a) then true
 else false
|P (q, V b) -> if (a = b) then true
 else false
|P (x, C (t, p)) -> 
 (match (t, p) with 
|(V e, V f) -> (check (x) (t) || check (x) (p))
|_ -> (check (x) (t) && check (x) (p)))
|P (x, P (e, f)) -> (check (x) (P ((e, f))) && check (e) (f))
|C (x, y) -> 
 (match (x, y) with 
|(V e, V f) -> (check (a) (x) || check (a) (y))
|_ -> (check (a) (x) && check (a) (x))))
 in 

 (match met with 
|P (b, c) -> check (b) (c)
|_ -> raise Error ("Illegal input"))

-----------------------------
Submission
-----------------------------

exception Error of string
type lambda =
|C of (lambda * lambda)
|P of (string * lambda)
|V of string

let rec check met  = (60636, 
let rec check a me  = (60625, 
 (match (60546, me with 
|V x -> (60552, if (60549, ((60547, x = (60548, a) then (60550, true
 else (60551, false
|P (q, V b) -> (60558, if (60555, ((60553, a = (60554, b) then (60556, true
 else (60557, false
|P (x, C (t, p)) -> (60584, 
 (match (60561, ((60559, t, (60560, p) with 
|(V e, V f) -> (60572, ((60566, (60565, (60562, check ((60563, x) ((60564, t) || (60571, (60570, (60567, check ((60568, x) ((60569, p))
|_ -> (60583, ((60577, (60576, (60573, check ((60574, x) ((60575, t) && (60582, (60581, (60578, check ((60579, x) ((60580, p)))
|P (x, P (e, f)) -> (60598, ((60592, (60591, (60585, check ((60586, x) ((60590, P ((60589, ((60587, e, (60588, f))) && (60597, (60596, (60593, check ((60594, e) ((60595, f))
|C (x, y) -> (60624, 
 (match (60601, ((60599, x, (60600, y) with 
|(V e, V f) -> (60612, ((60606, (60605, (60602, check ((60603, a) ((60604, x) || (60611, (60610, (60607, check ((60608, a) ((60609, y))
|_ -> (60623, ((60617, (60616, (60613, check ((60614, a) ((60615, x) && (60622, (60621, (60618, check ((60619, a) ((60620, x))))
 in 
(60635, 
 (match (60626, met with 
|P (b, c) -> (60631, (60630, (60627, check ((60628, b) ((60629, c)
|_ -> (60634, raise (60633, Error ((60632, "Illegal input")))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (47099 : 
Input : (met : lambda) 
Output : bool
Body : 
 (match met with 
|P (b, c) -> check (b) (c)
|_ -> raise Error ("Illegal input"))}
Edge : 
{(47099, 47100) -> ,
(47100, 47100) -> }
Starting : 47099
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (47065 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (47064 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(47064, 47064) -> ,
(47065, 47064) -> }
Starting : 47065
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60635 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60635 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

exception Error of string
type lambda =
|V of string
|P of (string * lambda)
|C of (lambda * lambda)

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check met  = 
let rec check a me  = 
 (match me with 
|V x -> if (x = a) then true
 else false
|P (q, V b) -> if (a = b) then true
 else false
|P (x, C (t, p)) -> 
 (match (t, p) with 
|(V e, V f) -> (check (x) (t) || check (x) (p))
|_ -> (check (x) (t) && check (x) (p)))
|P (x, P (e, f)) -> (check (x) (P ((e, f))) && check (e) (f))
|C (x, y) -> 
 (match (x, y) with 
|(V e, V f) -> (check (a) (x) || check (a) (y))
|_ -> (check (a) (x) && check (a) (x))))
 in 
checking (met) ([])

Time : 0.00236105918884
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/10/sub21.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check met  = 
let rec check met lst  = 
 (match met with 
|V id -> __list_mem__ (id) (lst)
|P (id, m) -> check (m) ((lst @ [id]))
|C (m1, m2) -> (check (m1) (lst) && check (m2) (lst)))
 in 

 (match met with 
|V id -> false
|P (id, m) -> check (m) ([id])
|C (m1, m2) -> false)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check met  = (60582, 
let rec check met lst  = (60571, 
 (match (60546, met with 
|V id -> (60551, (60550, (60547, __list_mem__ ((60548, id) ((60549, lst)
|P (id, m) -> (60559, (60558, (60552, check ((60553, m) ((60557, ((60554, lst @ (60556, [(60555, id]))
|C (m1, m2) -> (60570, ((60564, (60563, (60560, check ((60561, m1) ((60562, lst) && (60569, (60568, (60565, check ((60566, m2) ((60567, lst)))
 in 
(60581, 
 (match (60572, met with 
|V id -> (60573, false
|P (id, m) -> (60579, (60578, (60574, check ((60575, m) ((60577, [(60576, id])
|C (m1, m2) -> (60580, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 2
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{__list_mem__ -> (47074 : 
Input : elem (lst : #965819 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (47099 : 
Input : (met : lambda) 
Output : bool
Body : 
 (match met with 
|V id -> false
|P (id, m) -> check (m) ([id])
|C (m1, m2) -> false)}
Edge : 
{(47074, 47074) -> ,
(47099, 47100) -> ,
(47100, 47074) -> ,
(47100, 47100) -> }
Starting : 47099
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (47065 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (47064 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(47064, 47064) -> ,
(47065, 47064) -> }
Starting : 47065
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{__list_mem__ -> checking,
check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60581 : ? (?) ([]))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60581 : ? (?) ([]))

Decls : 
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/10/sub7.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check lambda  = 
 (match lambda with 
|V var -> false
|P (var1, V var2) -> (var1 = var2)
|P (var1, P (var2, C (lambda1, lambda2))) -> ((check (P ((var1, lambda1))) && check (P ((var2, lambda2)))) || (check (P ((var1, lambda2))) && check (P ((var2, lambda1)))))
|P (var1, P (var2, lambda)) -> (check (P ((var1, lambda))) || check (P ((var2, lambda))))
|P (var, C (lambda1, lambda2)) -> (check (P ((var, lambda1))) && check (P ((var, lambda2))))
|C (lambda1, lambda2) -> (check (lambda1) && check (lambda2)))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check lambda  = (60611, 
 (match (60546, lambda with 
|V var -> (60547, false
|P (var1, V var2) -> (60550, ((60548, var1 = (60549, var2)
|P (var1, P (var2, C (lambda1, lambda2))) -> (60577, ((60563, ((60556, (60551, check ((60555, P ((60554, ((60552, var1, (60553, lambda1))) && (60562, (60557, check ((60561, P ((60560, ((60558, var2, (60559, lambda2)))) || (60576, ((60569, (60564, check ((60568, P ((60567, ((60565, var1, (60566, lambda2))) && (60575, (60570, check ((60574, P ((60573, ((60571, var2, (60572, lambda1)))))
|P (var1, P (var2, lambda)) -> (60590, ((60583, (60578, check ((60582, P ((60581, ((60579, var1, (60580, lambda))) || (60589, (60584, check ((60588, P ((60587, ((60585, var2, (60586, lambda))))
|P (var, C (lambda1, lambda2)) -> (60603, ((60596, (60591, check ((60595, P ((60594, ((60592, var, (60593, lambda1))) && (60602, (60597, check ((60601, P ((60600, ((60598, var, (60599, lambda2))))
|C (lambda1, lambda2) -> (60610, ((60606, (60604, check ((60605, lambda1) && (60609, (60607, check ((60608, lambda2)))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|V var -> false
|P (var1, V var2) -> (var1 = var2)
|P (var1, P (var2, C (lambda1, lambda2))) -> ((check (P ((var1, lambda1))) && check (P ((var2, lambda2)))) || (check (P ((var1, lambda2))) && check (P ((var2, lambda1)))))
|P (var1, P (var2, lambda)) -> (check (P ((var1, lambda))) || check (P ((var2, lambda))))
|P (var, C (lambda1, lambda2)) -> (check (P ((var, lambda1))) && check (P ((var, lambda2))))
|C (lambda1, lambda2) -> (check (lambda1) && check (lambda2)))}
Edge : 
{(45777, 45777) -> }
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60611 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60611 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check lambda  = checking (lambda) ([])

Time : 0.00185489654541
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/11/sub13.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check m  = 
let rec idCheck id_list m  = 
let rec exists f l  = 
 (match l with 
|[] -> false
|h::t -> if (f = h) then true
 else exists (f) (t))
 in 

 (match m with 
|V a -> exists (a) (id_list)
|P (id1, m1) -> idCheck ((id1 :: id_list)) (m1)
|C (m1, m2) -> (idCheck (id_list) (m1) && idCheck (id_list) (m2)))
 in 

 (match m with 
|P (var, lambda) -> idCheck ((var :: [])) (lambda)
|_ -> false)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check m  = (60595, 
let rec idCheck id_list m  = (60584, 
let rec exists f l  = (60558, 
 (match (60546, l with 
|[] -> (60547, false
|h::t -> (60557, if (60550, ((60548, f = (60549, h) then (60551, true
 else (60556, (60555, (60552, exists ((60553, f) ((60554, t))
 in 
(60583, 
 (match (60559, m with 
|V a -> (60564, (60563, (60560, exists ((60561, a) ((60562, id_list)
|P (id1, m1) -> (60571, (60570, (60565, idCheck ((60568, ((60566, id1 :: (60567, id_list)) ((60569, m1)
|C (m1, m2) -> (60582, ((60576, (60575, (60572, idCheck ((60573, id_list) ((60574, m1) && (60581, (60580, (60577, idCheck ((60578, id_list) ((60579, m2)))
 in 
(60594, 
 (match (60585, m with 
|P (var, lambda) -> (60592, (60591, (60586, idCheck ((60589, ((60587, var :: (60588, [])) ((60590, lambda)
|_ -> (60593, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub55.ml Score : 3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checklambda  : (var list -> (lambda -> bool)) = 
fun lst lam -> 
 (match lam with 
|V x -> __list_mem__ (x) (lst)
|P (x, l) -> checklambda ((x :: lst)) (l)
|C (l1, l2) -> (checklambda (lst) (l1) && checklambda (lst) (l2)))

let check  : (lambda -> bool) = 
fun lam -> checklambda ([]) (lam)

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (48421 : 
Input : (m : lambda) 
Output : bool
Body : 
 (match m with 
|P (var, lambda) -> idCheck ((var :: [])) (lambda)
|_ -> false),

exists -> (48423 : 
Input : (f : string) (l : string list) 
Output : bool
Body : 
 (match l with 
|[] -> false
|h::t -> if (f = h) then true
 else exists (f) (t)),

idCheck -> (48422 : 
Input : (id_list : string list) (m : lambda) 
Output : bool
Body : 
 (match m with 
|V a -> exists (a) (id_list)
|P (id1, m1) -> idCheck ((id1 :: id_list)) (m1)
|C (m1, m2) -> (idCheck (id_list) (m1) && idCheck (id_list) (m2)))}
Edge : 
{(48421, 48422) -> ,
(48422, 48422) -> ,
(48422, 48423) -> ,
(48423, 48423) -> }
Starting : 48421
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{__list_mem__ -> (48361 : 
Input : elem (lst : #970275 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (48387 : 
Input : (lam : lambda) 
Output : bool
Body : checklambda ([]) (lam),

checklambda -> (48386 : 
Input : (lst : string list) (lam : lambda) 
Output : bool
Body : 
 (match lam with 
|V x -> __list_mem__ (x) (lst)
|P (x, l) -> checklambda ((x :: lst)) (l)
|C (l1, l2) -> (checklambda (lst) (l1) && checklambda (lst) (l2)))}
Edge : 
{(48361, 48361) -> ,
(48386, 48361) -> ,
(48386, 48386) -> ,
(48387, 48386) -> }
Starting : 48387
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
exists -> __list_mem__,
idCheck -> checklambda}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60557 : ((? = ?) || ? (?) (?)))

Decls : 
,Exp : Modify (60559 : ?)

Decls : 
,Exp : Modify (60564 : ? (?) (?))

Decls : 
,Exp : Modify (60571 : ? ((? :: ?)) (?))

Decls : 
,Exp : Modify (60576 : ? (?) (?))

Decls : 
,Exp : Modify (60581 : ? (?) (?))

Decls : 
,Exp : Modify (60594 : ? ([]) (?))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60594 : ? ([]) (?))

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check m  = 
let rec idCheck id_list m  = 
let rec exists f l  = 
 (match l with 
|[] -> false
|h::t -> if (f = h) then true
 else exists (f) (t))
 in 

 (match m with 
|V a -> exists (a) (id_list)
|P (id1, m1) -> idCheck ((id1 :: id_list)) (m1)
|C (m1, m2) -> (idCheck (id_list) (m1) && idCheck (id_list) (m2)))
 in 
idCheck ([]) (m)

Time : 0.00167298316956
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/11/sub16.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check lambda  = 
 (match lambda with 
|P (a, V b) -> (a = b)
|P (a, C (b, c)) -> (check (P ((a, b))) && check (P ((a, c))))
|P (a, P (b, c)) -> check (P ((a, c)))
|C (_, _) -> false
|V _ -> false)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check lambda  = (60571, 
 (match (60546, lambda with 
|P (a, V b) -> (60549, ((60547, a = (60548, b)
|P (a, C (b, c)) -> (60562, ((60555, (60550, check ((60554, P ((60553, ((60551, a, (60552, b))) && (60561, (60556, check ((60560, P ((60559, ((60557, a, (60558, c))))
|P (a, P (b, c)) -> (60568, (60563, check ((60567, P ((60566, ((60564, a, (60565, c)))
|C (_, _) -> (60569, false
|V _ -> (60570, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|P (a, V b) -> (a = b)
|P (a, C (b, c)) -> (check (P ((a, b))) && check (P ((a, c))))
|P (a, P (b, c)) -> check (P ((a, c)))
|C (_, _) -> false
|V _ -> false)}
Edge : 
{(45777, 45777) -> }
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60571 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60571 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check lambda  = checking (lambda) ([])

Time : 0.00176405906677
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/11/sub21.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec sub (l, a)  = 
 (match l with 
|[] -> []
|hd::tl -> if (hd = a) then sub ((tl, a))
 else (hd :: sub ((tl, a))))

let rec concat (a, b)  = 
 (match a with 
|[] -> b
|hd::tl -> (hd :: concat ((tl, b))))

let rec listsub (m : lambda)  = 
 (match m with 
|V a -> [a]
|P (a, b) -> sub ((listsub (b), a))
|C (a, b) -> concat ((listsub (a), listsub (b))))

let check (m : lambda)  = 
 (match m with 
|V a -> false
|P (a, b) -> if (sub ((listsub (b), a)) = []) then true
 else false
|C (a, b) -> false)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec sub (l, a)  = (60564, 
 (match (60546, l with 
|[] -> (60547, []
|hd::tl -> (60563, if (60550, ((60548, hd = (60549, a) then (60555, (60551, sub ((60554, ((60552, tl, (60553, a))
 else (60562, ((60556, hd :: (60561, (60557, sub ((60560, ((60558, tl, (60559, a))))

let rec concat (a, b)  = (60574, 
 (match (60565, a with 
|[] -> (60566, b
|hd::tl -> (60573, ((60567, hd :: (60572, (60568, concat ((60571, ((60569, tl, (60570, b))))

let rec listsub (m : lambda)  = (60594, 
 (match (60575, m with 
|V a -> (60577, [(60576, a]
|P (a, b) -> (60584, (60578, sub ((60583, ((60581, (60579, listsub ((60580, b), (60582, a))
|C (a, b) -> (60593, (60585, concat ((60592, ((60588, (60586, listsub ((60587, a), (60591, (60589, listsub ((60590, b))))

let check (m : lambda)  = (60610, 
 (match (60595, m with 
|V a -> (60596, false
|P (a, b) -> (60608, if (60605, ((60603, (60597, sub ((60602, ((60600, (60598, listsub ((60599, b), (60601, a)) = (60604, []) then (60606, true
 else (60607, false
|C (a, b) -> (60609, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/11/sub2.ml Score : 2
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check lambda_input  = 
let rec listStation m_input  = 
 (match m_input with 
|V n -> [n]
|P (n, m) -> deleteAll ((listStation (m), n))
|C (m1, m2) -> (listStation (m1) @ listStation (m2)))
and deleteAll (list_input, target)  = 
 (match list_input with 
|l::remain_list -> if (l = target) then deleteAll ((remain_list, target))
 else (l :: deleteAll ((remain_list, target)))
|[] -> [])
 in 
if (listStation (lambda_input) = []) then true
 else false

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (49748 : 
Input : (m : lambda) 
Output : bool
Body : 
 (match m with 
|V a -> false
|P (a, b) -> if (sub ((listsub (b), a)) = []) then true
 else false
|C (a, b) -> false),

concat -> (49746 : 
Input : ((a : #1000497 list), (b : #1000497 list)) 
Output : #1000497 list
Body : 
 (match a with 
|[] -> b
|hd::tl -> (hd :: concat ((tl, b)))),

listsub -> (49747 : 
Input : (m : lambda) 
Output : string list
Body : 
 (match m with 
|V a -> [a]
|P (a, b) -> sub ((listsub (b), a))
|C (a, b) -> concat ((listsub (a), listsub (b)))),

sub -> (49745 : 
Input : ((l : #1000493 list), a) 
Output : #1000493 list
Body : 
 (match l with 
|[] -> []
|hd::tl -> if (hd = a) then sub ((tl, a))
 else (hd :: sub ((tl, a))))}
Edge : 
{(49745, 49745) -> ,
(49746, 49746) -> ,
(49747, 49745) -> ,
(49747, 49746) -> ,
(49747, 49747) -> ,
(49748, 49745) -> ,
(49748, 49747) -> }
Starting : 49748
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (49708 : 
Input : (lambda_input : lambda) 
Output : bool
Body : if (listStation (lambda_input) = []) then true
 else false,

deleteAll -> (49710 : 
Input : ((list_input : string list), (target : string)) 
Output : string list
Body : 
 (match list_input with 
|l::remain_list -> if (l = target) then deleteAll ((remain_list, target))
 else (l :: deleteAll ((remain_list, target)))
|[] -> []),

listStation -> (49709 : 
Input : (m_input : lambda) 
Output : string list
Body : 
 (match m_input with 
|V n -> [n]
|P (n, m) -> deleteAll ((listStation (m), n))
|C (m1, m2) -> (listStation (m1) @ listStation (m2)))}
Edge : 
{(49708, 49709) -> ,
(49709, 49709) -> ,
(49709, 49710) -> ,
(49710, 49710) -> }
Starting : 49708
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
listsub -> listStation,
sub -> deleteAll}
------Remainings in submission ------
{concat}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60548 : ?)

Decls : 
,Exp : Modify (60549 : ?)

Decls : 
,Exp : Modify (60555 : ? ((?, ?)))

Decls : 
,Exp : Modify (60556 : ?)

Decls : 
,Exp : Modify (60561 : ? ((?, ?)))

Decls : 
,Exp : Modify (60575 : ?)

Decls : 
,Exp : Modify (60576 : ?)

Decls : 
,Exp : Modify (60584 : ? ((? (?), ?)))

Decls : 
,Exp : Modify (60593 : (? (?) @ ? (?)))

Decls : 
,Exp : Modify (60610 : if (? (?) = []) then true
 else false)

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60610 : if (? (?) = []) then true
 else false)

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec sub (l, a)  = 
 (match l with 
|[] -> []
|hd::tl -> if (hd = a) then sub ((tl, a))
 else (hd :: sub ((tl, a))))

let rec concat (a, b)  = 
 (match a with 
|[] -> b
|hd::tl -> (hd :: concat ((tl, b))))

let rec listsub (m : lambda)  = 
 (match m with 
|V a -> [a]
|P (a, b) -> sub ((listsub (b), a))
|C (a, b) -> concat ((listsub (a), listsub (b))))

let check (m : lambda)  = if (listsub (m) = []) then true
 else false

Time : 0.00199294090271
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/11/sub3.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

exception Invalid_input of string

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check m  = 
let rec check_sub (m, l)  = 
let rec checkArea (s, l)  = 
 (match l with 
|[] -> false
|h::t -> if (h = s) then true
 else checkArea ((s, t)))
 in 

 (match m with 
|V s -> checkArea ((s, l))
|P (a, m) -> check_sub ((m, (a :: l)))
|C (m0, m1) -> (check_sub ((m0, l)) && check_sub ((m1, l))))
 in 

 (match m with 
|V s -> raise Invalid_input ("V only")
|_ -> check_sub ((m, [])))

-----------------------------
Submission
-----------------------------

exception Invalid_input of string

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check m  = (60595, 
let rec check_sub (m, l)  = (60584, 
let rec checkArea (s, l)  = (60558, 
 (match (60546, l with 
|[] -> (60547, false
|h::t -> (60557, if (60550, ((60548, h = (60549, s) then (60551, true
 else (60556, (60552, checkArea ((60555, ((60553, s, (60554, t)))
 in 
(60583, 
 (match (60559, m with 
|V s -> (60564, (60560, checkArea ((60563, ((60561, s, (60562, l))
|P (a, m) -> (60571, (60565, check_sub ((60570, ((60566, m, (60569, ((60567, a :: (60568, l)))
|C (m0, m1) -> (60582, ((60576, (60572, check_sub ((60575, ((60573, m0, (60574, l)) && (60581, (60577, check_sub ((60580, ((60578, m1, (60579, l))))
 in 
(60594, 
 (match (60585, m with 
|V s -> (60588, raise (60587, Invalid_input ((60586, "V only"))
|_ -> (60593, (60589, check_sub ((60592, ((60590, m, (60591, [])))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_16/sub97.ml Score : 3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec mem  : ((var * var list) -> bool) = 
fun (key, lst) -> 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = key) then true
 else (false || mem ((key, tl))))

let check  : (lambda -> bool) = 
fun lambda -> 
let rec ch  : ((lambda * var list) -> bool) = 
fun (lambda, lst) -> 
 (match lambda with 
|V x -> mem ((x, lst))
|P (x, p) -> ch ((p, (x :: lst)))
|C (p, q) -> (ch ((p, lst)) && ch ((q, lst))))
 in 
ch ((lambda, []))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (48423 : 
Input : (m : lambda) 
Output : bool
Body : 
 (match m with 
|V s -> raise Invalid_input ("V only")
|_ -> check_sub ((m, []))),

checkArea -> (48425 : 
Input : ((s : string), (l : string list)) 
Output : bool
Body : 
 (match l with 
|[] -> false
|h::t -> if (h = s) then true
 else checkArea ((s, t))),

check_sub -> (48424 : 
Input : ((m : lambda), (l : string list)) 
Output : bool
Body : 
 (match m with 
|V s -> checkArea ((s, l))
|P (a, m) -> check_sub ((m, (a :: l)))
|C (m0, m1) -> (check_sub ((m0, l)) && check_sub ((m1, l))))}
Edge : 
{(48423, 48424) -> ,
(48424, 48424) -> ,
(48424, 48425) -> ,
(48425, 48425) -> }
Starting : 48423
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{ch -> (48388 : 
Input : ((lambda : lambda), (lst : string list)) 
Output : bool
Body : 
 (match lambda with 
|V x -> mem ((x, lst))
|P (x, p) -> ch ((p, (x :: lst)))
|C (p, q) -> (ch ((p, lst)) && ch ((q, lst)))),

check -> (48387 : 
Input : (lambda : lambda) 
Output : bool
Body : ch ((lambda, [])),

mem -> (48386 : 
Input : (key, (lst : #973318 list)) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = key) then true
 else (false || mem ((key, tl))))}
Edge : 
{(48386, 48386) -> ,
(48387, 48388) -> ,
(48388, 48386) -> ,
(48388, 48388) -> }
Starting : 48387
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
checkArea -> mem,
check_sub -> ch}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60548 : ?)

Decls : 
,Exp : Modify (60549 : ?)

Decls : 
,Exp : Modify (60556 : (false || ? ((?, ?))))

Decls : 
,Exp : Modify (60559 : ?)

Decls : 
,Exp : Modify (60564 : ? ((?, ?)))

Decls : 
,Exp : Modify (60571 : ? ((?, (? :: ?))))

Decls : 
,Exp : Modify (60576 : ? ((?, ?)))

Decls : 
,Exp : Modify (60581 : ? ((?, ?)))

Decls : 
,Exp : Modify (60594 : ? ((?, [])))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60594 : ? ((?, [])))

Decls : 
}
-----------------------------
Patch
-----------------------------

exception Invalid_input of string

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check m  = 
let rec check_sub (m, l)  = 
let rec checkArea (s, l)  = 
 (match l with 
|[] -> false
|h::t -> if (h = s) then true
 else checkArea ((s, t)))
 in 

 (match m with 
|V s -> checkArea ((s, l))
|P (a, m) -> check_sub ((m, (a :: l)))
|C (m0, m1) -> (check_sub ((m0, l)) && check_sub ((m1, l))))
 in 
check_sub ((m, []))

Time : 0.00168704986572
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/11/sub5.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check a  = 
 (match a with 
|V _ -> raise Invalid_argument ("check")
|C (a, b) -> raise Invalid_argument ("check")
|P (a, V b) -> if (a = b) then true
 else false
|P (a, C (V b, V c)) -> if ((a = b) || (a = c)) then true
 else false
|P (a, C (P (b, V c), V d)) -> if ((a = c) || (a = d)) then true
 else false
|P (a, C (V b, P (c, V d))) -> if ((a = b) || (a = d)) then true
 else false
|P (a, b) -> check (b))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check a  = (60592, 
 (match (60546, a with 
|V _ -> (60549, raise (60548, Invalid_argument ((60547, "check"))
|C (a, b) -> (60552, raise (60551, Invalid_argument ((60550, "check"))
|P (a, V b) -> (60558, if (60555, ((60553, a = (60554, b) then (60556, true
 else (60557, false
|P (a, C (V b, V c)) -> (60568, if (60565, ((60561, ((60559, a = (60560, b) || (60564, ((60562, a = (60563, c)) then (60566, true
 else (60567, false
|P (a, C (P (b, V c), V d)) -> (60578, if (60575, ((60571, ((60569, a = (60570, c) || (60574, ((60572, a = (60573, d)) then (60576, true
 else (60577, false
|P (a, C (V b, P (c, V d))) -> (60588, if (60585, ((60581, ((60579, a = (60580, b) || (60584, ((60582, a = (60583, d)) then (60586, true
 else (60587, false
|P (a, b) -> (60591, (60589, check ((60590, b))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : (a : lambda) 
Output : bool
Body : 
 (match a with 
|V _ -> raise Invalid_argument ("check")
|C (a, b) -> raise Invalid_argument ("check")
|P (a, V b) -> if (a = b) then true
 else false
|P (a, C (V b, V c)) -> if ((a = b) || (a = c)) then true
 else false
|P (a, C (P (b, V c), V d)) -> if ((a = c) || (a = d)) then true
 else false
|P (a, C (V b, P (c, V d))) -> if ((a = b) || (a = d)) then true
 else false
|P (a, b) -> check (b))}
Edge : 
{(45777, 45777) -> }
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60592 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60592 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check a  = checking (a) ([])

Time : 0.00182414054871
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/11/sub6.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check a  = 
 (match a with 
|V _ -> raise Invalid_argument ("check")
|C (a, b) -> raise Invalid_argument ("check")
|P (a, V b) -> if (a = b) then true
 else false
|P (a, C (V b, V c)) -> if ((a = b) || (a = c)) then true
 else false
|P (a, C (P (b, V c), V d)) -> if ((a = c) && (a = d)) then true
 else false
|P (a, C (V b, P (c, V d))) -> if ((a = b) && (a = d)) then true
 else false
|P (a, b) -> check (b))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check a  = (60592, 
 (match (60546, a with 
|V _ -> (60549, raise (60548, Invalid_argument ((60547, "check"))
|C (a, b) -> (60552, raise (60551, Invalid_argument ((60550, "check"))
|P (a, V b) -> (60558, if (60555, ((60553, a = (60554, b) then (60556, true
 else (60557, false
|P (a, C (V b, V c)) -> (60568, if (60565, ((60561, ((60559, a = (60560, b) || (60564, ((60562, a = (60563, c)) then (60566, true
 else (60567, false
|P (a, C (P (b, V c), V d)) -> (60578, if (60575, ((60571, ((60569, a = (60570, c) && (60574, ((60572, a = (60573, d)) then (60576, true
 else (60577, false
|P (a, C (V b, P (c, V d))) -> (60588, if (60585, ((60581, ((60579, a = (60580, b) && (60584, ((60582, a = (60583, d)) then (60586, true
 else (60587, false
|P (a, b) -> (60591, (60589, check ((60590, b))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : (a : lambda) 
Output : bool
Body : 
 (match a with 
|V _ -> raise Invalid_argument ("check")
|C (a, b) -> raise Invalid_argument ("check")
|P (a, V b) -> if (a = b) then true
 else false
|P (a, C (V b, V c)) -> if ((a = b) || (a = c)) then true
 else false
|P (a, C (P (b, V c), V d)) -> if ((a = c) && (a = d)) then true
 else false
|P (a, C (V b, P (c, V d))) -> if ((a = b) && (a = d)) then true
 else false
|P (a, b) -> check (b))}
Edge : 
{(45777, 45777) -> }
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60592 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60592 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check a  = checking (a) ([])

Time : 0.00182104110718

Error occurs : 
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/11/sub7.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases

Error occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/11/sub8.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases

Error occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/12/sub10.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases

../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/12/sub17.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check lambda  = 
let rec varStation lambda  = 
 (match lambda with 
|V n -> (n :: [])
|P (n, m) -> varStation (m)
|C (m1, m2) -> __list_append__ (varStation (m1)) (varStation (m2)))
 in 

let rec varArea lambda  = 
 (match lambda with 
|V n -> []
|P (n, m) -> (n :: varArea (m))
|C (m1, m2) -> __list_append__ (varArea (m1)) (varArea (m2)))
 in 

let rec check l1 l2  = 
 (match l1 with 
|[] -> true
|hd::tl -> (__list_mem__ (hd) (l2) && check (tl) (l2)))
 in 
check (varStation (lambda)) (varArea (lambda))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check lambda  = (60605, 
let rec varStation lambda  = (60562, 
 (match (60546, lambda with 
|V n -> (60549, ((60547, n :: (60548, [])
|P (n, m) -> (60552, (60550, varStation ((60551, m)
|C (m1, m2) -> (60561, (60560, (60553, __list_append__ ((60556, (60554, varStation ((60555, m1)) ((60559, (60557, varStation ((60558, m2)))
 in 
(60604, 
let rec varArea lambda  = (60579, 
 (match (60563, lambda with 
|V n -> (60564, []
|P (n, m) -> (60569, ((60565, n :: (60568, (60566, varArea ((60567, m))
|C (m1, m2) -> (60578, (60577, (60570, __list_append__ ((60573, (60571, varArea ((60572, m1)) ((60576, (60574, varArea ((60575, m2)))
 in 
(60603, 
let rec check l1 l2  = (60593, 
 (match (60580, l1 with 
|[] -> (60581, true
|hd::tl -> (60592, ((60586, (60585, (60582, __list_mem__ ((60583, hd) ((60584, l2) && (60591, (60590, (60587, check ((60588, tl) ((60589, l2)))
 in 
(60602, (60601, (60594, check ((60597, (60595, varStation ((60596, lambda)) ((60600, (60598, varArea ((60599, lambda))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_15/sub65.ml Score : 2
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec free_vars  = 
fun __fun__ -> 
 (match __fun__ with 
|V v -> [v]
|P (v, e) -> __list_filter__ (
fun x -> (x != v)) (free_vars (e))
|C (e1, e2) -> 
let f_e1  = free_vars (e1)
 in 

let f_e2  = free_vars (e2)
 in 
__list_append__ (f_e1) (__list_filter__ (
fun x -> not (__list_mem__ (x) (f_e1))) (f_e2)))

let rec fresh_var v1 l  = if __list_mem__ (v1) (l) then fresh_var ((v1 ^ "'")) (l)
 else v1

let check  : (lambda -> bool) = 
fun e -> if (free_vars (e) = []) then true
 else false

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{__list_append__ -> (49723 : 
Input : (lst1 : #984250 list) (lst2 : #984250 list) 
Output : #984187 list
Body : (lst1 @ lst2),

__list_mem__ -> (49720 : 
Input : elem (lst : #984219 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (49745 : 
Input : (lambda : lambda) 
Output : bool
Body : check (varStation (lambda)) (varArea (lambda)),

varArea -> (49747 : 
Input : (lambda : lambda) 
Output : string list
Body : 
 (match lambda with 
|V n -> []
|P (n, m) -> (n :: varArea (m))
|C (m1, m2) -> __list_append__ (varArea (m1)) (varArea (m2))),

varStation -> (49746 : 
Input : (lambda : lambda) 
Output : string list
Body : 
 (match lambda with 
|V n -> (n :: [])
|P (n, m) -> varStation (m)
|C (m1, m2) -> __list_append__ (varStation (m1)) (varStation (m2)))}
Edge : 
{(49720, 49720) -> ,
(49745, 49746) -> ,
(49745, 49747) -> ,
(49745, 49748) -> ,
(49746, 49723) -> ,
(49746, 49746) -> ,
(49747, 49723) -> ,
(49747, 49747) -> ,
(49748, 49720) -> ,
(49748, 49748) -> }
Starting : 49745
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{__list_append__ -> (49686 : 
Input : (lst1 : #983527 list) (lst2 : #983527 list) 
Output : #983464 list
Body : (lst1 @ lst2),

__list_filter__ -> (49685 : 
Input : (pred : (#983520 -> bool)) (lst : #983520 list) 
Output : #983464 list
Body : 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl)),

__list_mem__ -> (49683 : 
Input : elem (lst : #983496 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (49710 : 
Input : (e : lambda) 
Output : bool
Body : if (free_vars (e) = []) then true
 else false,

free_vars -> (49708 : 
Input : (__fun__ : lambda) 
Output : string list
Body : 
 (match __fun__ with 
|V v -> [v]
|P (v, e) -> __list_filter__ (
fun (x : string) -> (x != v)) (free_vars (e))
|C (e1, e2) -> 
let f_e1  : string list = free_vars (e1)
 in 

let f_e2  : string list = free_vars (e2)
 in 
__list_append__ (f_e1) (__list_filter__ (
fun (x : string) -> not (__list_mem__ (x) (f_e1))) (f_e2)))}
Edge : 
{(49683, 49683) -> ,
(49685, 49685) -> ,
(49708, 49683) -> ,
(49708, 49685) -> ,
(49708, 49686) -> ,
(49708, 49708) -> ,
(49710, 49708) -> }
Starting : 49710
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{__list_append__ -> __list_append__,
__list_mem__ -> __list_mem__,
check -> check,
varArea -> free_vars}
------Remainings in submission ------
{varStation}
------Remainings in solution ------
{__list_filter__}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60563 : ?)

Decls : 
,Exp : Modify (60564 : [?])

Decls : 
,Exp : Modify (60569 : ? (
fun (x : string) -> (? != ?)) (? (?)))

Decls : 

let rec __list_filter__ (pred : (#986472 -> bool)) (lst : #986472 list)  : #986416 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {varArea}
,Exp : Modify (60578 : 
let f_e1  : string list = ? (?)
 in 

let f_e2  : string list = ? (?)
 in 
? (?) (? (
fun (x : string) -> not (? (?) (?))) (?)))

Decls : 

let rec __list_filter__ (pred : (#986472 -> bool)) (lst : #986472 list)  : #986416 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {varArea}
,Exp : Modify (60602 : if (? (?) = []) then true
 else false)

Decls : 

let rec __list_filter__ (pred : (#986472 -> bool)) (lst : #986472 list)  : #986416 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {varArea}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60563 : ?)

Decls : 
,Exp : Modify (60564 : [?])

Decls : 
,Exp : Modify (60569 : ? (
fun (x : string) -> (? != ?)) (? (?)))

Decls : 

let rec __list_filter__ (pred : (#986472 -> bool)) (lst : #986472 list)  : #986416 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {varArea}
,Exp : Modify (60578 : 
let f_e1  : string list = ? (?)
 in 

let f_e2  : string list = ? (?)
 in 
? (?) (? (
fun (x : string) -> not (? (?) (?))) (?)))

Decls : 

let rec __list_filter__ (pred : (#986472 -> bool)) (lst : #986472 list)  : #986416 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {varArea}
,Exp : Modify (60602 : if (? (?) = []) then true
 else false)

Decls : 

let rec __list_filter__ (pred : (#986472 -> bool)) (lst : #986472 list)  : #986416 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {varArea}
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/12/sub19.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------
type partial =
|FIRSTHALF
|SECONDHALF

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check lambda  = 
 (match lambda with 
|V _ -> false
|P (a, V s) -> if (a = s) then true
 else false
|P (a, P (a2, C (m1, m2))) -> (((check (P ((a2, C ((m1, m2))))) || (check (P ((a, m1))) && check (P ((a2, m2))))) || (check (P ((a, m2))) && check (P ((a2, m1))))) || (check (P ((a, m1))) && check (P ((a, m2)))))
|P (a, P (a2, m)) -> ((check (m) || check (P ((a2, m)))) || check (P ((a, m))))
|P (a, C (m1, m2)) -> (check (P ((a, m1))) && check (P ((a, m2))))
|C (V _, _) -> false
|C (_, V _) -> false
|C (P (a1, m1), P (a2, m2)) -> (check (P ((a1, m1))) && check (P ((a2, m2))))
|C (C (m1, m2), C (m3, m4)) -> (((check (m1) && check (m2)) && check (m3)) && check (m4))
|C (C (m1, m2), P (a, m)) -> ((check (m1) && check (m2)) && check (P ((a, m))))
|C (P (a, m), C (m1, m2)) -> ((check (P ((a, m))) && check (m1)) && check (m2)))

-----------------------------
Submission
-----------------------------
type partial =
|SECONDHALF
|FIRSTHALF

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check lambda  = (60693, 
 (match (60546, lambda with 
|V _ -> (60547, false
|P (a, V s) -> (60553, if (60550, ((60548, a = (60549, s) then (60551, true
 else (60552, false
|P (a, P (a2, C (m1, m2))) -> (60604, ((60590, ((60576, ((60562, (60554, check ((60561, P ((60560, ((60555, a2, (60559, C ((60558, ((60556, m1, (60557, m2))))) || (60575, ((60568, (60563, check ((60567, P ((60566, ((60564, a, (60565, m1))) && (60574, (60569, check ((60573, P ((60572, ((60570, a2, (60571, m2))))) || (60589, ((60582, (60577, check ((60581, P ((60580, ((60578, a, (60579, m2))) && (60588, (60583, check ((60587, P ((60586, ((60584, a2, (60585, m1))))) || (60603, ((60596, (60591, check ((60595, P ((60594, ((60592, a, (60593, m1))) && (60602, (60597, check ((60601, P ((60600, ((60598, a, (60599, m2)))))
|P (a, P (a2, m)) -> (60621, ((60614, ((60607, (60605, check ((60606, m) || (60613, (60608, check ((60612, P ((60611, ((60609, a2, (60610, m)))) || (60620, (60615, check ((60619, P ((60618, ((60616, a, (60617, m))))
|P (a, C (m1, m2)) -> (60634, ((60627, (60622, check ((60626, P ((60625, ((60623, a, (60624, m1))) && (60633, (60628, check ((60632, P ((60631, ((60629, a, (60630, m2))))
|C (V _, _) -> (60635, false
|C (_, V _) -> (60636, false
|C (P (a1, m1), P (a2, m2)) -> (60649, ((60642, (60637, check ((60641, P ((60640, ((60638, a1, (60639, m1))) && (60648, (60643, check ((60647, P ((60646, ((60644, a2, (60645, m2))))
|C (C (m1, m2), C (m3, m4)) -> (60664, ((60660, ((60656, ((60652, (60650, check ((60651, m1) && (60655, (60653, check ((60654, m2)) && (60659, (60657, check ((60658, m3)) && (60663, (60661, check ((60662, m4))
|C (C (m1, m2), P (a, m)) -> (60678, ((60671, ((60667, (60665, check ((60666, m1) && (60670, (60668, check ((60669, m2)) && (60677, (60672, check ((60676, P ((60675, ((60673, a, (60674, m))))
|C (P (a, m), C (m1, m2)) -> (60692, ((60688, ((60684, (60679, check ((60683, P ((60682, ((60680, a, (60681, m))) && (60687, (60685, check ((60686, m1)) && (60691, (60689, check ((60690, m2)))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|V _ -> false
|P (a, V s) -> if (a = s) then true
 else false
|P (a, P (a2, C (m1, m2))) -> (((check (P ((a2, C ((m1, m2))))) || (check (P ((a, m1))) && check (P ((a2, m2))))) || (check (P ((a, m2))) && check (P ((a2, m1))))) || (check (P ((a, m1))) && check (P ((a, m2)))))
|P (a, P (a2, m)) -> ((check (m) || check (P ((a2, m)))) || check (P ((a, m))))
|P (a, C (m1, m2)) -> (check (P ((a, m1))) && check (P ((a, m2))))
|C (V _, _) -> false
|C (_, V _) -> false
|C (P (a1, m1), P (a2, m2)) -> (check (P ((a1, m1))) && check (P ((a2, m2))))
|C (C (m1, m2), C (m3, m4)) -> (((check (m1) && check (m2)) && check (m3)) && check (m4))
|C (C (m1, m2), P (a, m)) -> ((check (m1) && check (m2)) && check (P ((a, m))))
|C (P (a, m), C (m1, m2)) -> ((check (P ((a, m))) && check (m1)) && check (m2)))}
Edge : 
{(45777, 45777) -> }
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60693 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60693 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------
type partial =
|FIRSTHALF
|SECONDHALF

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check lambda  = checking (lambda) ([])

Time : 0.00179696083069
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/12/sub20.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------
type partial =
|FIRSTHALF
|SECONDHALF

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check lambda  = 
 (match lambda with 
|V _ -> false
|P (a, V s) -> if (a = s) then true
 else false
|P (a, P (a2, C (m1, m2))) -> (((check (P ((a2, C ((m1, m2))))) || (check (P ((a, m1))) && check (P ((a2, m2))))) || (check (P ((a, m2))) && check (P ((a2, m1))))) || (check (P ((a, m1))) && check (P ((a, m2)))))
|P (a, P (a2, m)) -> ((check (m) || check (P ((a2, m)))) || check (P ((a, m))))
|P (a, C (m1, m2)) -> (check (P ((a, m1))) && check (P ((a, m2))))
|C (V _, _) -> false
|C (_, V _) -> false
|C (P (a1, m1), P (a2, m2)) -> (check (P ((a1, m1))) && check (P ((a2, m2))))
|C (C (m1, m2), C (m3, m4)) -> (((check (m1) && check (m2)) && check (m3)) && check (m4))
|C (C (m1, m2), P (a, m)) -> ((check (m1) && check (m2)) && check (P ((a, m))))
|C (P (a, m), C (m1, m2)) -> ((check (P ((a, m))) && check (m1)) && check (m2)))

-----------------------------
Submission
-----------------------------
type partial =
|SECONDHALF
|FIRSTHALF

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check lambda  = (60693, 
 (match (60546, lambda with 
|V _ -> (60547, false
|P (a, V s) -> (60553, if (60550, ((60548, a = (60549, s) then (60551, true
 else (60552, false
|P (a, P (a2, C (m1, m2))) -> (60604, ((60590, ((60576, ((60562, (60554, check ((60561, P ((60560, ((60555, a2, (60559, C ((60558, ((60556, m1, (60557, m2))))) || (60575, ((60568, (60563, check ((60567, P ((60566, ((60564, a, (60565, m1))) && (60574, (60569, check ((60573, P ((60572, ((60570, a2, (60571, m2))))) || (60589, ((60582, (60577, check ((60581, P ((60580, ((60578, a, (60579, m2))) && (60588, (60583, check ((60587, P ((60586, ((60584, a2, (60585, m1))))) || (60603, ((60596, (60591, check ((60595, P ((60594, ((60592, a, (60593, m1))) && (60602, (60597, check ((60601, P ((60600, ((60598, a, (60599, m2)))))
|P (a, P (a2, m)) -> (60621, ((60614, ((60607, (60605, check ((60606, m) || (60613, (60608, check ((60612, P ((60611, ((60609, a2, (60610, m)))) || (60620, (60615, check ((60619, P ((60618, ((60616, a, (60617, m))))
|P (a, C (m1, m2)) -> (60634, ((60627, (60622, check ((60626, P ((60625, ((60623, a, (60624, m1))) && (60633, (60628, check ((60632, P ((60631, ((60629, a, (60630, m2))))
|C (V _, _) -> (60635, false
|C (_, V _) -> (60636, false
|C (P (a1, m1), P (a2, m2)) -> (60649, ((60642, (60637, check ((60641, P ((60640, ((60638, a1, (60639, m1))) && (60648, (60643, check ((60647, P ((60646, ((60644, a2, (60645, m2))))
|C (C (m1, m2), C (m3, m4)) -> (60664, ((60660, ((60656, ((60652, (60650, check ((60651, m1) && (60655, (60653, check ((60654, m2)) && (60659, (60657, check ((60658, m3)) && (60663, (60661, check ((60662, m4))
|C (C (m1, m2), P (a, m)) -> (60678, ((60671, ((60667, (60665, check ((60666, m1) && (60670, (60668, check ((60669, m2)) && (60677, (60672, check ((60676, P ((60675, ((60673, a, (60674, m))))
|C (P (a, m), C (m1, m2)) -> (60692, ((60688, ((60684, (60679, check ((60683, P ((60682, ((60680, a, (60681, m))) && (60687, (60685, check ((60686, m1)) && (60691, (60689, check ((60690, m2)))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|V _ -> false
|P (a, V s) -> if (a = s) then true
 else false
|P (a, P (a2, C (m1, m2))) -> (((check (P ((a2, C ((m1, m2))))) || (check (P ((a, m1))) && check (P ((a2, m2))))) || (check (P ((a, m2))) && check (P ((a2, m1))))) || (check (P ((a, m1))) && check (P ((a, m2)))))
|P (a, P (a2, m)) -> ((check (m) || check (P ((a2, m)))) || check (P ((a, m))))
|P (a, C (m1, m2)) -> (check (P ((a, m1))) && check (P ((a, m2))))
|C (V _, _) -> false
|C (_, V _) -> false
|C (P (a1, m1), P (a2, m2)) -> (check (P ((a1, m1))) && check (P ((a2, m2))))
|C (C (m1, m2), C (m3, m4)) -> (((check (m1) && check (m2)) && check (m3)) && check (m4))
|C (C (m1, m2), P (a, m)) -> ((check (m1) && check (m2)) && check (P ((a, m))))
|C (P (a, m), C (m1, m2)) -> ((check (P ((a, m))) && check (m1)) && check (m2)))}
Edge : 
{(45777, 45777) -> }
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60693 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60693 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------
type partial =
|FIRSTHALF
|SECONDHALF

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check lambda  = checking (lambda) ([])

Time : 0.00180101394653

Error occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/12/sub31.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases

Error occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/12/sub43.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases

../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/12/sub48.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checklist (arlist, stlist)  = 
let rec checkst (arlst, st)  = 
 (match (arlst, st) with 
|([], _) -> false
|(a::b, c) -> if (a = c) then true
 else checkst ((b, c)))
 in 

 (match (arlist, stlist) with 
|(_, []) -> true
|(a, b::c) -> if checkst ((a, b)) then checklist ((a, c))
 else false)

let rec check (met : lambda)  = 
let rec makestlist (me : lambda)  = 
 (match me with 
|V a -> (a :: [])
|P (a, b) -> makestlist (b)
|C (a, b) -> (makestlist (a) @ makestlist (b)))
 in 

let rec makearlist (me : lambda)  = 
 (match me with 
|P (a, b) -> (a :: makearlist (b))
|C (a, b) -> 
 (match (a, b) with 
|(V c, V d) -> []
|(V c, P (d, e)) -> (d :: makearlist (e))
|(V c, C _) -> makearlist (b)
|(P (c, d), V e) -> (c :: makearlist (d))
|(P (c, d), P (e, f)) -> ((c :: (e :: makearlist (d))) @ makearlist (f))
|(P (c, d), C _) -> ((c :: makearlist (d)) @ makearlist (b))
|(C _, V c) -> makearlist (a)
|(C _, P (c, d)) -> (makearlist (a) @ (c :: makearlist (d)))
|(C _, C _) -> (makearlist (a) @ makearlist (b)))
|_ -> [])
 in 

 (match met with 
|P (a, b) -> checklist (((a :: makearlist (b)), makestlist (b)))
|C (a, b) -> (check (a) && check (b))
|_ -> false)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec checklist (arlist, stlist)  = (60578, 
let rec checkst (arlst, st)  = (60560, 
 (match (60548, ((60546, arlst, (60547, st) with 
|([], _) -> (60549, false
|(a::b, c) -> (60559, if (60552, ((60550, a = (60551, c) then (60553, true
 else (60558, (60554, checkst ((60557, ((60555, b, (60556, c)))
 in 
(60577, 
 (match (60563, ((60561, arlist, (60562, stlist) with 
|(_, []) -> (60564, true
|(a, b::c) -> (60576, if (60569, (60565, checkst ((60568, ((60566, a, (60567, b)) then (60574, (60570, checklist ((60573, ((60571, a, (60572, c))
 else (60575, false)

let rec check (met : lambda)  = (60681, 
let rec makestlist (me : lambda)  = (60593, 
 (match (60579, me with 
|V a -> (60582, ((60580, a :: (60581, [])
|P (a, b) -> (60585, (60583, makestlist ((60584, b)
|C (a, b) -> (60592, ((60588, (60586, makestlist ((60587, a) @ (60591, (60589, makestlist ((60590, b)))
 in 
(60680, 
let rec makearlist (me : lambda)  = (60658, 
 (match (60594, me with 
|P (a, b) -> (60599, ((60595, a :: (60598, (60596, makearlist ((60597, b))
|C (a, b) -> (60656, 
 (match (60602, ((60600, a, (60601, b) with 
|(V c, V d) -> (60603, []
|(V c, P (d, e)) -> (60608, ((60604, d :: (60607, (60605, makearlist ((60606, e))
|(V c, C _) -> (60611, (60609, makearlist ((60610, b)
|(P (c, d), V e) -> (60616, ((60612, c :: (60615, (60613, makearlist ((60614, d))
|(P (c, d), P (e, f)) -> (60627, ((60623, ((60617, c :: (60622, ((60618, e :: (60621, (60619, makearlist ((60620, d))) @ (60626, (60624, makearlist ((60625, f))
|(P (c, d), C _) -> (60636, ((60632, ((60628, c :: (60631, (60629, makearlist ((60630, d)) @ (60635, (60633, makearlist ((60634, b))
|(C _, V c) -> (60639, (60637, makearlist ((60638, a)
|(C _, P (c, d)) -> (60648, ((60642, (60640, makearlist ((60641, a) @ (60647, ((60643, c :: (60646, (60644, makearlist ((60645, d)))
|(C _, C _) -> (60655, ((60651, (60649, makearlist ((60650, a) @ (60654, (60652, makearlist ((60653, b)))
|_ -> (60657, [])
 in 
(60679, 
 (match (60659, met with 
|P (a, b) -> (60670, (60660, checklist ((60669, ((60665, ((60661, a :: (60664, (60662, makearlist ((60663, b)), (60668, (60666, makestlist ((60667, b)))
|C (a, b) -> (60677, ((60673, (60671, check ((60672, a) && (60676, (60674, check ((60675, b))
|_ -> (60678, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/15/sub60.ml Score : 1
-----------------------------
type var = string
type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)

let rec contains  = 
fun (l, item) -> 
 (match l with 
|[] -> false
|h::tail -> if (item = h) then true
 else contains ((tail, item)))

let rec lambda  = 
fun (l, m) -> 
 (match m with 
|V n -> contains ((l, n))
|P (id, area) -> lambda (((id :: l), area))
|C (m1, m2) -> (lambda ((l, m1)) && lambda ((l, m2))))

let check  = 
fun m -> lambda (([], m))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (51069 : 
Input : (met : lambda) 
Output : bool
Body : 
 (match met with 
|P (a, b) -> checklist (((a :: makearlist (b)), makestlist (b)))
|C (a, b) -> (check (a) && check (b))
|_ -> false),

checklist -> (51067 : 
Input : ((arlist : #1137999 list), (stlist : #1137999 list)) 
Output : bool
Body : 
 (match (arlist, stlist) with 
|(_, []) -> true
|(a, b::c) -> if checkst ((a, b)) then checklist ((a, c))
 else false),

checkst -> (51068 : 
Input : ((arlst : #1137999 list), st) 
Output : bool
Body : 
 (match (arlst, st) with 
|([], _) -> false
|(a::b, c) -> if (a = c) then true
 else checkst ((b, c))),

makearlist -> (51071 : 
Input : (me : lambda) 
Output : string list
Body : 
 (match me with 
|P (a, b) -> (a :: makearlist (b))
|C (a, b) -> 
 (match (a, b) with 
|(V c, V d) -> []
|(V c, P (d, e)) -> (d :: makearlist (e))
|(V c, C _) -> makearlist (b)
|(P (c, d), V e) -> (c :: makearlist (d))
|(P (c, d), P (e, f)) -> ((c :: (e :: makearlist (d))) @ makearlist (f))
|(P (c, d), C _) -> ((c :: makearlist (d)) @ makearlist (b))
|(C _, V c) -> makearlist (a)
|(C _, P (c, d)) -> (makearlist (a) @ (c :: makearlist (d)))
|(C _, C _) -> (makearlist (a) @ makearlist (b)))
|_ -> []),

makestlist -> (51070 : 
Input : (me : lambda) 
Output : string list
Body : 
 (match me with 
|V a -> (a :: [])
|P (a, b) -> makestlist (b)
|C (a, b) -> (makestlist (a) @ makestlist (b)))}
Edge : 
{(51067, 51067) -> ,
(51067, 51068) -> ,
(51068, 51068) -> ,
(51069, 51067) -> ,
(51069, 51069) -> ,
(51069, 51070) -> ,
(51069, 51071) -> ,
(51070, 51070) -> ,
(51071, 51071) -> }
Starting : 51069
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (51032 : 
Input : (m : lambda) 
Output : bool
Body : lambda (([], m)),

contains -> (51030 : 
Input : ((l : #1137248 list), item) 
Output : bool
Body : 
 (match l with 
|[] -> false
|h::tail -> if (item = h) then true
 else contains ((tail, item))),

lambda -> (51031 : 
Input : ((l : string list), (m : lambda)) 
Output : bool
Body : 
 (match m with 
|V n -> contains ((l, n))
|P (id, area) -> lambda (((id :: l), area))
|C (m1, m2) -> (lambda ((l, m1)) && lambda ((l, m2))))}
Edge : 
{(51030, 51030) -> ,
(51031, 51030) -> ,
(51031, 51031) -> ,
(51032, 51031) -> }
Starting : 51032
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
checklist -> contains,
checkst -> lambda}
------Remainings in submission ------
{makearlist,makestlist}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60548 : ?)

Decls : 
,Exp : Modify (60563 : ?)

Decls : 
,Exp : Modify (60679 : ? (([], ?)))

Decls : 
,Exp : Insert (C (m1, m2) -> (? ((?, ?)) && ? ((?, ?))) At label 60560

Decls : 
,Exp : Insert (P (id, area) -> ? (((? :: ?), ?)) At label 60560

Decls : 
,Exp : Insert (V n -> ? ((?, ?)) At label 60560

Decls : 
,Exp : Insert ([] -> false At label 60577

Decls : 
,Exp : Insert (h::tail -> if (? = ?) then true
 else ? ((?, ?)) At label 60577

Decls : 
,Exp : Delete (([], _) -> false At label 60560

Decls : 
,Exp : Delete ((a::b, c) -> if (a = c) then true
 else checkst ((b, c)) At label 60560

Decls : 
,Exp : Delete ((_, []) -> true At label 60577

Decls : 
,Exp : Delete ((a, b::c) -> if checkst ((a, b)) then checklist ((a, c))
 else false At label 60577

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60548 : ?)

Decls : 
,Exp : Modify (60563 : ?)

Decls : 
,Exp : Modify (60679 : ? (([], ?)))

Decls : 
,Exp : Insert (C (m1, m2) -> (? ((?, ?)) && ? ((?, ?))) At label 60560

Decls : 
,Exp : Insert (P (id, area) -> ? (((? :: ?), ?)) At label 60560

Decls : 
,Exp : Insert (V n -> ? ((?, ?)) At label 60560

Decls : 
,Exp : Insert ([] -> false At label 60577

Decls : 
,Exp : Insert (h::tail -> if (? = ?) then true
 else ? ((?, ?)) At label 60577

Decls : 
,Exp : Delete (([], _) -> false At label 60560

Decls : 
,Exp : Delete ((a::b, c) -> if (a = c) then true
 else checkst ((b, c)) At label 60560

Decls : 
,Exp : Delete ((_, []) -> true At label 60577

Decls : 
,Exp : Delete ((a, b::c) -> if checkst ((a, b)) then checklist ((a, c))
 else false At label 60577

Decls : 
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/12/sub8.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check mat  = 
let rec checkStringInList (li, st)  = 
 (match li with 
|[] -> false
|a::remain -> if (st = a) then true
 else checkStringInList ((remain, st)))
 in 

let rec checkStationInArea (listOfArea, subMat)  = 
 (match subMat with 
|V s -> checkStringInList ((listOfArea, s))
|C (m1, m2) -> (checkStationInArea ((listOfArea, m1)) && checkStationInArea ((listOfArea, m2)))
|P (a, m) -> 
let newlist  = (a :: listOfArea)
 in 
checkStationInArea ((newlist, m)))
 in 

 (match mat with 
|V s -> false
|C (m1, m2) -> false
|P (a, m) -> checkStationInArea (([a], m)))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check mat  = (60597, 
let rec checkStringInList (li, st)  = (60558, 
 (match (60546, li with 
|[] -> (60547, false
|a::remain -> (60557, if (60550, ((60548, st = (60549, a) then (60551, true
 else (60556, (60552, checkStringInList ((60555, ((60553, remain, (60554, st)))
 in 
(60596, 
let rec checkStationInArea (listOfArea, subMat)  = (60585, 
 (match (60559, subMat with 
|V s -> (60564, (60560, checkStringInList ((60563, ((60561, listOfArea, (60562, s))
|C (m1, m2) -> (60575, ((60569, (60565, checkStationInArea ((60568, ((60566, listOfArea, (60567, m1)) && (60574, (60570, checkStationInArea ((60573, ((60571, listOfArea, (60572, m2)))
|P (a, m) -> (60584, 
let newlist  = (60578, ((60576, a :: (60577, listOfArea)
 in 
(60583, (60579, checkStationInArea ((60582, ((60580, newlist, (60581, m)))
 in 
(60595, 
 (match (60586, mat with 
|V s -> (60587, false
|C (m1, m2) -> (60588, false
|P (a, m) -> (60594, (60589, checkStationInArea ((60593, ((60591, [(60590, a], (60592, m)))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/17/sub117.ml Score : 3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun lambda -> 
let rec checkArea  : ((string list * lambda) -> bool) = 
fun (nl, m) -> 
 (match m with 
|V s -> 
let rec isExist  : ((string list * string) -> bool) = 
fun (str_list, str) -> 
 (match str_list with 
|[] -> false
|e::e_list -> if (e = str) then true
 else isExist ((e_list, str)))
 in 
isExist ((nl, s))
|P (a, b) -> checkArea (((a :: nl), b))
|C (a, b) -> (checkArea ((nl, a)) && checkArea ((nl, b))))
 in 

 (match lambda with 
|V n -> false
|P (n, m) -> checkArea (([n], m))
|C (m1, m2) -> (check (m1) && check (m2)))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (48423 : 
Input : (mat : lambda) 
Output : bool
Body : 
 (match mat with 
|V s -> false
|C (m1, m2) -> false
|P (a, m) -> checkStationInArea (([a], m))),

checkStationInArea -> (48425 : 
Input : ((listOfArea : string list), (subMat : lambda)) 
Output : bool
Body : 
 (match subMat with 
|V s -> checkStringInList ((listOfArea, s))
|C (m1, m2) -> (checkStationInArea ((listOfArea, m1)) && checkStationInArea ((listOfArea, m2)))
|P (a, m) -> 
let newlist  : string list = (a :: listOfArea)
 in 
checkStationInArea ((newlist, m))),

checkStringInList -> (48424 : 
Input : ((li : string list), (st : string)) 
Output : bool
Body : 
 (match li with 
|[] -> false
|a::remain -> if (st = a) then true
 else checkStringInList ((remain, st)))}
Edge : 
{(48423, 48425) -> ,
(48424, 48424) -> ,
(48425, 48424) -> ,
(48425, 48425) -> }
Starting : 48423
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (48386 : 
Input : (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|V n -> false
|P (n, m) -> checkArea (([n], m))
|C (m1, m2) -> (check (m1) && check (m2))),

checkArea -> (48387 : 
Input : ((nl : string list), (m : lambda)) 
Output : bool
Body : 
 (match m with 
|V s -> isExist ((nl, s))
|P (a, b) -> checkArea (((a :: nl), b))
|C (a, b) -> (checkArea ((nl, a)) && checkArea ((nl, b)))),

isExist -> (48388 : 
Input : ((str_list : string list), (str : string)) 
Output : bool
Body : 
 (match str_list with 
|[] -> false
|e::e_list -> if (e = str) then true
 else isExist ((e_list, str)))}
Edge : 
{(48386, 48386) -> ,
(48386, 48387) -> ,
(48387, 48387) -> ,
(48387, 48388) -> ,
(48388, 48388) -> }
Starting : 48386
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
checkStationInArea -> checkArea,
checkStringInList -> isExist}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60548 : ?)

Decls : 
,Exp : Modify (60549 : ?)

Decls : 
,Exp : Modify (60556 : ? ((?, ?)))

Decls : 
,Exp : Modify (60559 : ?)

Decls : 
,Exp : Modify (60564 : ? ((?, ?)))

Decls : 
,Exp : Modify (60569 : ? ((?, ?)))

Decls : 
,Exp : Modify (60574 : ? ((?, ?)))

Decls : 
,Exp : Modify (60584 : ? (((? :: ?), ?)))

Decls : 
,Exp : Modify (60586 : ?)

Decls : 
,Exp : Modify (60588 : (? (?) && ? (?)))

Decls : 
,Exp : Modify (60594 : ? (([?], ?)))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60586 : ?)

Decls : 
,Exp : Modify (60588 : (? (?) && ? (?)))

Decls : 
}
Fail to Repair

Error occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/13/sub10.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases

Error occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/13/sub2.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases

../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/13/sub29.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------
type var = string
type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)

let rec apl (b, m)  = 
 (match (b, m) with 
|(b, V a) -> if (b = a) then P ((b, V (a)))
 else V (a)
|(b, P (a, V c)) -> if ((a != c) && (b = c)) then P ((b, V (c)))
 else P ((a, V (c)))
|(b, P (a, P (c, d))) -> P ((a, P ((c, apl ((b, d))))))
|(b, P (a, C (c, d))) -> P ((a, apl ((b, C ((c, d))))))
|(b, C (a, c)) -> C ((apl ((b, a)), apl ((b, c)))))

let rec check m  = 
 (match m with 
|P (a, V b) -> if (a = b) then true
 else false
|P (a, C (b, c)) -> (check (P ((a, b))) && check (P ((a, c))))
|P (a, P (b, V c)) -> (check (P ((a, V (c)))) || check (P ((b, V (c)))))
|P (a, P (b, c)) -> (check (apl ((b, P ((a, c))))) || check (apl ((a, P ((b, c))))))
|_ -> false)

-----------------------------
Submission
-----------------------------
type var = string
type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var

let rec apl (b, m)  = (60612, 
 (match (60548, ((60546, b, (60547, m) with 
|(b, V a) -> (60559, if (60551, ((60549, b = (60550, a) then (60556, P ((60555, ((60552, b, (60554, V ((60553, a)))
 else (60558, V ((60557, a)
|(b, P (a, V c)) -> (60577, if (60566, ((60562, ((60560, a != (60561, c) && (60565, ((60563, b = (60564, c)) then (60571, P ((60570, ((60567, b, (60569, V ((60568, c)))
 else (60576, P ((60575, ((60572, a, (60574, V ((60573, c)))
|(b, P (a, P (c, d))) -> (60588, P ((60587, ((60578, a, (60586, P ((60585, ((60579, c, (60584, (60580, apl ((60583, ((60581, b, (60582, d))))))
|(b, P (a, C (c, d))) -> (60599, P ((60598, ((60589, a, (60597, (60590, apl ((60596, ((60591, b, (60595, C ((60594, ((60592, c, (60593, d))))))
|(b, C (a, c)) -> (60611, C ((60610, ((60604, (60600, apl ((60603, ((60601, b, (60602, a)), (60609, (60605, apl ((60608, ((60606, b, (60607, c)))))

let rec check m  = (60670, 
 (match (60613, m with 
|P (a, V b) -> (60619, if (60616, ((60614, a = (60615, b) then (60617, true
 else (60618, false
|P (a, C (b, c)) -> (60632, ((60625, (60620, check ((60624, P ((60623, ((60621, a, (60622, b))) && (60631, (60626, check ((60630, P ((60629, ((60627, a, (60628, c))))
|P (a, P (b, V c)) -> (60647, ((60639, (60633, check ((60638, P ((60637, ((60634, a, (60636, V ((60635, c)))) || (60646, (60640, check ((60645, P ((60644, ((60641, b, (60643, V ((60642, c)))))
|P (a, P (b, c)) -> (60668, ((60657, (60648, check ((60656, (60649, apl ((60655, ((60650, b, (60654, P ((60653, ((60651, a, (60652, c))))) || (60667, (60658, check ((60666, (60659, apl ((60665, ((60660, a, (60664, P ((60663, ((60661, b, (60662, c))))))
|_ -> (60669, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : -1
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{apl -> (47099 : 
Input : ((b : string), (m : lambda)) 
Output : lambda
Body : 
 (match (b, m) with 
|(b, V a) -> if (b = a) then P ((b, V (a)))
 else V (a)
|(b, P (a, V c)) -> if ((a != c) && (b = c)) then P ((b, V (c)))
 else P ((a, V (c)))
|(b, P (a, P (c, d))) -> P ((a, P ((c, apl ((b, d))))))
|(b, P (a, C (c, d))) -> P ((a, apl ((b, C ((c, d))))))
|(b, C (a, c)) -> C ((apl ((b, a)), apl ((b, c))))),

check -> (47100 : 
Input : (m : lambda) 
Output : bool
Body : 
 (match m with 
|P (a, V b) -> if (a = b) then true
 else false
|P (a, C (b, c)) -> (check (P ((a, b))) && check (P ((a, c))))
|P (a, P (b, V c)) -> (check (P ((a, V (c)))) || check (P ((b, V (c)))))
|P (a, P (b, c)) -> (check (apl ((b, P ((a, c))))) || check (apl ((a, P ((b, c))))))
|_ -> false)}
Edge : 
{(47099, 47099) -> ,
(47100, 47099) -> ,
(47100, 47100) -> }
Starting : 47100
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (47065 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (47064 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(47064, 47064) -> ,
(47065, 47064) -> }
Starting : 47065
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{apl}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60670 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60670 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------
type var = string
type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)

let rec apl (b, m)  = 
 (match (b, m) with 
|(b, V a) -> if (b = a) then P ((b, V (a)))
 else V (a)
|(b, P (a, V c)) -> if ((a != c) && (b = c)) then P ((b, V (c)))
 else P ((a, V (c)))
|(b, P (a, P (c, d))) -> P ((a, P ((c, apl ((b, d))))))
|(b, P (a, C (c, d))) -> P ((a, apl ((b, C ((c, d))))))
|(b, C (a, c)) -> C ((apl ((b, a)), apl ((b, c)))))

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check m  = checking (m) ([])

Time : 0.0022668838501
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/13/sub30.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------
type var = string
type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)

let rec apl (b, m)  = 
 (match (b, m) with 
|(b, V a) -> if (b = a) then P ((b, V (a)))
 else V (a)
|(b, P (a, V c)) -> if ((a != c) && (b = c)) then P ((b, V (c)))
 else P ((a, V (c)))
|(b, P (a, P (c, d))) -> P ((a, P ((c, apl ((b, d))))))
|(b, P (a, C (c, d))) -> P ((a, apl ((b, C ((c, d))))))
|(b, C (a, c)) -> C ((apl ((b, a)), apl ((b, c)))))

let rec check m  = 
 (match m with 
|P (a, V b) -> if (a = b) then true
 else false
|P (a, C (b, c)) -> (check (P ((a, b))) && check (P ((a, c))))
|P (a, P (b, V c)) -> (check (P ((a, V (c)))) || check (P ((b, V (c)))))
|P (a, P (b, c)) -> (check (apl ((b, P ((a, c))))) || check (apl ((a, P ((b, c))))))
|C (a, b) -> (check (a) && check (b))
|_ -> false)

-----------------------------
Submission
-----------------------------
type var = string
type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var

let rec apl (b, m)  = (60612, 
 (match (60548, ((60546, b, (60547, m) with 
|(b, V a) -> (60559, if (60551, ((60549, b = (60550, a) then (60556, P ((60555, ((60552, b, (60554, V ((60553, a)))
 else (60558, V ((60557, a)
|(b, P (a, V c)) -> (60577, if (60566, ((60562, ((60560, a != (60561, c) && (60565, ((60563, b = (60564, c)) then (60571, P ((60570, ((60567, b, (60569, V ((60568, c)))
 else (60576, P ((60575, ((60572, a, (60574, V ((60573, c)))
|(b, P (a, P (c, d))) -> (60588, P ((60587, ((60578, a, (60586, P ((60585, ((60579, c, (60584, (60580, apl ((60583, ((60581, b, (60582, d))))))
|(b, P (a, C (c, d))) -> (60599, P ((60598, ((60589, a, (60597, (60590, apl ((60596, ((60591, b, (60595, C ((60594, ((60592, c, (60593, d))))))
|(b, C (a, c)) -> (60611, C ((60610, ((60604, (60600, apl ((60603, ((60601, b, (60602, a)), (60609, (60605, apl ((60608, ((60606, b, (60607, c)))))

let rec check m  = (60677, 
 (match (60613, m with 
|P (a, V b) -> (60619, if (60616, ((60614, a = (60615, b) then (60617, true
 else (60618, false
|P (a, C (b, c)) -> (60632, ((60625, (60620, check ((60624, P ((60623, ((60621, a, (60622, b))) && (60631, (60626, check ((60630, P ((60629, ((60627, a, (60628, c))))
|P (a, P (b, V c)) -> (60647, ((60639, (60633, check ((60638, P ((60637, ((60634, a, (60636, V ((60635, c)))) || (60646, (60640, check ((60645, P ((60644, ((60641, b, (60643, V ((60642, c)))))
|P (a, P (b, c)) -> (60668, ((60657, (60648, check ((60656, (60649, apl ((60655, ((60650, b, (60654, P ((60653, ((60651, a, (60652, c))))) || (60667, (60658, check ((60666, (60659, apl ((60665, ((60660, a, (60664, P ((60663, ((60661, b, (60662, c))))))
|C (a, b) -> (60675, ((60671, (60669, check ((60670, a) && (60674, (60672, check ((60673, b))
|_ -> (60676, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : -1
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{apl -> (47099 : 
Input : ((b : string), (m : lambda)) 
Output : lambda
Body : 
 (match (b, m) with 
|(b, V a) -> if (b = a) then P ((b, V (a)))
 else V (a)
|(b, P (a, V c)) -> if ((a != c) && (b = c)) then P ((b, V (c)))
 else P ((a, V (c)))
|(b, P (a, P (c, d))) -> P ((a, P ((c, apl ((b, d))))))
|(b, P (a, C (c, d))) -> P ((a, apl ((b, C ((c, d))))))
|(b, C (a, c)) -> C ((apl ((b, a)), apl ((b, c))))),

check -> (47100 : 
Input : (m : lambda) 
Output : bool
Body : 
 (match m with 
|P (a, V b) -> if (a = b) then true
 else false
|P (a, C (b, c)) -> (check (P ((a, b))) && check (P ((a, c))))
|P (a, P (b, V c)) -> (check (P ((a, V (c)))) || check (P ((b, V (c)))))
|P (a, P (b, c)) -> (check (apl ((b, P ((a, c))))) || check (apl ((a, P ((b, c))))))
|C (a, b) -> (check (a) && check (b))
|_ -> false)}
Edge : 
{(47099, 47099) -> ,
(47100, 47099) -> ,
(47100, 47100) -> }
Starting : 47100
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (47065 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (47064 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(47064, 47064) -> ,
(47065, 47064) -> }
Starting : 47065
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{apl}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60677 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60677 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------
type var = string
type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)

let rec apl (b, m)  = 
 (match (b, m) with 
|(b, V a) -> if (b = a) then P ((b, V (a)))
 else V (a)
|(b, P (a, V c)) -> if ((a != c) && (b = c)) then P ((b, V (c)))
 else P ((a, V (c)))
|(b, P (a, P (c, d))) -> P ((a, P ((c, apl ((b, d))))))
|(b, P (a, C (c, d))) -> P ((a, apl ((b, C ((c, d))))))
|(b, C (a, c)) -> C ((apl ((b, a)), apl ((b, c)))))

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check m  = checking (m) ([])

Time : 0.00229096412659
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/13/sub47.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checkArea n e  = 
 (match e with 
|P (a, b) -> checkArea ((n @ [a])) (b)
|C (a, b) -> (checkArea (n) (a) && checkArea (n) (b))
|V a -> __list_exists__ (
fun x -> (x = a)) (n))

let rec check e  = 
 (match e with 
|P (a, b) -> checkArea ([a]) (b)
|C (a, b) -> (check (a) && check (b))
|V n -> true)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec checkArea n e  = (60574, 
 (match (60546, e with 
|P (a, b) -> (60554, (60553, (60547, checkArea ((60551, ((60548, n @ (60550, [(60549, a])) ((60552, b)
|C (a, b) -> (60565, ((60559, (60558, (60555, checkArea ((60556, n) ((60557, a) && (60564, (60563, (60560, checkArea ((60561, n) ((60562, b))
|V a -> (60573, (60572, (60566, __list_exists__ ((60570, 
fun x -> (60569, ((60567, x = (60568, a)) ((60571, n))

let rec check e  = (60590, 
 (match (60575, e with 
|P (a, b) -> (60581, (60580, (60576, checkArea ((60578, [(60577, a]) ((60579, b)
|C (a, b) -> (60588, ((60584, (60582, check ((60583, a) && (60587, (60585, check ((60586, b))
|V n -> (60589, true)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub55.ml Score : 3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checklambda  : (var list -> (lambda -> bool)) = 
fun lst lam -> 
 (match lam with 
|V x -> __list_mem__ (x) (lst)
|P (x, l) -> checklambda ((x :: lst)) (l)
|C (l1, l2) -> (checklambda (lst) (l1) && checklambda (lst) (l2)))

let check  : (lambda -> bool) = 
fun lam -> checklambda ([]) (lam)

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{__list_exists__ -> (47075 : 
Input : (pred : (#970986 -> bool)) (lst : #970986 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> (pred (hd) || __list_exists__ (pred) (tl))),

check -> (47100 : 
Input : (e : lambda) 
Output : bool
Body : 
 (match e with 
|P (a, b) -> checkArea ([a]) (b)
|C (a, b) -> (check (a) && check (b))
|V n -> true),

checkArea -> (47099 : 
Input : (n : string list) (e : lambda) 
Output : bool
Body : 
 (match e with 
|P (a, b) -> checkArea ((n @ [a])) (b)
|C (a, b) -> (checkArea (n) (a) && checkArea (n) (b))
|V a -> __list_exists__ (
fun (x : string) -> (x = a)) (n))}
Edge : 
{(47075, 47075) -> ,
(47099, 47075) -> ,
(47099, 47099) -> ,
(47100, 47099) -> ,
(47100, 47100) -> }
Starting : 47100
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{__list_mem__ -> (47039 : 
Input : elem (lst : #970273 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (47065 : 
Input : (lam : lambda) 
Output : bool
Body : checklambda ([]) (lam),

checklambda -> (47064 : 
Input : (lst : string list) (lam : lambda) 
Output : bool
Body : 
 (match lam with 
|V x -> __list_mem__ (x) (lst)
|P (x, l) -> checklambda ((x :: lst)) (l)
|C (l1, l2) -> (checklambda (lst) (l1) && checklambda (lst) (l2)))}
Edge : 
{(47039, 47039) -> ,
(47064, 47039) -> ,
(47064, 47064) -> ,
(47065, 47064) -> }
Starting : 47065
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{__list_exists__ -> __list_mem__,
check -> check,
checkArea -> checklambda}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60554 : ? ((? :: ?)) (?))

Decls : 
,Exp : Modify (60559 : ? (?) (?))

Decls : 
,Exp : Modify (60564 : ? (?) (?))

Decls : 
,Exp : Modify (60573 : ? (?) (?))

Decls : 
,Exp : Modify (60590 : ? ([]) (?))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60590 : ? ([]) (?))

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checkArea n e  = 
 (match e with 
|P (a, b) -> checkArea ((n @ [a])) (b)
|C (a, b) -> (checkArea (n) (a) && checkArea (n) (b))
|V a -> __list_exists__ (
fun x -> (x = a)) (n))

let rec check e  = checkArea ([]) (e)

Time : 0.00179219245911
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/13/sub54.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check (m, l)  = 
 (match m with 
|P (nam, met) -> check ((met, (nam :: l)))
|V nam -> 
let x  = __list_find__ (
fun elem -> (elem = nam)) (l)
 in 
true
|C (met1, met2) -> (check ((met1, l)) && check ((met2, l))))

let check m  = check ((m, []))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check (m, l)  = (60575, 
 (match (60546, m with 
|P (nam, met) -> (60553, (60547, check ((60552, ((60548, met, (60551, ((60549, nam :: (60550, l)))
|V nam -> (60563, 
let x  = (60561, (60560, (60554, __list_find__ ((60558, 
fun elem -> (60557, ((60555, elem = (60556, nam)) ((60559, l)
 in 
(60562, true
|C (met1, met2) -> (60574, ((60568, (60564, check ((60567, ((60565, met1, (60566, l)) && (60573, (60569, check ((60572, ((60570, met2, (60571, l))))

let check m  = (60580, (60576, check ((60579, ((60577, m, (60578, []))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_15/sub24.ml Score : 2
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check  : (lambda -> bool) = 
fun e -> 
let rec check x y  = 
 (match x with 
|V x1 -> __list_mem__ (x1) (y)
|C (x1, y1) -> (check (x1) (y) && check (y1) (y))
|P (x1, y1) -> check (y1) ((x1 :: y)))
 in 
check (e) ([])

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{__list_find__ -> (47092 : 
Input : (pred : (#959254 -> bool)) (lst : #959254 list) 
Output : #959047
Body : 
 (match lst with 
|[] -> raise ListError
|hd::tl -> if pred (hd) then hd
 else __list_find__ (pred) (tl)),

check -> (47100 : 
Input : (m : lambda) 
Output : bool
Body : check ((m, []))}
Edge : 
{(47092, 47092) -> ,
(47099, 47092) -> ,
(47099, 47099) -> ,
(47100, 47099) -> }
Starting : 47100
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{__list_mem__ -> (47039 : 
Input : elem (lst : #958376 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (47064 : 
Input : (e : lambda) 
Output : bool
Body : check (e) ([])}
Edge : 
{(47039, 47039) -> ,
(47064, 47065) -> ,
(47065, 47039) -> ,
(47065, 47065) -> }
Starting : 47064
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{__list_find__ -> __list_mem__,
check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60580 : ? (?) ([]))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60580 : ? (?) ([]))

Decls : 
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/13/sub55.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking mtr arealst  = 
 (match mtr with 
|V n -> if (__list_mem__ (n) (arealst) = true) then true
 else false
|C (m, n) -> (checking (m) (arealst) && checking (n) (arealst))
|P (n, m) -> checking (m) ((n :: arealst)))

let check mtr  = 
 (match mtr with 
|V n -> false
|C (m, n) -> false
|P (n, m) -> checking (mtr) ([]))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec checking mtr arealst  = (60575, 
 (match (60546, mtr with 
|V n -> (60556, if (60553, ((60551, (60550, (60547, __list_mem__ ((60548, n) ((60549, arealst) = (60552, true) then (60554, true
 else (60555, false
|C (m, n) -> (60567, ((60561, (60560, (60557, checking ((60558, m) ((60559, arealst) && (60566, (60565, (60562, checking ((60563, n) ((60564, arealst))
|P (n, m) -> (60574, (60573, (60568, checking ((60569, m) ((60572, ((60570, n :: (60571, arealst)))

let check mtr  = (60584, 
 (match (60576, mtr with 
|V n -> (60577, false
|C (m, n) -> (60578, false
|P (n, m) -> (60583, (60582, (60579, checking ((60580, mtr) ((60581, []))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub6.ml Score : 3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec find_stack  = 
fun v stack -> 
 (match stack with 
|hd::tl -> if (hd = v) then true
 else find_stack (v) (tl)
|[] -> false)

let rec check_inner  = 
fun lam stack -> 
 (match lam with 
|V v -> if find_stack (v) (stack) then true
 else false
|P (v, l) -> check_inner (l) ((v :: stack))
|C (l1, l2) -> (check_inner (l1) (stack) && check_inner (l2) (stack)))

let check  : (lambda -> bool) = 
fun lam -> check_inner (lam) ([])

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{__list_mem__ -> (47076 : 
Input : elem (lst : #965703 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (47102 : 
Input : (mtr : lambda) 
Output : bool
Body : 
 (match mtr with 
|V n -> false
|C (m, n) -> false
|P (n, m) -> checking (mtr) ([])),

checking -> (47101 : 
Input : (mtr : lambda) (arealst : string list) 
Output : bool
Body : 
 (match mtr with 
|V n -> if (__list_mem__ (n) (arealst) = true) then true
 else false
|C (m, n) -> (checking (m) (arealst) && checking (n) (arealst))
|P (n, m) -> checking (m) ((n :: arealst)))}
Edge : 
{(47076, 47076) -> ,
(47101, 47076) -> ,
(47101, 47101) -> ,
(47102, 47101) -> }
Starting : 47102
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (47066 : 
Input : (lam : lambda) 
Output : bool
Body : check_inner (lam) ([]),

check_inner -> (47065 : 
Input : (lam : lambda) (stack : string list) 
Output : bool
Body : 
 (match lam with 
|V v -> if find_stack (v) (stack) then true
 else false
|P (v, l) -> check_inner (l) ((v :: stack))
|C (l1, l2) -> (check_inner (l1) (stack) && check_inner (l2) (stack))),

find_stack -> (47064 : 
Input : v (stack : #965383 list) 
Output : bool
Body : 
 (match stack with 
|hd::tl -> if (hd = v) then true
 else find_stack (v) (tl)
|[] -> false)}
Edge : 
{(47064, 47064) -> ,
(47065, 47064) -> ,
(47065, 47065) -> ,
(47066, 47065) -> }
Starting : 47066
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{__list_mem__ -> check_inner,
check -> check,
checking -> find_stack}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60584 : ? (?) ([]))

Decls : 
,Exp : Insert ([] -> false At label 60575

Decls : 
,Exp : Insert (hd::tl -> if (? = ?) then true
 else ? (?) (?) At label 60575

Decls : 
,Exp : Insert (C (l1, l2) -> (? (?) (?) && ? (?) (?)) At label 60634

Decls : 
,Exp : Insert (P (v, l) -> ? (?) ((? :: ?)) At label 60634

Decls : 
,Exp : Insert (V v -> if ? (?) (?) then true
 else false At label 60634

Decls : 
,Exp : Delete (C (m, n) -> (checking (m) (arealst) && checking (n) (arealst)) At label 60575

Decls : 
,Exp : Delete (P (n, m) -> checking (m) ((n :: arealst)) At label 60575

Decls : 
,Exp : Delete (V n -> if (__list_mem__ (n) (arealst) = true) then true
 else false At label 60575

Decls : 
,Exp : Delete ([] -> false At label 60634

Decls : 
,Exp : Delete (hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl)) At label 60634

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60584 : ? (?) ([]))

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking mtr arealst  = 
 (match mtr with 
|V n -> if (__list_mem__ (n) (arealst) = true) then true
 else false
|C (m, n) -> (checking (m) (arealst) && checking (n) (arealst))
|P (n, m) -> checking (m) ((n :: arealst)))

let check mtr  = checking (mtr) ([])

Time : 0.00162100791931
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/13/sub58.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let addToList lst newInlst  = (newInlst :: lst)

let rec check_sub prevAreaName lambda  = 
 (match lambda with 
|V stationName -> __list_mem__ (stationName) (prevAreaName)
|P (areaName, nextMetro) -> check_sub ((areaName :: prevAreaName)) (nextMetro)
|C (lambdaA, lambdaB) -> (check_sub (prevAreaName) (lambdaA) && check_sub (prevAreaName) (lambdaB)))

let rec check inpt  = 
 (match inpt with 
|V var -> true
|P (var, lambda) -> check_sub ((var :: [])) (lambda)
|C (lambdaA, lambdaB) -> (check (lambdaA) && check (lambdaB)))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let addToList lst newInlst  = (60548, ((60546, newInlst :: (60547, lst)

let rec check_sub prevAreaName lambda  = (60573, 
 (match (60549, lambda with 
|V stationName -> (60554, (60553, (60550, __list_mem__ ((60551, stationName) ((60552, prevAreaName)
|P (areaName, nextMetro) -> (60561, (60560, (60555, check_sub ((60558, ((60556, areaName :: (60557, prevAreaName)) ((60559, nextMetro)
|C (lambdaA, lambdaB) -> (60572, ((60566, (60565, (60562, check_sub ((60563, prevAreaName) ((60564, lambdaA) && (60571, (60570, (60567, check_sub ((60568, prevAreaName) ((60569, lambdaB)))

let rec check inpt  = (60590, 
 (match (60574, inpt with 
|V var -> (60575, true
|P (var, lambda) -> (60582, (60581, (60576, check_sub ((60579, ((60577, var :: (60578, [])) ((60580, lambda)
|C (lambdaA, lambdaB) -> (60589, ((60585, (60583, check ((60584, lambdaA) && (60588, (60586, check ((60587, lambdaB)))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub55.ml Score : 3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checklambda  : (var list -> (lambda -> bool)) = 
fun lst lam -> 
 (match lam with 
|V x -> __list_mem__ (x) (lst)
|P (x, l) -> checklambda ((x :: lst)) (l)
|C (l1, l2) -> (checklambda (lst) (l1) && checklambda (lst) (l2)))

let check  : (lambda -> bool) = 
fun lam -> checklambda ([]) (lam)

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{__list_mem__ -> (48396 : 
Input : elem (lst : #969656 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (48423 : 
Input : (inpt : lambda) 
Output : bool
Body : 
 (match inpt with 
|V var -> true
|P (var, lambda) -> check_sub ((var :: [])) (lambda)
|C (lambdaA, lambdaB) -> (check (lambdaA) && check (lambdaB))),

check_sub -> (48422 : 
Input : (prevAreaName : string list) (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|V stationName -> __list_mem__ (stationName) (prevAreaName)
|P (areaName, nextMetro) -> check_sub ((areaName :: prevAreaName)) (nextMetro)
|C (lambdaA, lambdaB) -> (check_sub (prevAreaName) (lambdaA) && check_sub (prevAreaName) (lambdaB)))}
Edge : 
{(48396, 48396) -> ,
(48422, 48396) -> ,
(48422, 48422) -> ,
(48423, 48422) -> ,
(48423, 48423) -> }
Starting : 48423
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{__list_mem__ -> (48361 : 
Input : elem (lst : #968953 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (48387 : 
Input : (lam : lambda) 
Output : bool
Body : checklambda ([]) (lam),

checklambda -> (48386 : 
Input : (lst : string list) (lam : lambda) 
Output : bool
Body : 
 (match lam with 
|V x -> __list_mem__ (x) (lst)
|P (x, l) -> checklambda ((x :: lst)) (l)
|C (l1, l2) -> (checklambda (lst) (l1) && checklambda (lst) (l2)))}
Edge : 
{(48361, 48361) -> ,
(48386, 48361) -> ,
(48386, 48386) -> ,
(48387, 48386) -> }
Starting : 48387
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{__list_mem__ -> __list_mem__,
check -> check,
check_sub -> checklambda}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60549 : ?)

Decls : 
,Exp : Modify (60554 : ? (?) (?))

Decls : 
,Exp : Modify (60561 : ? ((? :: ?)) (?))

Decls : 
,Exp : Modify (60566 : ? (?) (?))

Decls : 
,Exp : Modify (60571 : ? (?) (?))

Decls : 
,Exp : Modify (60590 : ? ([]) (?))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60590 : ? ([]) (?))

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let addToList lst newInlst  = (newInlst :: lst)

let rec check_sub prevAreaName lambda  = 
 (match lambda with 
|V stationName -> __list_mem__ (stationName) (prevAreaName)
|P (areaName, nextMetro) -> check_sub ((areaName :: prevAreaName)) (nextMetro)
|C (lambdaA, lambdaB) -> (check_sub (prevAreaName) (lambdaA) && check_sub (prevAreaName) (lambdaB)))

let rec check inpt  = check_sub ([]) (inpt)

Time : 0.00240707397461
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/13/sub64.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check met  = 
 (match met with 
|V n -> false
|P (n, metr) -> (idSearch ((n, idList (metr))) || check (metr))
|C (metr1, metr2) -> (check (metr1) && check (metr2)))
and idList met  = 
 (match met with 
|V n -> (n :: [])
|P (n, metr) -> idList (metr)
|C (metr1, metr2) -> (idList (metr1) @ idList (metr2)))
and idSearch (id, l)  = 
 (match l with 
|[] -> false
|head::tail -> if (head = id) then true
 else idSearch ((id, tail)))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check met  = (60566, 
 (match (60546, met with 
|V n -> (60547, false
|P (n, metr) -> (60558, ((60554, (60548, idSearch ((60553, ((60549, n, (60552, (60550, idList ((60551, metr))) || (60557, (60555, check ((60556, metr))
|C (metr1, metr2) -> (60565, ((60561, (60559, check ((60560, metr1) && (60564, (60562, check ((60563, metr2)))
and idList met  = (60581, 
 (match (60567, met with 
|V n -> (60570, ((60568, n :: (60569, [])
|P (n, metr) -> (60573, (60571, idList ((60572, metr)
|C (metr1, metr2) -> (60580, ((60576, (60574, idList ((60575, metr1) @ (60579, (60577, idList ((60578, metr2)))
and idSearch (id, l)  = (60594, 
 (match (60582, l with 
|[] -> (60583, false
|head::tail -> (60593, if (60586, ((60584, head = (60585, id) then (60587, true
 else (60592, (60588, idSearch ((60591, ((60589, id, (60590, tail)))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/17/sub13.ml Score : 1
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec containCheck (n, ll)  : bool = 
 (match ll with 
|hd::tl -> if (hd = n) then true
 else containCheck ((n, tl))
|[] -> false)

let check lambda  : bool = 
let rec check (lambda, ll)  : bool = 
 (match lambda with 
|V n -> containCheck ((n, ll))
|P (n, met) -> check ((met, (n :: ll)))
|C (met1, met2) -> (check ((met1, ll)) && check ((met2, ll))))
 in 
check ((lambda, []))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (48423 : 
Input : (met : lambda) 
Output : bool
Body : 
 (match met with 
|V n -> false
|P (n, metr) -> (idSearch ((n, idList (metr))) || check (metr))
|C (metr1, metr2) -> (check (metr1) && check (metr2))),

idList -> (48424 : 
Input : (met : lambda) 
Output : string list
Body : 
 (match met with 
|V n -> (n :: [])
|P (n, metr) -> idList (metr)
|C (metr1, metr2) -> (idList (metr1) @ idList (metr2))),

idSearch -> (48425 : 
Input : ((id : string), (l : string list)) 
Output : bool
Body : 
 (match l with 
|[] -> false
|head::tail -> if (head = id) then true
 else idSearch ((id, tail)))}
Edge : 
{(48423, 48423) -> ,
(48423, 48424) -> ,
(48423, 48425) -> ,
(48424, 48424) -> ,
(48425, 48425) -> }
Starting : 48423
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (48387 : 
Input : (lambda : lambda) 
Output : bool
Body : check ((lambda, [])),

containCheck -> (48386 : 
Input : (n, (ll : #977284 list)) 
Output : bool
Body : 
 (match ll with 
|hd::tl -> if (hd = n) then true
 else containCheck ((n, tl))
|[] -> false)}
Edge : 
{(48386, 48386) -> ,
(48387, 48388) -> ,
(48388, 48386) -> ,
(48388, 48388) -> }
Starting : 48387
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
idSearch -> containCheck}
------Remainings in submission ------
{idList}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60566 : ? ((?, [])))

Decls : 
,Exp : Modify (60582 : ?)

Decls : 
,Exp : Modify (60584 : ?)

Decls : 
,Exp : Modify (60585 : ?)

Decls : 
,Exp : Modify (60592 : ? ((?, ?)))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60566 : ? ((?, [])))

Decls : 
,Exp : Modify (60582 : ?)

Decls : 
,Exp : Modify (60584 : ?)

Decls : 
,Exp : Modify (60585 : ?)

Decls : 
,Exp : Modify (60592 : ? ((?, ?)))

Decls : 
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/13/sub66.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec deletecity (var, lis)  = if (var = __list_hd__ (lis)) then if (__list_length__ (lis) = 1) then []
 else deletecity ((var, __list_tl__ (lis)))
 else if (__list_length__ (lis) = 1) then lis
 else (__list_hd__ (lis) :: deletecity ((var, __list_tl__ (lis))))

let rec findcity met  = 
 (match met with 
|V var -> (var :: [])
|P (var, lambda) -> deletecity ((var, findcity (lambda)))
|C (met1, met2) -> __list_rev_append__ (findcity (met1)) (findcity (met2)))

let deletestation (var, lambda)  = 
let citylist  = findcity (lambda)
 in 
if (deletecity ((var, citylist)) = []) then true
 else false

let rec check met  = 
 (match met with 
|V var -> false
|P (var, lambda) -> if check (lambda) then true
 else deletestation ((var, lambda))
|C (met1, met2) -> (check (met1) && check (met2)))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec deletecity (var, lis)  = (60583, if (60550, ((60546, var = (60549, (60547, __list_hd__ ((60548, lis)) then (60564, if (60555, ((60553, (60551, __list_length__ ((60552, lis) = (60554, 1) then (60556, []
 else (60563, (60557, deletecity ((60562, ((60558, var, (60561, (60559, __list_tl__ ((60560, lis)))
 else (60582, if (60569, ((60567, (60565, __list_length__ ((60566, lis) = (60568, 1) then (60570, lis
 else (60581, ((60573, (60571, __list_hd__ ((60572, lis) :: (60580, (60574, deletecity ((60579, ((60575, var, (60578, (60576, __list_tl__ ((60577, lis))))

let rec findcity met  = (60604, 
 (match (60584, met with 
|V var -> (60587, ((60585, var :: (60586, [])
|P (var, lambda) -> (60594, (60588, deletecity ((60593, ((60589, var, (60592, (60590, findcity ((60591, lambda)))
|C (met1, met2) -> (60603, (60602, (60595, __list_rev_append__ ((60598, (60596, findcity ((60597, met1)) ((60601, (60599, findcity ((60600, met2)))

let deletestation (var, lambda)  = (60618, 
let citylist  = (60607, (60605, findcity ((60606, lambda)
 in 
(60617, if (60614, ((60612, (60608, deletecity ((60611, ((60609, var, (60610, citylist)) = (60613, []) then (60615, true
 else (60616, false

let rec check met  = (60638, 
 (match (60619, met with 
|V var -> (60620, false
|P (var, lambda) -> (60630, if (60623, (60621, check ((60622, lambda) then (60624, true
 else (60629, (60625, deletestation ((60628, ((60626, var, (60627, lambda))
|C (met1, met2) -> (60637, ((60633, (60631, check ((60632, met1) && (60636, (60634, check ((60635, met2)))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_17/sub49.ml Score : -1
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec remove n ls  = 
 (match ls with 
|[] -> []
|hd::tl -> if (hd = n) then remove (n) (tl)
 else (hd :: remove (n) (tl)))

let rec length ls  = 
 (match ls with 
|[] -> 0
|hd::tl -> (1 + length (tl)))

let rec union l1 l2  = 
 (match l1 with 
|[] -> l2
|hd::tl -> union (tl) ((hd :: l2)))

let rec setfree lam  = 
 (match lam with 
|V x -> [x]
|P (x, lam1) -> remove (x) (setfree (lam1))
|C (lam1, lam2) -> union (setfree (lam1)) (setfree (lam2)))

let rec check  : (lambda -> bool) = 
fun lam -> 
let s  = setfree (lam)
 in 
if (length (s) = 0) then true
 else false

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{__list_hd__ -> (49721 : 
Input : (lst : #1000090 list) 
Output : #1000083
Body : 
 (match lst with 
|[] -> raise ListError
|hd::tl -> hd),

__list_length__ -> (49728 : 
Input : (lst : #1000151 list) 
Output : int
Body : 
 (match lst with 
|[] -> 0
|_::tl -> (1 + __list_length__ (tl))),

__list_rev_append__ -> (49738 : 
Input : (lst1 : #1000255 list) (lst2 : #1000255 list) 
Output : #1000083 list
Body : 
 (match lst1 with 
|[] -> lst2
|hd::tl -> __list_rev_append__ (tl) ((hd :: lst2))),

__list_tl__ -> (49722 : 
Input : (lst : #1000096 list) 
Output : #1000083 list
Body : 
 (match lst with 
|[] -> raise ListError
|hd::tl -> tl),

check -> (49752 : 
Input : (met : lambda) 
Output : bool
Body : 
 (match met with 
|V var -> false
|P (var, lambda) -> if check (lambda) then true
 else deletestation ((var, lambda))
|C (met1, met2) -> (check (met1) && check (met2))),

deletecity -> (49749 : 
Input : (var, (lis : #1000521 list)) 
Output : #1000521 list
Body : if (var = __list_hd__ (lis)) then if (__list_length__ (lis) = 1) then []
 else deletecity ((var, __list_tl__ (lis)))
 else if (__list_length__ (lis) = 1) then lis
 else (__list_hd__ (lis) :: deletecity ((var, __list_tl__ (lis)))),

deletestation -> (49751 : 
Input : (var, (lambda : lambda)) 
Output : bool
Body : 
let citylist  : string list = findcity (lambda)
 in 
if (deletecity ((var, citylist)) = []) then true
 else false,

findcity -> (49750 : 
Input : (met : lambda) 
Output : string list
Body : 
 (match met with 
|V var -> (var :: [])
|P (var, lambda) -> deletecity ((var, findcity (lambda)))
|C (met1, met2) -> __list_rev_append__ (findcity (met1)) (findcity (met2)))}
Edge : 
{(49728, 49728) -> ,
(49738, 49738) -> ,
(49749, 49721) -> ,
(49749, 49722) -> ,
(49749, 49728) -> ,
(49749, 49749) -> ,
(49750, 49738) -> ,
(49750, 49749) -> ,
(49750, 49750) -> ,
(49751, 49749) -> ,
(49751, 49750) -> ,
(49752, 49751) -> ,
(49752, 49752) -> }
Starting : 49752
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (49712 : 
Input : (lam : lambda) 
Output : bool
Body : 
let s  : string list = setfree (lam)
 in 
if (length (s) = 0) then true
 else false,

length -> (49709 : 
Input : (ls : #999769 list) 
Output : int
Body : 
 (match ls with 
|[] -> 0
|hd::tl -> (1 + length (tl))),

remove -> (49708 : 
Input : (n : string) (ls : #6822 list) 
Output : #6822 list
Body : 
 (match ls with 
|[] -> []
|hd::tl -> if (hd = n) then remove (n) (tl)
 else (hd :: remove (n) (tl))),

setfree -> (49711 : 
Input : (lam : lambda) 
Output : string list
Body : 
 (match lam with 
|V x -> [x]
|P (x, lam1) -> remove (x) (setfree (lam1))
|C (lam1, lam2) -> union (setfree (lam1)) (setfree (lam2))),

union -> (49710 : 
Input : (l1 : #999775 list) (l2 : #999775 list) 
Output : #999775 list
Body : 
 (match l1 with 
|[] -> l2
|hd::tl -> union (tl) ((hd :: l2)))}
Edge : 
{(49708, 49708) -> ,
(49709, 49709) -> ,
(49710, 49710) -> ,
(49711, 49708) -> ,
(49711, 49710) -> ,
(49711, 49711) -> ,
(49712, 49709) -> ,
(49712, 49711) -> }
Starting : 49712
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{__list_hd__ -> length,
__list_rev_append__ -> union,
check -> check,
findcity -> setfree}
------Remainings in submission ------
{__list_length__,__list_tl__,deletecity,deletestation}
------Remainings in solution ------
{remove}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60584 : ?)

Decls : 
,Exp : Modify (60587 : [?])

Decls : 
,Exp : Modify (60594 : ? (?) (? (?)))

Decls : 

let rec remove (n : string) (ls : #6822 list)  : #6822 list = 
 (match ls with 
|[] -> []
|hd::tl -> if (hd = n) then remove (n) (tl)
 else (hd :: remove (n) (tl)))

Callers : {findcity}
,Exp : Modify (60603 : ? (? (?)) (? (?)))

Decls : 
,Exp : Modify (60638 : 
let s  : string list = ? (?)
 in 
if (? (?) = 0) then true
 else false)

Decls : 

let rec remove (n : string) (ls : #6822 list)  : #6822 list = 
 (match ls with 
|[] -> []
|hd::tl -> if (hd = n) then remove (n) (tl)
 else (hd :: remove (n) (tl)))

Callers : {findcity}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60584 : ?)

Decls : 
,Exp : Modify (60587 : [?])

Decls : 
,Exp : Modify (60594 : ? (?) (? (?)))

Decls : 

let rec remove (n : string) (ls : #6822 list)  : #6822 list = 
 (match ls with 
|[] -> []
|hd::tl -> if (hd = n) then remove (n) (tl)
 else (hd :: remove (n) (tl)))

Callers : {findcity}
,Exp : Modify (60603 : ? (? (?)) (? (?)))

Decls : 
,Exp : Modify (60638 : 
let s  : string list = ? (?)
 in 
if (? (?) = 0) then true
 else false)

Decls : 

let rec remove (n : string) (ls : #6822 list)  : #6822 list = 
 (match ls with 
|[] -> []
|hd::tl -> if (hd = n) then remove (n) (tl)
 else (hd :: remove (n) (tl)))

Callers : {findcity}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec deletecity (var, lis)  = if (var = __list_hd__ (lis)) then if (__list_length__ (lis) = 1) then []
 else deletecity ((var, __list_tl__ (lis)))
 else if (__list_length__ (lis) = 1) then lis
 else (__list_hd__ (lis) :: deletecity ((var, __list_tl__ (lis))))

let rec remove (n : string) (ls : #6822 list)  : #6822 list = 
 (match ls with 
|[] -> []
|hd::tl -> if (hd = n) then remove (n) (tl)
 else (hd :: remove (n) (tl)))

let rec findcity met  = 
 (match met with 
|V var -> (var :: [])
|P (var, lambda) -> remove (var) (findcity (lambda))
|C (met1, met2) -> __list_rev_append__ (findcity (met1)) (findcity (met2)))

let deletestation (var, lambda)  = 
let citylist  = findcity (lambda)
 in 
if (deletecity ((var, citylist)) = []) then true
 else false

let rec check met  = 
 (match met with 
|V var -> false
|P (var, lambda) -> if check (lambda) then true
 else deletestation ((var, lambda))
|C (met1, met2) -> (check (met1) && check (met2)))

Time : 0.00474286079407
Error occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/13/sub67.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/14/sub34.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

exception TODO

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check (m : lambda)  : bool = 
 (match m with 
|P (id, y) -> if check (y) then true
 else 
 (match y with 
|V s -> (s = id)
|P (a, metr) -> 
 (match metr with 
|C (m1, m2) -> ((check (P ((a, m1))) || check (P ((id, m1)))) && (check (P ((a, m2))) || check (P ((id, m2)))))
|_ -> (check (P ((id, metr))) || check (P ((a, metr)))))
|C (m1, m2) -> (check (P ((id, m1))) && check (P ((id, m2)))))
|C (m1, m2) -> (check (m1) && check (m2))
|_ -> false)

-----------------------------
Submission
-----------------------------

exception TODO

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check (m : lambda)  : bool = (60620, 
 (match (60546, m with 
|P (id, y) -> (60611, if (60549, (60547, check ((60548, y) then (60550, true
 else (60610, 
 (match (60551, y with 
|V s -> (60554, ((60552, s = (60553, id)
|P (a, metr) -> (60596, 
 (match (60555, metr with 
|C (m1, m2) -> (60582, ((60568, ((60561, (60556, check ((60560, P ((60559, ((60557, a, (60558, m1))) || (60567, (60562, check ((60566, P ((60565, ((60563, id, (60564, m1)))) && (60581, ((60574, (60569, check ((60573, P ((60572, ((60570, a, (60571, m2))) || (60580, (60575, check ((60579, P ((60578, ((60576, id, (60577, m2)))))
|_ -> (60595, ((60588, (60583, check ((60587, P ((60586, ((60584, id, (60585, metr))) || (60594, (60589, check ((60593, P ((60592, ((60590, a, (60591, metr)))))
|C (m1, m2) -> (60609, ((60602, (60597, check ((60601, P ((60600, ((60598, id, (60599, m1))) && (60608, (60603, check ((60607, P ((60606, ((60604, id, (60605, m2)))))
|C (m1, m2) -> (60618, ((60614, (60612, check ((60613, m1) && (60617, (60615, check ((60616, m2))
|_ -> (60619, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : (m : lambda) 
Output : bool
Body : 
 (match m with 
|P (id, y) -> if check (y) then true
 else 
 (match y with 
|V s -> (s = id)
|P (a, metr) -> 
 (match metr with 
|C (m1, m2) -> ((check (P ((a, m1))) || check (P ((id, m1)))) && (check (P ((a, m2))) || check (P ((id, m2)))))
|_ -> (check (P ((id, metr))) || check (P ((a, metr)))))
|C (m1, m2) -> (check (P ((id, m1))) && check (P ((id, m2)))))
|C (m1, m2) -> (check (m1) && check (m2))
|_ -> false)}
Edge : 
{(45777, 45777) -> }
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60620 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60620 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

exception TODO

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check (m : lambda)  : bool = checking (m) ([])

Time : 0.00146579742432
Error occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/14/sub40.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/14/sub66.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec contains listOfArea s  = 
 (match listOfArea with 
|[] -> false
|h::t -> if (h = s) then true
 else contains (t) (s))

let rec check2 x listOfArea  = 
 (match x with 
|V s -> contains (listOfArea) (s)
|P (n, m) -> check2 (m) ((n :: listOfArea))
|C (m1, m2) -> (check2 (m1) (listOfArea) && check2 (m2) (listOfArea)))

let check x  = 
 (match x with 
|V s -> true
|_ -> check2 (x) ([]))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec contains listOfArea s  = (60558, 
 (match (60546, listOfArea with 
|[] -> (60547, false
|h::t -> (60557, if (60550, ((60548, h = (60549, s) then (60551, true
 else (60556, (60555, (60552, contains ((60553, t) ((60554, s))

let rec check2 x listOfArea  = (60583, 
 (match (60559, x with 
|V s -> (60564, (60563, (60560, contains ((60561, listOfArea) ((60562, s)
|P (n, m) -> (60571, (60570, (60565, check2 ((60566, m) ((60569, ((60567, n :: (60568, listOfArea))
|C (m1, m2) -> (60582, ((60576, (60575, (60572, check2 ((60573, m1) ((60574, listOfArea) && (60581, (60580, (60577, check2 ((60578, m2) ((60579, listOfArea)))

let check x  = (60591, 
 (match (60584, x with 
|V s -> (60585, true
|_ -> (60590, (60589, (60586, check2 ((60587, x) ((60588, []))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub51.ml Score : 3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec findlst  : (var list -> (var -> bool)) = 
fun lst v -> 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = v) then true
 else findlst (tl) (v))

let rec mycheck  : (lambda -> (var list -> bool)) = 
fun lam lst -> 
 (match lam with 
|V x -> findlst (lst) (x)
|P (x, e) -> mycheck (e) ((x :: lst))
|C (e1, e2) -> (mycheck (e1) (lst) && mycheck (e2) (lst)))

let check  : (lambda -> bool) = 
fun lam -> mycheck (lam) ([])

let t1  = P (("a", V ("a")))

let t2  = P (("a", P (("a", V ("a")))))

let t3  = P (("a", P (("b", C ((V ("a"), V ("b")))))))

let t4  = P (("a", C ((V ("a"), P (("b", V ("a")))))))

let t5  = P (("a", V ("b")))

let t6  = P (("a", C ((V ("a"), P (("b", V ("c")))))))

let t7  = P (("a", P (("b", C ((V ("a"), V ("c")))))))

let _  = check (t1)

let _  = check (t2)

let _  = check (t3)

let _  = check (t4)

let _  = check (t5)

let _  = check (t6)

let _  = check (t7)

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (48425 : 
Input : (x : lambda) 
Output : bool
Body : 
 (match x with 
|V s -> true
|_ -> check2 (x) ([])),

check2 -> (48424 : 
Input : (x : lambda) (listOfArea : string list) 
Output : bool
Body : 
 (match x with 
|V s -> contains (listOfArea) (s)
|P (n, m) -> check2 (m) ((n :: listOfArea))
|C (m1, m2) -> (check2 (m1) (listOfArea) && check2 (m2) (listOfArea))),

contains -> (48423 : 
Input : (listOfArea : #7532 list) (s : string) 
Output : bool
Body : 
 (match listOfArea with 
|[] -> false
|h::t -> if (h = s) then true
 else contains (t) (s))}
Edge : 
{(48423, 48423) -> ,
(48424, 48423) -> ,
(48424, 48424) -> ,
(48425, 48424) -> }
Starting : 48425
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (48388 : 
Input : (lam : lambda) 
Output : bool
Body : mycheck (lam) ([]),

findlst -> (48386 : 
Input : (lst : #7469 list) (v : string) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = v) then true
 else findlst (tl) (v)),

mycheck -> (48387 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lam with 
|V x -> findlst (lst) (x)
|P (x, e) -> mycheck (e) ((x :: lst))
|C (e1, e2) -> (mycheck (e1) (lst) && mycheck (e2) (lst)))}
Edge : 
{(48386, 48386) -> ,
(48387, 48386) -> ,
(48387, 48387) -> ,
(48388, 48387) -> }
Starting : 48388
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
check2 -> mycheck,
contains -> findlst}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60548 : ?)

Decls : 
,Exp : Modify (60549 : ?)

Decls : 
,Exp : Modify (60556 : ? (?) (?))

Decls : 
,Exp : Modify (60559 : ?)

Decls : 
,Exp : Modify (60564 : ? (?) (?))

Decls : 
,Exp : Modify (60571 : ? (?) ((? :: ?)))

Decls : 
,Exp : Modify (60576 : ? (?) (?))

Decls : 
,Exp : Modify (60581 : ? (?) (?))

Decls : 
,Exp : Modify (60591 : ? (?) ([]))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60591 : ? (?) ([]))

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec contains listOfArea s  = 
 (match listOfArea with 
|[] -> false
|h::t -> if (h = s) then true
 else contains (t) (s))

let rec check2 x listOfArea  = 
 (match x with 
|V s -> contains (listOfArea) (s)
|P (n, m) -> check2 (m) ((n :: listOfArea))
|C (m1, m2) -> (check2 (m1) (listOfArea) && check2 (m2) (listOfArea)))

let check x  = check2 (x) ([])

Time : 0.00178003311157
Error occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/15/sub29.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/15/sub31.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check  : (lambda -> bool) = 
fun met -> 
let rec checkIn  : ((lambda * var list) -> bool) = 
fun (lambda, stationlist) -> 
 (match lambda with 
|V stationstr -> if __list_mem__ (stationstr) (stationlist) then true
 else false
|P (areastr, metin) -> checkIn ((metin, (stationlist @ [areastr])))
|C (metin1, metin2) -> (checkIn ((metin1, stationlist)) && checkIn ((metin2, stationlist))))
 in 

 (match met with 
|V varstr -> true
|_ -> checkIn ((met, [])))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check  : (lambda -> bool) = (60585, 
fun met -> (60584, 
let rec checkIn  : ((lambda * var list) -> bool) = (60575, 
fun (lambda, stationlist) -> (60574, 
 (match (60546, lambda with 
|V stationstr -> (60554, if (60551, (60550, (60547, __list_mem__ ((60548, stationstr) ((60549, stationlist) then (60552, true
 else (60553, false
|P (areastr, metin) -> (60562, (60555, checkIn ((60561, ((60556, metin, (60560, ((60557, stationlist @ (60559, [(60558, areastr])))
|C (metin1, metin2) -> (60573, ((60567, (60563, checkIn ((60566, ((60564, metin1, (60565, stationlist)) && (60572, (60568, checkIn ((60571, ((60569, metin2, (60570, stationlist))))
 in 
(60583, 
 (match (60576, met with 
|V varstr -> (60577, true
|_ -> (60582, (60578, checkIn ((60581, ((60579, met, (60580, [])))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_16/sub35.ml Score : 3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec chklst (lambda, lst)  = 
 (match lambda with 
|P (var, lambda) -> chklst ((lambda, (lst @ [var])))
|C (lambda1, lambda2) -> if (chklst ((lambda1, lst)) && chklst ((lambda2, lst))) then true
 else false
|V var -> if (lst = []) then false
 else __list_exists__ (
fun x -> (x = var)) (lst))

let check  : (lambda -> bool) = 
fun lambda -> chklst ((lambda, []))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{__list_mem__ -> (47074 : 
Input : elem (lst : #961737 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (47099 : 
Input : (met : lambda) 
Output : bool
Body : 
 (match met with 
|V varstr -> true
|_ -> checkIn ((met, []))),

checkIn -> (47100 : 
Input : ((lambda : lambda), (stationlist : string list)) 
Output : bool
Body : 
 (match lambda with 
|V stationstr -> if __list_mem__ (stationstr) (stationlist) then true
 else false
|P (areastr, metin) -> checkIn ((metin, (stationlist @ [areastr])))
|C (metin1, metin2) -> (checkIn ((metin1, stationlist)) && checkIn ((metin2, stationlist))))}
Edge : 
{(47074, 47074) -> ,
(47099, 47100) -> ,
(47100, 47074) -> ,
(47100, 47100) -> }
Starting : 47099
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{__list_exists__ -> (47040 : 
Input : (pred : (#961026 -> bool)) (lst : #961026 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> (pred (hd) || __list_exists__ (pred) (tl))),

check -> (47065 : 
Input : (lambda : lambda) 
Output : bool
Body : chklst ((lambda, [])),

chklst -> (47064 : 
Input : ((lambda : lambda), (lst : string list)) 
Output : bool
Body : 
 (match lambda with 
|P (var, lambda) -> chklst ((lambda, (lst @ [var])))
|C (lambda1, lambda2) -> if (chklst ((lambda1, lst)) && chklst ((lambda2, lst))) then true
 else false
|V var -> if (lst = []) then false
 else __list_exists__ (
fun (x : string) -> (x = var)) (lst))}
Edge : 
{(47040, 47040) -> ,
(47064, 47040) -> ,
(47064, 47064) -> ,
(47065, 47064) -> }
Starting : 47065
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{__list_mem__ -> __list_exists__,
check -> check,
checkIn -> chklst}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60551 : (? = []))

Decls : 
,Exp : Modify (60552 : false)

Decls : 
,Exp : Modify (60553 : ? (
fun (x : string) -> (? = ?)) (?))

Decls : 
,Exp : Modify (60562 : ? ((?, (? @ [?]))))

Decls : 
,Exp : Modify (60573 : if (? ((?, ?)) && ? ((?, ?))) then true
 else false)

Decls : 
,Exp : Modify (60583 : ? ((?, [])))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60583 : ? ((?, [])))

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check  : (lambda -> bool) = 
fun met -> 
let rec checkIn  : ((lambda * var list) -> bool) = 
fun (lambda, stationlist) -> 
 (match lambda with 
|V stationstr -> if __list_mem__ (stationstr) (stationlist) then true
 else false
|P (areastr, metin) -> checkIn ((metin, (stationlist @ [areastr])))
|C (metin1, metin2) -> (checkIn ((metin1, stationlist)) && checkIn ((metin2, stationlist))))
 in 
checkIn ((met, []))

Time : 0.0014340877533
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/15/sub54.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec findStation  : (lambda -> string list) = 
fun x -> 
 (match x with 
|V station -> [station]
|C (a, b) -> (findStation (a) @ findStation (b))
|P (area, next) -> findStation (next))

let rec exclude  : (lambda -> (string list -> bool)) = 
fun m strl -> 
 (match strl with 
|[] -> true
|_ -> 
 (match m with 
|V sta -> false
|P (area, next) -> if __list_mem__ (area) (strl) then exclude (next) (__list_filter__ (
fun x -> (x != area)) (strl))
 else exclude (next) (strl)
|C (V sta, con2) -> exclude (con2) (strl)
|C (con1, V sta) -> exclude (con1) (strl)
|C (con1, con2) -> (exclude (con1) (findStation (con1)) && exclude (con2) (findStation (con2)))))

let rec check  : (lambda -> bool) = 
fun x -> exclude (x) (findStation (x))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec findStation  : (lambda -> string list) = (60560, 
fun x -> (60559, 
 (match (60546, x with 
|V station -> (60548, [(60547, station]
|C (a, b) -> (60555, ((60551, (60549, findStation ((60550, a) @ (60554, (60552, findStation ((60553, b))
|P (area, next) -> (60558, (60556, findStation ((60557, next))

let rec exclude  : (lambda -> (string list -> bool)) = (60616, 
fun m strl -> (60614, 
 (match (60561, strl with 
|[] -> (60562, true
|_ -> (60613, 
 (match (60563, m with 
|V sta -> (60564, false
|P (area, next) -> (60587, if (60569, (60568, (60565, __list_mem__ ((60566, area) ((60567, strl) then (60581, (60580, (60570, exclude ((60571, next) ((60579, (60578, (60572, __list_filter__ ((60576, 
fun x -> (60575, ((60573, x != (60574, area)) ((60577, strl))
 else (60586, (60585, (60582, exclude ((60583, next) ((60584, strl)
|C (V sta, con2) -> (60592, (60591, (60588, exclude ((60589, con2) ((60590, strl)
|C (con1, V sta) -> (60597, (60596, (60593, exclude ((60594, con1) ((60595, strl)
|C (con1, con2) -> (60612, ((60604, (60603, (60598, exclude ((60599, con1) ((60602, (60600, findStation ((60601, con1)) && (60611, (60610, (60605, exclude ((60606, con2) ((60609, (60607, findStation ((60608, con2)))))

let rec check  : (lambda -> bool) = (60624, 
fun x -> (60623, (60622, (60617, exclude ((60618, x) ((60621, (60619, findStation ((60620, x))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_15/sub65.ml Score : 2
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec free_vars  = 
fun __fun__ -> 
 (match __fun__ with 
|V v -> [v]
|P (v, e) -> __list_filter__ (
fun x -> (x != v)) (free_vars (e))
|C (e1, e2) -> 
let f_e1  = free_vars (e1)
 in 

let f_e2  = free_vars (e2)
 in 
__list_append__ (f_e1) (__list_filter__ (
fun x -> not (__list_mem__ (x) (f_e1))) (f_e2)))

let rec fresh_var v1 l  = if __list_mem__ (v1) (l) then fresh_var ((v1 ^ "'")) (l)
 else v1

let check  : (lambda -> bool) = 
fun e -> if (free_vars (e) = []) then true
 else false

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{__list_filter__ -> (48400 : 
Input : (pred : (#1000103 -> bool)) (lst : #1000103 list) 
Output : #1000047 list
Body : 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl)),

__list_mem__ -> (48398 : 
Input : elem (lst : #1000079 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (48425 : 
Input : (x : lambda) 
Output : bool
Body : exclude (x) (findStation (x)),

exclude -> (48424 : 
Input : (m : lambda) (strl : string list) 
Output : bool
Body : 
 (match strl with 
|[] -> true
|_ -> 
 (match m with 
|V sta -> false
|P (area, next) -> if __list_mem__ (area) (strl) then exclude (next) (__list_filter__ (
fun (x : string) -> (x != area)) (strl))
 else exclude (next) (strl)
|C (V sta, con2) -> exclude (con2) (strl)
|C (con1, V sta) -> exclude (con1) (strl)
|C (con1, con2) -> (exclude (con1) (findStation (con1)) && exclude (con2) (findStation (con2))))),

findStation -> (48423 : 
Input : (x : lambda) 
Output : string list
Body : 
 (match x with 
|V station -> [station]
|C (a, b) -> (findStation (a) @ findStation (b))
|P (area, next) -> findStation (next))}
Edge : 
{(48398, 48398) -> ,
(48400, 48400) -> ,
(48423, 48423) -> ,
(48424, 48398) -> ,
(48424, 48400) -> ,
(48424, 48423) -> ,
(48424, 48424) -> ,
(48425, 48423) -> ,
(48425, 48424) -> }
Starting : 48425
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{__list_append__ -> (48364 : 
Input : (lst1 : #999387 list) (lst2 : #999387 list) 
Output : #999324 list
Body : (lst1 @ lst2),

__list_filter__ -> (48363 : 
Input : (pred : (#999380 -> bool)) (lst : #999380 list) 
Output : #999324 list
Body : 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl)),

__list_mem__ -> (48361 : 
Input : elem (lst : #999356 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (48388 : 
Input : (e : lambda) 
Output : bool
Body : if (free_vars (e) = []) then true
 else false,

free_vars -> (48386 : 
Input : (__fun__ : lambda) 
Output : string list
Body : 
 (match __fun__ with 
|V v -> [v]
|P (v, e) -> __list_filter__ (
fun (x : string) -> (x != v)) (free_vars (e))
|C (e1, e2) -> 
let f_e1  : string list = free_vars (e1)
 in 

let f_e2  : string list = free_vars (e2)
 in 
__list_append__ (f_e1) (__list_filter__ (
fun (x : string) -> not (__list_mem__ (x) (f_e1))) (f_e2)))}
Edge : 
{(48361, 48361) -> ,
(48363, 48363) -> ,
(48386, 48361) -> ,
(48386, 48363) -> ,
(48386, 48364) -> ,
(48386, 48386) -> ,
(48388, 48386) -> }
Starting : 48388
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{__list_filter__ -> __list_filter__,
__list_mem__ -> __list_mem__,
check -> check,
findStation -> free_vars}
------Remainings in submission ------
{exclude}
------Remainings in solution ------
{__list_append__}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60547 : ?)

Decls : 
,Exp : Modify (60555 : 
let f_e1  : string list = ? (?)
 in 

let f_e2  : string list = ? (?)
 in 
? (?) (? (
fun (x : string) -> not (? (?) (?))) (?)))

Decls : 

let __list_append__ (lst1 : #1002387 list) (lst2 : #1002387 list)  : #1002324 list = (lst1 @ lst2)

Callers : {findStation}
,Exp : Modify (60558 : ? (
fun (x : string) -> (? != ?)) (? (?)))

Decls : 
,Exp : Modify (60623 : if (? (?) = []) then true
 else false)

Decls : 

let __list_append__ (lst1 : #1002387 list) (lst2 : #1002387 list)  : #1002324 list = (lst1 @ lst2)

Callers : {findStation}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60547 : ?)

Decls : 
,Exp : Modify (60555 : 
let f_e1  : string list = ? (?)
 in 

let f_e2  : string list = ? (?)
 in 
? (?) (? (
fun (x : string) -> not (? (?) (?))) (?)))

Decls : 

let __list_append__ (lst1 : #1002387 list) (lst2 : #1002387 list)  : #1002324 list = (lst1 @ lst2)

Callers : {findStation}
,Exp : Modify (60558 : ? (
fun (x : string) -> (? != ?)) (? (?)))

Decls : 
,Exp : Modify (60623 : if (? (?) = []) then true
 else false)

Decls : 

let __list_append__ (lst1 : #1002387 list) (lst2 : #1002387 list)  : #1002324 list = (lst1 @ lst2)

Callers : {findStation}
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/15/sub7.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec station_list x  = 
 (match x with 
|V n -> [n]
|P (n, m) -> station_list (m)
|C (m1, m2) -> __list_append__ (station_list (m1)) (station_list (m2)))

let rec check (x : lambda)  : bool = 
 (match x with 
|V n -> false
|P (n, m) -> __list_mem__ (n) (station_list (m))
|C (m1, m2) -> false)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec station_list x  = (60561, 
 (match (60546, x with 
|V n -> (60548, [(60547, n]
|P (n, m) -> (60551, (60549, station_list ((60550, m)
|C (m1, m2) -> (60560, (60559, (60552, __list_append__ ((60555, (60553, station_list ((60554, m1)) ((60558, (60556, station_list ((60557, m2)))

let rec check (x : lambda)  : bool = (60572, 
 (match (60562, x with 
|V n -> (60563, false
|P (n, m) -> (60570, (60569, (60564, __list_mem__ ((60565, n) ((60568, (60566, station_list ((60567, m))
|C (m1, m2) -> (60571, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_15/sub65.ml Score : 3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec free_vars  = 
fun __fun__ -> 
 (match __fun__ with 
|V v -> [v]
|P (v, e) -> __list_filter__ (
fun x -> (x != v)) (free_vars (e))
|C (e1, e2) -> 
let f_e1  = free_vars (e1)
 in 

let f_e2  = free_vars (e2)
 in 
__list_append__ (f_e1) (__list_filter__ (
fun x -> not (__list_mem__ (x) (f_e1))) (f_e2)))

let rec fresh_var v1 l  = if __list_mem__ (v1) (l) then fresh_var ((v1 ^ "'")) (l)
 else v1

let check  : (lambda -> bool) = 
fun e -> if (free_vars (e) = []) then true
 else false

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{__list_append__ -> (47079 : 
Input : (lst1 : #960447 list) (lst2 : #960447 list) 
Output : #960384 list
Body : (lst1 @ lst2),

__list_mem__ -> (47076 : 
Input : elem (lst : #960416 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (47102 : 
Input : (x : lambda) 
Output : bool
Body : 
 (match x with 
|V n -> false
|P (n, m) -> __list_mem__ (n) (station_list (m))
|C (m1, m2) -> false),

station_list -> (47101 : 
Input : (x : lambda) 
Output : string list
Body : 
 (match x with 
|V n -> [n]
|P (n, m) -> station_list (m)
|C (m1, m2) -> __list_append__ (station_list (m1)) (station_list (m2)))}
Edge : 
{(47076, 47076) -> ,
(47101, 47079) -> ,
(47101, 47101) -> ,
(47102, 47076) -> ,
(47102, 47101) -> }
Starting : 47102
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{__list_append__ -> (47042 : 
Input : (lst1 : #959724 list) (lst2 : #959724 list) 
Output : #959661 list
Body : (lst1 @ lst2),

__list_filter__ -> (47041 : 
Input : (pred : (#959717 -> bool)) (lst : #959717 list) 
Output : #959661 list
Body : 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl)),

__list_mem__ -> (47039 : 
Input : elem (lst : #959693 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (47066 : 
Input : (e : lambda) 
Output : bool
Body : if (free_vars (e) = []) then true
 else false,

free_vars -> (47064 : 
Input : (__fun__ : lambda) 
Output : string list
Body : 
 (match __fun__ with 
|V v -> [v]
|P (v, e) -> __list_filter__ (
fun (x : string) -> (x != v)) (free_vars (e))
|C (e1, e2) -> 
let f_e1  : string list = free_vars (e1)
 in 

let f_e2  : string list = free_vars (e2)
 in 
__list_append__ (f_e1) (__list_filter__ (
fun (x : string) -> not (__list_mem__ (x) (f_e1))) (f_e2)))}
Edge : 
{(47039, 47039) -> ,
(47041, 47041) -> ,
(47064, 47039) -> ,
(47064, 47041) -> ,
(47064, 47042) -> ,
(47064, 47064) -> ,
(47066, 47064) -> }
Starting : 47066
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{__list_append__ -> __list_append__,
__list_mem__ -> __list_mem__,
check -> check,
station_list -> free_vars}
------Remainings in submission ------
{}
------Remainings in solution ------
{__list_filter__}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60547 : ?)

Decls : 
,Exp : Modify (60551 : ? (
fun (x : string) -> (? != ?)) (? (?)))

Decls : 

let rec __list_filter__ (pred : (#962597 -> bool)) (lst : #962597 list)  : #962541 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {station_list}
,Exp : Modify (60560 : 
let f_e1  : string list = ? (?)
 in 

let f_e2  : string list = ? (?)
 in 
? (?) (? (
fun (x : string) -> not (? (?) (?))) (?)))

Decls : 

let rec __list_filter__ (pred : (#962597 -> bool)) (lst : #962597 list)  : #962541 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {station_list}
,Exp : Modify (60572 : if (? (?) = []) then true
 else false)

Decls : 

let rec __list_filter__ (pred : (#962597 -> bool)) (lst : #962597 list)  : #962541 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {station_list}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60547 : ?)

Decls : 
,Exp : Modify (60551 : ? (
fun (x : string) -> (? != ?)) (? (?)))

Decls : 

let rec __list_filter__ (pred : (#962597 -> bool)) (lst : #962597 list)  : #962541 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {station_list}
,Exp : Modify (60560 : 
let f_e1  : string list = ? (?)
 in 

let f_e2  : string list = ? (?)
 in 
? (?) (? (
fun (x : string) -> not (? (?) (?))) (?)))

Decls : 

let rec __list_filter__ (pred : (#962597 -> bool)) (lst : #962597 list)  : #962541 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {station_list}
,Exp : Modify (60572 : if (? (?) = []) then true
 else false)

Decls : 

let rec __list_filter__ (pred : (#962597 -> bool)) (lst : #962597 list)  : #962541 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {station_list}
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/15/sub74.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let isStringExist e l  = 
let x  = __list_find__ (
fun x -> (x = e)) (l)
 in 
true

let check lambda  = 
let rec checkWithArea areaList lambda  = 
 (match lambda with 
|V var -> isStringExist (var) (areaList)
|P (var, lambda) -> checkWithArea ((areaList @ [var])) (lambda)
|C (m1, m2) -> (checkWithArea (areaList) (m1) && checkWithArea (areaList) (m2)))
 in 
checkWithArea ([]) (lambda)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let isStringExist e l  = (60555, 
let x  = (60553, (60552, (60546, __list_find__ ((60550, 
fun x -> (60549, ((60547, x = (60548, e)) ((60551, l)
 in 
(60554, true

let check lambda  = (60587, 
let rec checkWithArea areaList lambda  = (60581, 
 (match (60556, lambda with 
|V var -> (60561, (60560, (60557, isStringExist ((60558, var) ((60559, areaList)
|P (var, lambda) -> (60569, (60568, (60562, checkWithArea ((60566, ((60563, areaList @ (60565, [(60564, var])) ((60567, lambda)
|C (m1, m2) -> (60580, ((60574, (60573, (60570, checkWithArea ((60571, areaList) ((60572, m1) && (60579, (60578, (60575, checkWithArea ((60576, areaList) ((60577, m2)))
 in 
(60586, (60585, (60582, checkWithArea ((60583, []) ((60584, lambda)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub55.ml Score : 2
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checklambda  : (var list -> (lambda -> bool)) = 
fun lst lam -> 
 (match lam with 
|V x -> __list_mem__ (x) (lst)
|P (x, l) -> checklambda ((x :: lst)) (l)
|C (l1, l2) -> (checklambda (lst) (l1) && checklambda (lst) (l2)))

let check  : (lambda -> bool) = 
fun lam -> checklambda ([]) (lam)

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{__list_find__ -> (48414 : 
Input : (pred : (#957935 -> bool)) (lst : #957935 list) 
Output : #957728
Body : 
 (match lst with 
|[] -> raise ListError
|hd::tl -> if pred (hd) then hd
 else __list_find__ (pred) (tl)),

check -> (48422 : 
Input : (lambda : lambda) 
Output : bool
Body : checkWithArea ([]) (lambda),

checkWithArea -> (48423 : 
Input : (areaList : string list) (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|V var -> isStringExist (var) (areaList)
|P (var, lambda) -> checkWithArea ((areaList @ [var])) (lambda)
|C (m1, m2) -> (checkWithArea (areaList) (m1) && checkWithArea (areaList) (m2))),

isStringExist -> (48421 : 
Input : (e : string) (l : #7531 list) 
Output : bool
Body : 
let x  = __list_find__ (
fun x -> (x = e)) (l)
 in 
true}
Edge : 
{(48414, 48414) -> ,
(48421, 48414) -> ,
(48422, 48423) -> ,
(48423, 48421) -> ,
(48423, 48423) -> }
Starting : 48422
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{__list_mem__ -> (48361 : 
Input : elem (lst : #957057 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (48387 : 
Input : (lam : lambda) 
Output : bool
Body : checklambda ([]) (lam),

checklambda -> (48386 : 
Input : (lst : string list) (lam : lambda) 
Output : bool
Body : 
 (match lam with 
|V x -> __list_mem__ (x) (lst)
|P (x, l) -> checklambda ((x :: lst)) (l)
|C (l1, l2) -> (checklambda (lst) (l1) && checklambda (lst) (l2)))}
Edge : 
{(48361, 48361) -> ,
(48386, 48361) -> ,
(48386, 48386) -> ,
(48387, 48386) -> }
Starting : 48387
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{__list_find__ -> __list_mem__,
check -> check,
checkWithArea -> checklambda}
------Remainings in submission ------
{isStringExist}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60556 : ?)

Decls : 
,Exp : Modify (60561 : ? (?) (?))

Decls : 
,Exp : Modify (60569 : ? ((? :: ?)) (?))

Decls : 
,Exp : Modify (60574 : ? (?) (?))

Decls : 
,Exp : Modify (60579 : ? (?) (?))

Decls : 
,Exp : Modify (60586 : ? ([]) (?))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60556 : ?)

Decls : 
,Exp : Modify (60561 : ? (?) (?))

Decls : 
,Exp : Modify (60569 : ? ((? :: ?)) (?))

Decls : 
,Exp : Modify (60574 : ? (?) (?))

Decls : 
,Exp : Modify (60579 : ? (?) (?))

Decls : 
,Exp : Modify (60586 : ? ([]) (?))

Decls : 
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/15/sub75.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let isStringExist e l  = 
let x  = __list_find__ (
fun x -> (x = e)) (l)
 in 
true

let check lambda  = 
let rec checkWithArea areaList lambda  = 
 (match lambda with 
|V var -> isStringExist (var) (areaList)
|P (var, lambda) -> checkWithArea ((areaList @ [var])) (lambda)
|C (m1, m2) -> (checkWithArea (areaList) (m1) && checkWithArea (areaList) (m2)))
 in 
checkWithArea ([]) (lambda)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let isStringExist e l  = (60555, 
let x  = (60553, (60552, (60546, __list_find__ ((60550, 
fun x -> (60549, ((60547, x = (60548, e)) ((60551, l)
 in 
(60554, true

let check lambda  = (60587, 
let rec checkWithArea areaList lambda  = (60581, 
 (match (60556, lambda with 
|V var -> (60561, (60560, (60557, isStringExist ((60558, var) ((60559, areaList)
|P (var, lambda) -> (60569, (60568, (60562, checkWithArea ((60566, ((60563, areaList @ (60565, [(60564, var])) ((60567, lambda)
|C (m1, m2) -> (60580, ((60574, (60573, (60570, checkWithArea ((60571, areaList) ((60572, m1) && (60579, (60578, (60575, checkWithArea ((60576, areaList) ((60577, m2)))
 in 
(60586, (60585, (60582, checkWithArea ((60583, []) ((60584, lambda)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub55.ml Score : 2
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checklambda  : (var list -> (lambda -> bool)) = 
fun lst lam -> 
 (match lam with 
|V x -> __list_mem__ (x) (lst)
|P (x, l) -> checklambda ((x :: lst)) (l)
|C (l1, l2) -> (checklambda (lst) (l1) && checklambda (lst) (l2)))

let check  : (lambda -> bool) = 
fun lam -> checklambda ([]) (lam)

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{__list_find__ -> (48414 : 
Input : (pred : (#957935 -> bool)) (lst : #957935 list) 
Output : #957728
Body : 
 (match lst with 
|[] -> raise ListError
|hd::tl -> if pred (hd) then hd
 else __list_find__ (pred) (tl)),

check -> (48422 : 
Input : (lambda : lambda) 
Output : bool
Body : checkWithArea ([]) (lambda),

checkWithArea -> (48423 : 
Input : (areaList : string list) (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|V var -> isStringExist (var) (areaList)
|P (var, lambda) -> checkWithArea ((areaList @ [var])) (lambda)
|C (m1, m2) -> (checkWithArea (areaList) (m1) && checkWithArea (areaList) (m2))),

isStringExist -> (48421 : 
Input : (e : string) (l : #7531 list) 
Output : bool
Body : 
let x  = __list_find__ (
fun x -> (x = e)) (l)
 in 
true}
Edge : 
{(48414, 48414) -> ,
(48421, 48414) -> ,
(48422, 48423) -> ,
(48423, 48421) -> ,
(48423, 48423) -> }
Starting : 48422
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{__list_mem__ -> (48361 : 
Input : elem (lst : #957057 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (48387 : 
Input : (lam : lambda) 
Output : bool
Body : checklambda ([]) (lam),

checklambda -> (48386 : 
Input : (lst : string list) (lam : lambda) 
Output : bool
Body : 
 (match lam with 
|V x -> __list_mem__ (x) (lst)
|P (x, l) -> checklambda ((x :: lst)) (l)
|C (l1, l2) -> (checklambda (lst) (l1) && checklambda (lst) (l2)))}
Edge : 
{(48361, 48361) -> ,
(48386, 48361) -> ,
(48386, 48386) -> ,
(48387, 48386) -> }
Starting : 48387
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{__list_find__ -> __list_mem__,
check -> check,
checkWithArea -> checklambda}
------Remainings in submission ------
{isStringExist}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60556 : ?)

Decls : 
,Exp : Modify (60561 : ? (?) (?))

Decls : 
,Exp : Modify (60569 : ? ((? :: ?)) (?))

Decls : 
,Exp : Modify (60574 : ? (?) (?))

Decls : 
,Exp : Modify (60579 : ? (?) (?))

Decls : 
,Exp : Modify (60586 : ? ([]) (?))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60556 : ?)

Decls : 
,Exp : Modify (60561 : ? (?) (?))

Decls : 
,Exp : Modify (60569 : ? ((? :: ?)) (?))

Decls : 
,Exp : Modify (60574 : ? (?) (?))

Decls : 
,Exp : Modify (60579 : ? (?) (?))

Decls : 
,Exp : Modify (60586 : ? ([]) (?))

Decls : 
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/15/sub8.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec station_list x  = 
 (match x with 
|V n -> [n]
|P (n, m) -> station_list (m)
|C (m1, m2) -> __list_append__ (station_list (m1)) (station_list (m2)))

let rec check (x : lambda)  : bool = 
 (match x with 
|V n -> false
|P (n, m) -> __list_mem__ (n) (station_list (m))
|C (m1, m2) -> (check (m1) && check (m2)))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec station_list x  = (60561, 
 (match (60546, x with 
|V n -> (60548, [(60547, n]
|P (n, m) -> (60551, (60549, station_list ((60550, m)
|C (m1, m2) -> (60560, (60559, (60552, __list_append__ ((60555, (60553, station_list ((60554, m1)) ((60558, (60556, station_list ((60557, m2)))

let rec check (x : lambda)  : bool = (60578, 
 (match (60562, x with 
|V n -> (60563, false
|P (n, m) -> (60570, (60569, (60564, __list_mem__ ((60565, n) ((60568, (60566, station_list ((60567, m))
|C (m1, m2) -> (60577, ((60573, (60571, check ((60572, m1) && (60576, (60574, check ((60575, m2)))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_15/sub65.ml Score : 3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec free_vars  = 
fun __fun__ -> 
 (match __fun__ with 
|V v -> [v]
|P (v, e) -> __list_filter__ (
fun x -> (x != v)) (free_vars (e))
|C (e1, e2) -> 
let f_e1  = free_vars (e1)
 in 

let f_e2  = free_vars (e2)
 in 
__list_append__ (f_e1) (__list_filter__ (
fun x -> not (__list_mem__ (x) (f_e1))) (f_e2)))

let rec fresh_var v1 l  = if __list_mem__ (v1) (l) then fresh_var ((v1 ^ "'")) (l)
 else v1

let check  : (lambda -> bool) = 
fun e -> if (free_vars (e) = []) then true
 else false

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{__list_append__ -> (47079 : 
Input : (lst1 : #963091 list) (lst2 : #963091 list) 
Output : #963028 list
Body : (lst1 @ lst2),

__list_mem__ -> (47076 : 
Input : elem (lst : #963060 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (47102 : 
Input : (x : lambda) 
Output : bool
Body : 
 (match x with 
|V n -> false
|P (n, m) -> __list_mem__ (n) (station_list (m))
|C (m1, m2) -> (check (m1) && check (m2))),

station_list -> (47101 : 
Input : (x : lambda) 
Output : string list
Body : 
 (match x with 
|V n -> [n]
|P (n, m) -> station_list (m)
|C (m1, m2) -> __list_append__ (station_list (m1)) (station_list (m2)))}
Edge : 
{(47076, 47076) -> ,
(47101, 47079) -> ,
(47101, 47101) -> ,
(47102, 47076) -> ,
(47102, 47101) -> ,
(47102, 47102) -> }
Starting : 47102
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{__list_append__ -> (47042 : 
Input : (lst1 : #962368 list) (lst2 : #962368 list) 
Output : #962305 list
Body : (lst1 @ lst2),

__list_filter__ -> (47041 : 
Input : (pred : (#962361 -> bool)) (lst : #962361 list) 
Output : #962305 list
Body : 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl)),

__list_mem__ -> (47039 : 
Input : elem (lst : #962337 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (47066 : 
Input : (e : lambda) 
Output : bool
Body : if (free_vars (e) = []) then true
 else false,

free_vars -> (47064 : 
Input : (__fun__ : lambda) 
Output : string list
Body : 
 (match __fun__ with 
|V v -> [v]
|P (v, e) -> __list_filter__ (
fun (x : string) -> (x != v)) (free_vars (e))
|C (e1, e2) -> 
let f_e1  : string list = free_vars (e1)
 in 

let f_e2  : string list = free_vars (e2)
 in 
__list_append__ (f_e1) (__list_filter__ (
fun (x : string) -> not (__list_mem__ (x) (f_e1))) (f_e2)))}
Edge : 
{(47039, 47039) -> ,
(47041, 47041) -> ,
(47064, 47039) -> ,
(47064, 47041) -> ,
(47064, 47042) -> ,
(47064, 47064) -> ,
(47066, 47064) -> }
Starting : 47066
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{__list_append__ -> __list_append__,
__list_mem__ -> __list_mem__,
check -> check,
station_list -> free_vars}
------Remainings in submission ------
{}
------Remainings in solution ------
{__list_filter__}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60547 : ?)

Decls : 
,Exp : Modify (60551 : ? (
fun (x : string) -> (? != ?)) (? (?)))

Decls : 

let rec __list_filter__ (pred : (#965249 -> bool)) (lst : #965249 list)  : #965193 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {station_list}
,Exp : Modify (60560 : 
let f_e1  : string list = ? (?)
 in 

let f_e2  : string list = ? (?)
 in 
? (?) (? (
fun (x : string) -> not (? (?) (?))) (?)))

Decls : 

let rec __list_filter__ (pred : (#965249 -> bool)) (lst : #965249 list)  : #965193 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {station_list}
,Exp : Modify (60578 : if (? (?) = []) then true
 else false)

Decls : 

let rec __list_filter__ (pred : (#965249 -> bool)) (lst : #965249 list)  : #965193 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {station_list}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60547 : ?)

Decls : 
,Exp : Modify (60551 : ? (
fun (x : string) -> (? != ?)) (? (?)))

Decls : 

let rec __list_filter__ (pred : (#965249 -> bool)) (lst : #965249 list)  : #965193 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {station_list}
,Exp : Modify (60560 : 
let f_e1  : string list = ? (?)
 in 

let f_e2  : string list = ? (?)
 in 
? (?) (? (
fun (x : string) -> not (? (?) (?))) (?)))

Decls : 

let rec __list_filter__ (pred : (#965249 -> bool)) (lst : #965249 list)  : #965193 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {station_list}
,Exp : Modify (60578 : if (? (?) = []) then true
 else false)

Decls : 

let rec __list_filter__ (pred : (#965249 -> bool)) (lst : #965249 list)  : #965193 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {station_list}
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/15/sub86.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun a -> 
 (match a with 
|V q -> false
|P (q, p) -> 
 (match p with 
|V x -> if (q = x) then true
 else false
|P (x, y) -> 
 (match y with 
|P (a, b) -> ((check (P ((a, b))) || check (P ((x, b)))) || check (P ((q, b))))
|V a -> ((a = x) || (a = q))
|C (a, b) -> 
 (match (a, b) with 
|(V a, V b) -> (((a = q) || (a = x)) && ((b = q) || (b = x)))
|(V a, P (c, d)) -> (((a = q) || (a = x)) && ((check (P ((c, d))) || check (P ((x, d)))) || check (P ((q, d)))))
|(P (a, b), V c) -> (((check (P ((a, b))) || check (P ((x, b)))) || check (P ((q, b)))) && ((c = q) || (c = x)))
|(P (a, b), P (c, d)) -> (((check (P ((a, b))) || check (P ((x, b)))) || check (P ((q, b)))) && ((check (P ((c, d))) || check (P ((x, d)))) || check (P ((q, d)))))
|(_, _) -> (check (a) && check (b))))
|C (x, y) -> 
 (match (x, y) with 
|(V a, V b) -> ((a = q) && (b = q))
|(V a, P (c, d)) -> ((a = q) && (check (P ((c, d))) || check (P ((q, d)))))
|(P (a, b), V c) -> ((check (P ((a, b))) || check (P ((q, b)))) && (c = q))
|(P (a, b), P (c, d)) -> ((check (P ((a, b))) || check (P ((q, b)))) && (check (P ((c, d))) || check (P ((q, d)))))
|(_, _) -> (check (x) && check (y))))
|C (q, p) -> (check (q) && check (p)))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = (60795, 
fun a -> (60794, 
 (match (60546, a with 
|V q -> (60547, false
|P (q, p) -> (60786, 
 (match (60548, p with 
|V x -> (60554, if (60551, ((60549, q = (60550, x) then (60552, true
 else (60553, false
|P (x, y) -> (60706, 
 (match (60555, y with 
|P (a, b) -> (60575, ((60568, ((60561, (60556, check ((60560, P ((60559, ((60557, a, (60558, b))) || (60567, (60562, check ((60566, P ((60565, ((60563, x, (60564, b)))) || (60574, (60569, check ((60573, P ((60572, ((60570, q, (60571, b))))
|V a -> (60582, ((60578, ((60576, a = (60577, x) || (60581, ((60579, a = (60580, q))
|C (a, b) -> (60705, 
 (match (60585, ((60583, a, (60584, b) with 
|(V a, V b) -> (60600, ((60592, ((60588, ((60586, a = (60587, q) || (60591, ((60589, a = (60590, x)) && (60599, ((60595, ((60593, b = (60594, q) || (60598, ((60596, b = (60597, x)))
|(V a, P (c, d)) -> (60628, ((60607, ((60603, ((60601, a = (60602, q) || (60606, ((60604, a = (60605, x)) && (60627, ((60620, ((60613, (60608, check ((60612, P ((60611, ((60609, c, (60610, d))) || (60619, (60614, check ((60618, P ((60617, ((60615, x, (60616, d)))) || (60626, (60621, check ((60625, P ((60624, ((60622, q, (60623, d)))))
|(P (a, b), V c) -> (60656, ((60648, ((60641, ((60634, (60629, check ((60633, P ((60632, ((60630, a, (60631, b))) || (60640, (60635, check ((60639, P ((60638, ((60636, x, (60637, b)))) || (60647, (60642, check ((60646, P ((60645, ((60643, q, (60644, b)))) && (60655, ((60651, ((60649, c = (60650, q) || (60654, ((60652, c = (60653, x)))
|(P (a, b), P (c, d)) -> (60697, ((60676, ((60669, ((60662, (60657, check ((60661, P ((60660, ((60658, a, (60659, b))) || (60668, (60663, check ((60667, P ((60666, ((60664, x, (60665, b)))) || (60675, (60670, check ((60674, P ((60673, ((60671, q, (60672, b)))) && (60696, ((60689, ((60682, (60677, check ((60681, P ((60680, ((60678, c, (60679, d))) || (60688, (60683, check ((60687, P ((60686, ((60684, x, (60685, d)))) || (60695, (60690, check ((60694, P ((60693, ((60691, q, (60692, d)))))
|(_, _) -> (60704, ((60700, (60698, check ((60699, a) && (60703, (60701, check ((60702, b))))
|C (x, y) -> (60785, 
 (match (60709, ((60707, x, (60708, y) with 
|(V a, V b) -> (60716, ((60712, ((60710, a = (60711, q) && (60715, ((60713, b = (60714, q))
|(V a, P (c, d)) -> (60733, ((60719, ((60717, a = (60718, q) && (60732, ((60725, (60720, check ((60724, P ((60723, ((60721, c, (60722, d))) || (60731, (60726, check ((60730, P ((60729, ((60727, q, (60728, d)))))
|(P (a, b), V c) -> (60750, ((60746, ((60739, (60734, check ((60738, P ((60737, ((60735, a, (60736, b))) || (60745, (60740, check ((60744, P ((60743, ((60741, q, (60742, b)))) && (60749, ((60747, c = (60748, q))
|(P (a, b), P (c, d)) -> (60777, ((60763, ((60756, (60751, check ((60755, P ((60754, ((60752, a, (60753, b))) || (60762, (60757, check ((60761, P ((60760, ((60758, q, (60759, b)))) && (60776, ((60769, (60764, check ((60768, P ((60767, ((60765, c, (60766, d))) || (60775, (60770, check ((60774, P ((60773, ((60771, q, (60772, d)))))
|(_, _) -> (60784, ((60780, (60778, check ((60779, x) && (60783, (60781, check ((60782, y))))
|C (q, p) -> (60793, ((60789, (60787, check ((60788, q) && (60792, (60790, check ((60791, p)))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : (a : lambda) 
Output : bool
Body : 
 (match a with 
|V q -> false
|P (q, p) -> 
 (match p with 
|V x -> if (q = x) then true
 else false
|P (x, y) -> 
 (match y with 
|P (a, b) -> ((check (P ((a, b))) || check (P ((x, b)))) || check (P ((q, b))))
|V a -> ((a = x) || (a = q))
|C (a, b) -> 
 (match (a, b) with 
|(V a, V b) -> (((a = q) || (a = x)) && ((b = q) || (b = x)))
|(V a, P (c, d)) -> (((a = q) || (a = x)) && ((check (P ((c, d))) || check (P ((x, d)))) || check (P ((q, d)))))
|(P (a, b), V c) -> (((check (P ((a, b))) || check (P ((x, b)))) || check (P ((q, b)))) && ((c = q) || (c = x)))
|(P (a, b), P (c, d)) -> (((check (P ((a, b))) || check (P ((x, b)))) || check (P ((q, b)))) && ((check (P ((c, d))) || check (P ((x, d)))) || check (P ((q, d)))))
|(_, _) -> (check (a) && check (b))))
|C (x, y) -> 
 (match (x, y) with 
|(V a, V b) -> ((a = q) && (b = q))
|(V a, P (c, d)) -> ((a = q) && (check (P ((c, d))) || check (P ((q, d)))))
|(P (a, b), V c) -> ((check (P ((a, b))) || check (P ((q, b)))) && (c = q))
|(P (a, b), P (c, d)) -> ((check (P ((a, b))) || check (P ((q, b)))) && (check (P ((c, d))) || check (P ((q, d)))))
|(_, _) -> (check (x) && check (y))))
|C (q, p) -> (check (q) && check (p)))}
Edge : 
{(45777, 45777) -> }
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60794 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60794 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun a -> checking (a) ([])

Time : 0.0014820098877
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/17/sub140.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun m -> 
 (match m with 
|V _ -> false
|C _ -> false
|P (n', m') -> __list_mem__ (n') (listMetro (m')))
and listMetro  : (lambda -> a list) = 
fun m -> 
 (match m with 
|V m' -> [m']
|C (m1, m2) -> 
 (match (listMetro (m1), listMetro (m2)) with 
|(a::b, c::d) -> __list_append__ ((a :: b)) ((c :: d))
|(_, _) -> [])
|P (n', m') -> 
 (match check (m) with 
|true -> listMetro (m')
|false -> []))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = (60557, 
fun m -> (60556, 
 (match (60546, m with 
|V _ -> (60547, false
|C _ -> (60548, false
|P (n', m') -> (60555, (60554, (60549, __list_mem__ ((60550, n') ((60553, (60551, listMetro ((60552, m')))
and listMetro  : (lambda -> a list) = (60588, 
fun m -> (60587, 
 (match (60558, m with 
|V m' -> (60560, [(60559, m']
|C (m1, m2) -> (60578, 
 (match (60567, ((60563, (60561, listMetro ((60562, m1), (60566, (60564, listMetro ((60565, m2)) with 
|(a::b, c::d) -> (60576, (60575, (60568, __list_append__ ((60571, ((60569, a :: (60570, b)) ((60574, ((60572, c :: (60573, d))
|(_, _) -> (60577, [])
|P (n', m') -> (60586, 
 (match (60581, (60579, check ((60580, m) with 
|true -> (60584, (60582, listMetro ((60583, m')
|false -> (60585, []))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_15/sub65.ml Score : 3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec free_vars  = 
fun __fun__ -> 
 (match __fun__ with 
|V v -> [v]
|P (v, e) -> __list_filter__ (
fun x -> (x != v)) (free_vars (e))
|C (e1, e2) -> 
let f_e1  = free_vars (e1)
 in 

let f_e2  = free_vars (e2)
 in 
__list_append__ (f_e1) (__list_filter__ (
fun x -> not (__list_mem__ (x) (f_e1))) (f_e2)))

let rec fresh_var v1 l  = if __list_mem__ (v1) (l) then fresh_var ((v1 ^ "'")) (l)
 else v1

let check  : (lambda -> bool) = 
fun e -> if (free_vars (e) = []) then true
 else false

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{__list_append__ -> (47079 : 
Input : (lst1 : #984243 list) (lst2 : #984243 list) 
Output : #984180 list
Body : (lst1 @ lst2),

__list_mem__ -> (47076 : 
Input : elem (lst : #984212 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (47101 : 
Input : (m : lambda) 
Output : bool
Body : 
 (match m with 
|V _ -> false
|C _ -> false
|P (n', m') -> __list_mem__ (n') (listMetro (m'))),

listMetro -> (47102 : 
Input : (m : lambda) 
Output : #984180 list
Body : 
 (match m with 
|V m' -> [m']
|C (m1, m2) -> 
 (match (listMetro (m1), listMetro (m2)) with 
|(a::b, c::d) -> __list_append__ ((a :: b)) ((c :: d))
|(_, _) -> [])
|P (n', m') -> 
 (match check (m) with 
|true -> listMetro (m')
|false -> []))}
Edge : 
{(47076, 47076) -> ,
(47101, 47076) -> ,
(47101, 47102) -> ,
(47102, 47079) -> ,
(47102, 47101) -> ,
(47102, 47102) -> }
Starting : 47101
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{__list_append__ -> (47042 : 
Input : (lst1 : #983520 list) (lst2 : #983520 list) 
Output : #983457 list
Body : (lst1 @ lst2),

__list_filter__ -> (47041 : 
Input : (pred : (#983513 -> bool)) (lst : #983513 list) 
Output : #983457 list
Body : 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl)),

__list_mem__ -> (47039 : 
Input : elem (lst : #983489 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (47066 : 
Input : (e : lambda) 
Output : bool
Body : if (free_vars (e) = []) then true
 else false,

free_vars -> (47064 : 
Input : (__fun__ : lambda) 
Output : string list
Body : 
 (match __fun__ with 
|V v -> [v]
|P (v, e) -> __list_filter__ (
fun (x : string) -> (x != v)) (free_vars (e))
|C (e1, e2) -> 
let f_e1  : string list = free_vars (e1)
 in 

let f_e2  : string list = free_vars (e2)
 in 
__list_append__ (f_e1) (__list_filter__ (
fun (x : string) -> not (__list_mem__ (x) (f_e1))) (f_e2)))}
Edge : 
{(47039, 47039) -> ,
(47041, 47041) -> ,
(47064, 47039) -> ,
(47064, 47041) -> ,
(47064, 47042) -> ,
(47064, 47064) -> ,
(47066, 47064) -> }
Starting : 47066
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{__list_append__ -> __list_append__,
__list_mem__ -> __list_mem__,
check -> check,
listMetro -> free_vars}
------Remainings in submission ------
{}
------Remainings in solution ------
{__list_filter__}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60556 : if (? (?) = []) then true
 else false)

Decls : 

let rec __list_filter__ (pred : (#986465 -> bool)) (lst : #986465 list)  : #986409 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {listMetro}
,Exp : Modify (60558 : ?)

Decls : 
,Exp : Modify (60559 : ?)

Decls : 
,Exp : Modify (60578 : 
let f_e1  : string list = ? (?)
 in 

let f_e2  : string list = ? (?)
 in 
? (?) (? (
fun (x : string) -> not (? (?) (?))) (?)))

Decls : 

let rec __list_filter__ (pred : (#986465 -> bool)) (lst : #986465 list)  : #986409 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {listMetro}
,Exp : Modify (60586 : ? (
fun (x : string) -> (? != ?)) (? (?)))

Decls : 

let rec __list_filter__ (pred : (#986465 -> bool)) (lst : #986465 list)  : #986409 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {listMetro}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60556 : if (? (?) = []) then true
 else false)

Decls : 

let rec __list_filter__ (pred : (#986465 -> bool)) (lst : #986465 list)  : #986409 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {listMetro}
,Exp : Modify (60558 : ?)

Decls : 
,Exp : Modify (60559 : ?)

Decls : 
,Exp : Modify (60578 : 
let f_e1  : string list = ? (?)
 in 

let f_e2  : string list = ? (?)
 in 
? (?) (? (
fun (x : string) -> not (? (?) (?))) (?)))

Decls : 

let rec __list_filter__ (pred : (#986465 -> bool)) (lst : #986465 list)  : #986409 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {listMetro}
,Exp : Modify (60586 : ? (
fun (x : string) -> (? != ?)) (? (?)))

Decls : 

let rec __list_filter__ (pred : (#986465 -> bool)) (lst : #986465 list)  : #986409 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {listMetro}
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/17/sub30.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V s -> false
|P (n, m) -> 
 (match m with 
|V s -> if (n = s) then true
 else false
|P (n, m) -> check (P ((n, m)))
|C (m1, m2) -> (check (P ((n, m1))) || check (P ((n, m2)))))
|C (m1, m2) -> false)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = (60577, 
fun lambda -> (60576, 
 (match (60546, lambda with 
|V s -> (60547, false
|P (n, m) -> (60574, 
 (match (60548, m with 
|V s -> (60554, if (60551, ((60549, n = (60550, s) then (60552, true
 else (60553, false
|P (n, m) -> (60560, (60555, check ((60559, P ((60558, ((60556, n, (60557, m)))
|C (m1, m2) -> (60573, ((60566, (60561, check ((60565, P ((60564, ((60562, n, (60563, m1))) || (60572, (60567, check ((60571, P ((60570, ((60568, n, (60569, m2)))))
|C (m1, m2) -> (60575, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|V s -> false
|P (n, m) -> 
 (match m with 
|V s -> if (n = s) then true
 else false
|P (n, m) -> check (P ((n, m)))
|C (m1, m2) -> (check (P ((n, m1))) || check (P ((n, m2)))))
|C (m1, m2) -> false)}
Edge : 
{(45777, 45777) -> }
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60576 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60576 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lambda -> checking (lambda) ([])

Time : 0.00143003463745
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/17/sub46.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V _ -> false
|P (a, b) -> true
|C (a, b) -> true)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = (60551, 
fun lambda -> (60550, 
 (match (60546, lambda with 
|V _ -> (60547, false
|P (a, b) -> (60548, true
|C (a, b) -> (60549, true)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|V _ -> false
|P (a, b) -> true
|C (a, b) -> true)}
Edge : 
empty
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60550 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60550 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lambda -> checking (lambda) ([])

Time : 0.00144791603088
Error occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/17/sub6.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/17/sub85.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check (m : lambda)  : bool = 
 (match m with 
|V n -> true
|C (m1, m2) -> (check (m1) && check (m2))
|P (n, m) -> 
 (match m with 
|V n2 -> if (n = n2) then true
 else false
|_ -> check (m)))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check (m : lambda)  : bool = (60566, 
 (match (60546, m with 
|V n -> (60547, true
|C (m1, m2) -> (60554, ((60550, (60548, check ((60549, m1) && (60553, (60551, check ((60552, m2))
|P (n, m) -> (60565, 
 (match (60555, m with 
|V n2 -> (60561, if (60558, ((60556, n = (60557, n2) then (60559, true
 else (60560, false
|_ -> (60564, (60562, check ((60563, m)))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : (m : lambda) 
Output : bool
Body : 
 (match m with 
|V n -> true
|C (m1, m2) -> (check (m1) && check (m2))
|P (n, m) -> 
 (match m with 
|V n2 -> if (n = n2) then true
 else false
|_ -> check (m)))}
Edge : 
{(45777, 45777) -> }
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60566 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60566 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check (m : lambda)  : bool = checking (m) ([])

Time : 0.00149083137512
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/17/sub87.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun x -> 
 (match x with 
|P (n, V n1) -> if (n1 = n) then true
 else false
|P (n, P (n1, m)) -> (check (P ((n, m))) && check (P ((n1, m))))
|P (n, C (V m1, V m2)) -> if ((n = m1) || (n = m2)) then true
 else false
|P (n, C (P (n1, m1), V n2)) -> if (((n = n2) || (n1 = n2)) && (check (P ((n, m1))) || check (P ((n1, m1))))) then true
 else false
|P (n, C (V n2, P (n1, m1))) -> if (((n = n2) || (n1 = n2)) && (check (P ((n, m1))) || check (P ((n1, m1))))) then true
 else false
|C (P (n1, m1), P (n2, m2)) -> if ((check (P ((n1, m1))) || check (P ((n2, m1)))) && (check (P ((n1, m2))) || check (P ((n2, m2))))) then true
 else false
|V n -> false)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = (60656, 
fun x -> (60655, 
 (match (60546, x with 
|P (n, V n1) -> (60552, if (60549, ((60547, n1 = (60548, n) then (60550, true
 else (60551, false
|P (n, P (n1, m)) -> (60565, ((60558, (60553, check ((60557, P ((60556, ((60554, n, (60555, m))) && (60564, (60559, check ((60563, P ((60562, ((60560, n1, (60561, m))))
|P (n, C (V m1, V m2)) -> (60575, if (60572, ((60568, ((60566, n = (60567, m1) || (60571, ((60569, n = (60570, m2)) then (60573, true
 else (60574, false
|P (n, C (P (n1, m1), V n2)) -> (60599, if (60596, ((60582, ((60578, ((60576, n = (60577, n2) || (60581, ((60579, n1 = (60580, n2)) && (60595, ((60588, (60583, check ((60587, P ((60586, ((60584, n, (60585, m1))) || (60594, (60589, check ((60593, P ((60592, ((60590, n1, (60591, m1))))) then (60597, true
 else (60598, false
|P (n, C (V n2, P (n1, m1))) -> (60623, if (60620, ((60606, ((60602, ((60600, n = (60601, n2) || (60605, ((60603, n1 = (60604, n2)) && (60619, ((60612, (60607, check ((60611, P ((60610, ((60608, n, (60609, m1))) || (60618, (60613, check ((60617, P ((60616, ((60614, n1, (60615, m1))))) then (60621, true
 else (60622, false
|C (P (n1, m1), P (n2, m2)) -> (60653, if (60650, ((60636, ((60629, (60624, check ((60628, P ((60627, ((60625, n1, (60626, m1))) || (60635, (60630, check ((60634, P ((60633, ((60631, n2, (60632, m1)))) && (60649, ((60642, (60637, check ((60641, P ((60640, ((60638, n1, (60639, m2))) || (60648, (60643, check ((60647, P ((60646, ((60644, n2, (60645, m2))))) then (60651, true
 else (60652, false
|V n -> (60654, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : (x : lambda) 
Output : bool
Body : 
 (match x with 
|P (n, V n1) -> if (n1 = n) then true
 else false
|P (n, P (n1, m)) -> (check (P ((n, m))) && check (P ((n1, m))))
|P (n, C (V m1, V m2)) -> if ((n = m1) || (n = m2)) then true
 else false
|P (n, C (P (n1, m1), V n2)) -> if (((n = n2) || (n1 = n2)) && (check (P ((n, m1))) || check (P ((n1, m1))))) then true
 else false
|P (n, C (V n2, P (n1, m1))) -> if (((n = n2) || (n1 = n2)) && (check (P ((n, m1))) || check (P ((n1, m1))))) then true
 else false
|C (P (n1, m1), P (n2, m2)) -> if ((check (P ((n1, m1))) || check (P ((n2, m1)))) && (check (P ((n1, m2))) || check (P ((n2, m2))))) then true
 else false
|V n -> false)}
Edge : 
{(45777, 45777) -> }
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60655 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60655 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun x -> checking (x) ([])

Time : 0.0014820098877
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/17/sub89.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec matchid ((x : string), (l : string list))  : bool = 
 (match l with 
|[] -> false
|hd::tl -> if (hd = x) then true
 else matchid ((x, tl)))

let rec ckMetro ((m : lambda), (idl : string list))  : bool = 
 (match m with 
|V x -> matchid ((x, idl))
|P (id, V x) -> ckMetro ((V (x), (id :: idl)))
|P (id, some) -> ckMetro ((some, (id :: idl)))
|C (V x, V y) -> (matchid ((x, idl)) && matchid ((y, idl)))
|C (V x, some) -> if matchid ((x, idl)) then ckMetro ((some, idl))
 else false
|C (x, y) -> (ckMetro ((x, idl)) && ckMetro ((y, []))))

let rec check (m : lambda)  : bool = ckMetro ((m, []))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec matchid ((x : string), (l : string list))  : bool = (60558, 
 (match (60546, l with 
|[] -> (60547, false
|hd::tl -> (60557, if (60550, ((60548, hd = (60549, x) then (60551, true
 else (60556, (60552, matchid ((60555, ((60553, x, (60554, tl)))

let rec ckMetro ((m : lambda), (idl : string list))  : bool = (60614, 
 (match (60559, m with 
|V x -> (60564, (60560, matchid ((60563, ((60561, x, (60562, idl))
|P (id, V x) -> (60572, (60565, ckMetro ((60571, ((60567, V ((60566, x), (60570, ((60568, id :: (60569, idl)))
|P (id, some) -> (60579, (60573, ckMetro ((60578, ((60574, some, (60577, ((60575, id :: (60576, idl)))
|C (V x, V y) -> (60590, ((60584, (60580, matchid ((60583, ((60581, x, (60582, idl)) && (60589, (60585, matchid ((60588, ((60586, y, (60587, idl)))
|C (V x, some) -> (60602, if (60595, (60591, matchid ((60594, ((60592, x, (60593, idl)) then (60600, (60596, ckMetro ((60599, ((60597, some, (60598, idl))
 else (60601, false
|C (x, y) -> (60613, ((60607, (60603, ckMetro ((60606, ((60604, x, (60605, idl)) && (60612, (60608, ckMetro ((60611, ((60609, y, (60610, []))))

let rec check (m : lambda)  : bool = (60619, (60615, ckMetro ((60618, ((60616, m, (60617, []))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_16/sub97.ml Score : 3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec mem  : ((var * var list) -> bool) = 
fun (key, lst) -> 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = key) then true
 else (false || mem ((key, tl))))

let check  : (lambda -> bool) = 
fun lambda -> 
let rec ch  : ((lambda * var list) -> bool) = 
fun (lambda, lst) -> 
 (match lambda with 
|V x -> mem ((x, lst))
|P (x, p) -> ch ((p, (x :: lst)))
|C (p, q) -> (ch ((p, lst)) && ch ((q, lst))))
 in 
ch ((lambda, []))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (48425 : 
Input : (m : lambda) 
Output : bool
Body : ckMetro ((m, [])),

ckMetro -> (48424 : 
Input : ((m : lambda), (idl : string list)) 
Output : bool
Body : 
 (match m with 
|V x -> matchid ((x, idl))
|P (id, V x) -> ckMetro ((V (x), (id :: idl)))
|P (id, some) -> ckMetro ((some, (id :: idl)))
|C (V x, V y) -> (matchid ((x, idl)) && matchid ((y, idl)))
|C (V x, some) -> if matchid ((x, idl)) then ckMetro ((some, idl))
 else false
|C (x, y) -> (ckMetro ((x, idl)) && ckMetro ((y, [])))),

matchid -> (48423 : 
Input : ((x : string), (l : string list)) 
Output : bool
Body : 
 (match l with 
|[] -> false
|hd::tl -> if (hd = x) then true
 else matchid ((x, tl)))}
Edge : 
{(48423, 48423) -> ,
(48424, 48423) -> ,
(48424, 48424) -> ,
(48425, 48424) -> }
Starting : 48425
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{ch -> (48388 : 
Input : ((lambda : lambda), (lst : string list)) 
Output : bool
Body : 
 (match lambda with 
|V x -> mem ((x, lst))
|P (x, p) -> ch ((p, (x :: lst)))
|C (p, q) -> (ch ((p, lst)) && ch ((q, lst)))),

check -> (48387 : 
Input : (lambda : lambda) 
Output : bool
Body : ch ((lambda, [])),

mem -> (48386 : 
Input : (key, (lst : #1007682 list)) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = key) then true
 else (false || mem ((key, tl))))}
Edge : 
{(48386, 48386) -> ,
(48387, 48388) -> ,
(48388, 48386) -> ,
(48388, 48388) -> }
Starting : 48387
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
ckMetro -> ch,
matchid -> mem}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60548 : ?)

Decls : 
,Exp : Modify (60549 : ?)

Decls : 
,Exp : Modify (60556 : (false || ? ((?, ?))))

Decls : 
,Exp : Modify (60559 : ?)

Decls : 
,Exp : Modify (60564 : ? ((?, ?)))

Decls : 
,Exp : Modify (60579 : ? ((?, (? :: ?))))

Decls : 
,Exp : Modify (60607 : ? ((?, ?)))

Decls : 
,Exp : Modify (60612 : ? ((?, ?)))

Decls : 
,Exp : Modify (60619 : ? ((?, [])))

Decls : 
,Exp : Delete (C (V x, some) -> if matchid ((x, idl)) then ckMetro ((some, idl))
 else false At label 60614

Decls : 
,Exp : Delete (C (V x, V y) -> (matchid ((x, idl)) && matchid ((y, idl))) At label 60614

Decls : 
,Exp : Delete (P (id, V x) -> ckMetro ((V (x), (id :: idl))) At label 60614

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60548 : ?)

Decls : 
,Exp : Modify (60549 : ?)

Decls : 
,Exp : Modify (60556 : (false || ? ((?, ?))))

Decls : 
,Exp : Modify (60559 : ?)

Decls : 
,Exp : Modify (60564 : ? ((?, ?)))

Decls : 
,Exp : Modify (60579 : ? ((?, (? :: ?))))

Decls : 
,Exp : Modify (60607 : ? ((?, ?)))

Decls : 
,Exp : Modify (60612 : ? ((?, ?)))

Decls : 
,Exp : Modify (60619 : ? ((?, [])))

Decls : 
,Exp : Delete (C (V x, some) -> if matchid ((x, idl)) then ckMetro ((some, idl))
 else false At label 60614

Decls : 
,Exp : Delete (C (V x, V y) -> (matchid ((x, idl)) && matchid ((y, idl))) At label 60614

Decls : 
,Exp : Delete (P (id, V x) -> ckMetro ((V (x), (id :: idl))) At label 60614

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec matchid ((x : string), (l : string list))  : bool = 
 (match l with 
|[] -> false
|hd::tl -> if (hd = x) then true
 else matchid ((x, tl)))

let rec ckMetro ((m : lambda), (idl : string list))  : bool = 
 (match m with 
|V x -> matchid ((x, idl))
|P (id, V x) -> ckMetro ((V (x), (id :: idl)))
|P (id, some) -> ckMetro ((some, (id :: idl)))
|C (V x, V y) -> (matchid ((x, idl)) && matchid ((y, idl)))
|C (V x, some) -> if matchid ((x, idl)) then ckMetro ((some, idl))
 else false
|C (x, y) -> (ckMetro ((x, idl)) && ckMetro ((y, idl))))

let rec check (m : lambda)  : bool = ckMetro ((m, []))

Time : 0.0061399936676
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub14.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec envmt  : (lambda -> string list) = 
fun e -> 
let lst  = []
 in 

 (match e with 
|V v -> lst
|P (v, lambdar) -> ((v :: envmt (lambdar)) @ lst)
|C (lambda1, lambda2) -> (envmt (lambda1) @ (envmt (lambda2) @ lst)))

let rec exist  : ((lambda * string list) -> int) = 
fun (e, lst) -> 
 (match e with 
|V v -> 
 (match lst with 
|[] -> 0
|hd::tl -> if (hd = v) then (1 + exist ((e, tl)))
 else exist ((e, tl)))
|P (v, lambda1) -> exist ((lambda1, lst))
|C (lambda1, lambda2) -> (exist ((lambda1, lst)) + exist ((lambda2, lst))))

let check  : (lambda -> bool) = 
fun e -> 
let env  = envmt (e)
 in 
if (exist ((e, env)) = 0) then false
 else if (__list_length__ (env) > exist ((e, env))) then false
 else true

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec envmt  : (lambda -> string list) = (60567, 
fun e -> (60566, 
let lst  = (60546, []
 in 
(60565, 
 (match (60547, e with 
|V v -> (60548, lst
|P (v, lambdar) -> (60555, ((60553, ((60549, v :: (60552, (60550, envmt ((60551, lambdar)) @ (60554, lst)
|C (lambda1, lambda2) -> (60564, ((60558, (60556, envmt ((60557, lambda1) @ (60563, ((60561, (60559, envmt ((60560, lambda2) @ (60562, lst)))

let rec exist  : ((lambda * string list) -> int) = (60605, 
fun (e, lst) -> (60604, 
 (match (60568, e with 
|V v -> (60587, 
 (match (60569, lst with 
|[] -> (60570, 0
|hd::tl -> (60586, if (60573, ((60571, hd = (60572, v) then (60580, ((60574, 1 + (60579, (60575, exist ((60578, ((60576, e, (60577, tl)))
 else (60585, (60581, exist ((60584, ((60582, e, (60583, tl)))
|P (v, lambda1) -> (60592, (60588, exist ((60591, ((60589, lambda1, (60590, lst))
|C (lambda1, lambda2) -> (60603, ((60597, (60593, exist ((60596, ((60594, lambda1, (60595, lst)) + (60602, (60598, exist ((60601, ((60599, lambda2, (60600, lst))))

let check  : (lambda -> bool) = (60631, 
fun e -> (60630, 
let env  = (60608, (60606, envmt ((60607, e)
 in 
(60629, if (60615, ((60613, (60609, exist ((60612, ((60610, e, (60611, env)) = (60614, 0) then (60616, false
 else (60628, if (60625, ((60619, (60617, __list_length__ ((60618, env) > (60624, (60620, exist ((60623, ((60621, e, (60622, env))) then (60626, false
 else (60627, true

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/13/sub51.ml Score : 1
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec list_del lst element  = 
 (match lst with 
|[] -> []
|head::tail -> if (head = element) then list_del (tail) (element)
 else (head :: list_del (tail) (element)))

let rec remainStation m  = 
 (match m with 
|V str -> [str]
|P (str, met) -> list_del (remainStation (met)) (str)
|C (met1, met2) -> (remainStation (met1) @ remainStation (met2)))

let rec check m  = if (__list_length__ (remainStation (m)) = 0) then true
 else false

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{__list_length__ -> (48402 : 
Input : (lst : #998794 list) 
Output : int
Body : 
 (match lst with 
|[] -> 0
|_::tl -> (1 + __list_length__ (tl))),

check -> (48425 : 
Input : (e : lambda) 
Output : bool
Body : 
let env  : string list = envmt (e)
 in 
if (exist ((e, env)) = 0) then false
 else if (__list_length__ (env) > exist ((e, env))) then false
 else true,

envmt -> (48423 : 
Input : (e : lambda) 
Output : string list
Body : 
let lst  : string list = []
 in 

 (match e with 
|V v -> lst
|P (v, lambdar) -> ((v :: envmt (lambdar)) @ lst)
|C (lambda1, lambda2) -> (envmt (lambda1) @ (envmt (lambda2) @ lst))),

exist -> (48424 : 
Input : ((e : lambda), (lst : string list)) 
Output : int
Body : 
 (match e with 
|V v -> 
 (match lst with 
|[] -> 0
|hd::tl -> if (hd = v) then (1 + exist ((e, tl)))
 else exist ((e, tl)))
|P (v, lambda1) -> exist ((lambda1, lst))
|C (lambda1, lambda2) -> (exist ((lambda1, lst)) + exist ((lambda2, lst))))}
Edge : 
{(48402, 48402) -> ,
(48423, 48423) -> ,
(48424, 48424) -> ,
(48425, 48402) -> ,
(48425, 48423) -> ,
(48425, 48424) -> }
Starting : 48425
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{__list_length__ -> (48365 : 
Input : (lst : #998071 list) 
Output : int
Body : 
 (match lst with 
|[] -> 0
|_::tl -> (1 + __list_length__ (tl))),

check -> (48388 : 
Input : (m : lambda) 
Output : bool
Body : if (__list_length__ (remainStation (m)) = 0) then true
 else false,

list_del -> (48386 : 
Input : (lst : #4657 list) (element : string) 
Output : #4657 list
Body : 
 (match lst with 
|[] -> []
|head::tail -> if (head = element) then list_del (tail) (element)
 else (head :: list_del (tail) (element))),

remainStation -> (48387 : 
Input : (m : lambda) 
Output : string list
Body : 
 (match m with 
|V str -> [str]
|P (str, met) -> list_del (remainStation (met)) (str)
|C (met1, met2) -> (remainStation (met1) @ remainStation (met2)))}
Edge : 
{(48365, 48365) -> ,
(48386, 48386) -> ,
(48387, 48386) -> ,
(48387, 48387) -> ,
(48388, 48365) -> ,
(48388, 48387) -> }
Starting : 48388
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{__list_length__ -> __list_length__,
check -> check,
envmt -> remainStation}
------Remainings in submission ------
{exist}
------Remainings in solution ------
{list_del}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60566 : 
 (match ? with 
|V str -> [?]
|P (str, met) -> ? (? (?)) (?)
|C (met1, met2) -> (? (?) @ ? (?))))

Decls : 

let rec list_del (lst : #4657 list) (element : string)  : #4657 list = 
 (match lst with 
|[] -> []
|head::tail -> if (head = element) then list_del (tail) (element)
 else (head :: list_del (tail) (element)))

Callers : {envmt}
,Exp : Modify (60630 : if (? (? (?)) = 0) then true
 else false)

Decls : 

let rec list_del (lst : #4657 list) (element : string)  : #4657 list = 
 (match lst with 
|[] -> []
|head::tail -> if (head = element) then list_del (tail) (element)
 else (head :: list_del (tail) (element)))

Callers : {envmt}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60566 : 
 (match ? with 
|V str -> [?]
|P (str, met) -> ? (? (?)) (?)
|C (met1, met2) -> (? (?) @ ? (?))))

Decls : 

let rec list_del (lst : #4657 list) (element : string)  : #4657 list = 
 (match lst with 
|[] -> []
|head::tail -> if (head = element) then list_del (tail) (element)
 else (head :: list_del (tail) (element)))

Callers : {envmt}
,Exp : Modify (60630 : if (? (? (?)) = 0) then true
 else false)

Decls : 

let rec list_del (lst : #4657 list) (element : string)  : #4657 list = 
 (match lst with 
|[] -> []
|head::tail -> if (head = element) then list_del (tail) (element)
 else (head :: list_del (tail) (element)))

Callers : {envmt}
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub15.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec pcheck  : ((var list * lambda) -> bool) = 
fun (var, lambda) -> 
 (match lambda with 
|V evar -> __list_exists__ (
fun v -> (v = evar)) (var)
|P (v, lambda) -> pcheck (((v :: var), lambda))
|C (e1, e2) -> (pcheck ((var, e1)) && pcheck ((var, e2))))

let check  : (lambda -> bool) = 
fun e -> 
 (match e with 
|V v -> false
|P (v, lambda) -> pcheck (((v :: []), lambda))
|C (e1, e2) -> false)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec pcheck  : ((var list * lambda) -> bool) = (60574, 
fun (var, lambda) -> (60573, 
 (match (60546, lambda with 
|V evar -> (60554, (60553, (60547, __list_exists__ ((60551, 
fun v -> (60550, ((60548, v = (60549, evar)) ((60552, var)
|P (v, lambda) -> (60561, (60555, pcheck ((60560, ((60558, ((60556, v :: (60557, var), (60559, lambda))
|C (e1, e2) -> (60572, ((60566, (60562, pcheck ((60565, ((60563, var, (60564, e1)) && (60571, (60567, pcheck ((60570, ((60568, var, (60569, e2))))

let check  : (lambda -> bool) = (60586, 
fun e -> (60585, 
 (match (60575, e with 
|V v -> (60576, false
|P (v, lambda) -> (60583, (60577, pcheck ((60582, ((60580, ((60578, v :: (60579, []), (60581, lambda))
|C (e1, e2) -> (60584, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/17/sub95.ml Score : 3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec innerlambda  : ((var list * lambda) -> bool) = 
fun (area_list, input) -> 
 (match input with 
|C (a, b) -> (innerlambda ((area_list, a)) && innerlambda ((area_list, b)))
|P (a, b) -> if __list_exists__ (
fun x -> (a = x)) (area_list) then innerlambda ((area_list, b))
 else innerlambda (((a :: area_list), b))
|V a -> if __list_exists__ (
fun x -> (a = x)) (area_list) then true
 else false)

let check  : (lambda -> bool) = 
fun input -> 
let area_list  : var list = []
 in 
innerlambda ((area_list, input))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{__list_exists__ -> (47075 : 
Input : (pred : (#973654 -> bool)) (lst : #973654 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> (pred (hd) || __list_exists__ (pred) (tl))),

check -> (47100 : 
Input : (e : lambda) 
Output : bool
Body : 
 (match e with 
|V v -> false
|P (v, lambda) -> pcheck (((v :: []), lambda))
|C (e1, e2) -> false),

pcheck -> (47099 : 
Input : ((var : string list), (lambda : lambda)) 
Output : bool
Body : 
 (match lambda with 
|V evar -> __list_exists__ (
fun (v : string) -> (v = evar)) (var)
|P (v, lambda) -> pcheck (((v :: var), lambda))
|C (e1, e2) -> (pcheck ((var, e1)) && pcheck ((var, e2))))}
Edge : 
{(47075, 47075) -> ,
(47099, 47075) -> ,
(47099, 47099) -> ,
(47100, 47099) -> }
Starting : 47100
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{__list_exists__ -> (47040 : 
Input : (pred : (#972925 -> bool)) (lst : #972925 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> (pred (hd) || __list_exists__ (pred) (tl))),

check -> (47065 : 
Input : (input : lambda) 
Output : bool
Body : 
let area_list  : var list = []
 in 
innerlambda ((area_list, input)),

innerlambda -> (47064 : 
Input : ((area_list : string list), (input : lambda)) 
Output : bool
Body : 
 (match input with 
|C (a, b) -> (innerlambda ((area_list, a)) && innerlambda ((area_list, b)))
|P (a, b) -> if __list_exists__ (
fun (x : string) -> (a = x)) (area_list) then innerlambda ((area_list, b))
 else innerlambda (((a :: area_list), b))
|V a -> if __list_exists__ (
fun (x : string) -> (a = x)) (area_list) then true
 else false)}
Edge : 
{(47040, 47040) -> ,
(47064, 47040) -> ,
(47064, 47064) -> ,
(47065, 47064) -> }
Starting : 47065
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{__list_exists__ -> __list_exists__,
check -> check,
pcheck -> innerlambda}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60554 : if ? (
fun (x : string) -> (? = ?)) (?) then true
 else false)

Decls : 
,Exp : Modify (60561 : if ? (
fun (x : string) -> (? = ?)) (?) then ? ((?, ?))
 else ? (((? :: ?), ?)))

Decls : 
,Exp : Modify (60566 : ? ((?, ?)))

Decls : 
,Exp : Modify (60571 : ? ((?, ?)))

Decls : 
,Exp : Modify (60585 : 
let area_list  : var list = []
 in 
? ((?, ?)))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60585 : 
let area_list  : var list = []
 in 
? ((?, ?)))

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec pcheck  : ((var list * lambda) -> bool) = 
fun (var, lambda) -> 
 (match lambda with 
|V evar -> __list_exists__ (
fun v -> (v = evar)) (var)
|P (v, lambda) -> pcheck (((v :: var), lambda))
|C (e1, e2) -> (pcheck ((var, e1)) && pcheck ((var, e2))))

let check  : (lambda -> bool) = 
fun e -> 
let area_list  : var list = []
 in 
pcheck ((area_list, e))

Time : 0.00143313407898
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub16.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec look  : ((var * string list) -> bool) = 
fun (v, li) -> 
 (match li with 
|[] -> false
|h::t -> if (h = v) then true
 else look ((v, t)))

let rec add  : ((var * string list) -> string list) = 
fun (v, li) -> 
 (match li with 
|[] -> (li @ [v])
|h::t -> if (h = v) then li
 else ([h] @ add ((v, t))))

let rec collect1  : ((lambda * string list) -> string list) = 
fun (e, li) -> 
 (match e with 
|P (v, e1) -> collect1 ((e1, add ((v, li))))
|C (e1, e2) -> collect1 ((e2, collect1 ((e1, li))))
|V v1 -> li)

let rec collect2  : ((lambda * string list) -> string list) = 
fun (e, li) -> 
 (match e with 
|P (v, e1) -> collect2 ((e1, li))
|C (e1, e2) -> collect2 ((e2, collect2 ((e1, li))))
|V v1 -> add ((v1, li)))

let rec compare  : ((string list * string list) -> bool) = 
fun (li1, li2) -> 
 (match li2 with 
|[] -> true
|h::t -> (look ((h, li1)) && compare ((li1, t))))

let check  : (lambda -> bool) = 
fun e -> 
let li1  = collect1 ((e, []))
 in 

let li2  = collect2 ((e, []))
 in 
compare ((li1, li2))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec look  : ((var * string list) -> bool) = (60559, 
fun (v, li) -> (60558, 
 (match (60546, li with 
|[] -> (60547, false
|h::t -> (60557, if (60550, ((60548, h = (60549, v) then (60551, true
 else (60556, (60552, look ((60555, ((60553, v, (60554, t)))

let rec add  : ((var * string list) -> string list) = (60579, 
fun (v, li) -> (60578, 
 (match (60560, li with 
|[] -> (60564, ((60561, li @ (60563, [(60562, v])
|h::t -> (60577, if (60567, ((60565, h = (60566, v) then (60568, li
 else (60576, ((60570, [(60569, h] @ (60575, (60571, add ((60574, ((60572, v, (60573, t))))

let rec collect1  : ((lambda * string list) -> string list) = (60601, 
fun (e, li) -> (60600, 
 (match (60580, e with 
|P (v, e1) -> (60589, (60581, collect1 ((60588, ((60582, e1, (60587, (60583, add ((60586, ((60584, v, (60585, li))))
|C (e1, e2) -> (60598, (60590, collect1 ((60597, ((60591, e2, (60596, (60592, collect1 ((60595, ((60593, e1, (60594, li))))
|V v1 -> (60599, li)

let rec collect2  : ((lambda * string list) -> string list) = (60623, 
fun (e, li) -> (60622, 
 (match (60602, e with 
|P (v, e1) -> (60607, (60603, collect2 ((60606, ((60604, e1, (60605, li))
|C (e1, e2) -> (60616, (60608, collect2 ((60615, ((60609, e2, (60614, (60610, collect2 ((60613, ((60611, e1, (60612, li))))
|V v1 -> (60621, (60617, add ((60620, ((60618, v1, (60619, li)))

let rec compare  : ((string list * string list) -> bool) = (60638, 
fun (li1, li2) -> (60637, 
 (match (60624, li2 with 
|[] -> (60625, true
|h::t -> (60636, ((60630, (60626, look ((60629, ((60627, h, (60628, li1)) && (60635, (60631, compare ((60634, ((60632, li1, (60633, t))))

let check  : (lambda -> bool) = (60656, 
fun e -> (60655, 
let li1  = (60643, (60639, collect1 ((60642, ((60640, e, (60641, []))
 in 
(60654, 
let li2  = (60648, (60644, collect2 ((60647, ((60645, e, (60646, []))
 in 
(60653, (60649, compare ((60652, ((60650, li1, (60651, li2))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_16/sub97.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec mem  : ((var * var list) -> bool) = 
fun (key, lst) -> 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = key) then true
 else (false || mem ((key, tl))))

let check  : (lambda -> bool) = 
fun lambda -> 
let rec ch  : ((lambda * var list) -> bool) = 
fun (lambda, lst) -> 
 (match lambda with 
|V x -> mem ((x, lst))
|P (x, p) -> ch ((p, (x :: lst)))
|C (p, q) -> (ch ((p, lst)) && ch ((q, lst))))
 in 
ch ((lambda, []))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{add -> (52390 : 
Input : ((v : string), (li : string list)) 
Output : string list
Body : 
 (match li with 
|[] -> (li @ [v])
|h::t -> if (h = v) then li
 else ([h] @ add ((v, t)))),

check -> (52394 : 
Input : (e : lambda) 
Output : bool
Body : 
let li1  : string list = collect1 ((e, []))
 in 

let li2  : string list = collect2 ((e, []))
 in 
compare ((li1, li2)),

collect1 -> (52391 : 
Input : ((e : lambda), (li : string list)) 
Output : string list
Body : 
 (match e with 
|P (v, e1) -> collect1 ((e1, add ((v, li))))
|C (e1, e2) -> collect1 ((e2, collect1 ((e1, li))))
|V v1 -> li),

collect2 -> (52392 : 
Input : ((e : lambda), (li : string list)) 
Output : string list
Body : 
 (match e with 
|P (v, e1) -> collect2 ((e1, li))
|C (e1, e2) -> collect2 ((e2, collect2 ((e1, li))))
|V v1 -> add ((v1, li))),

compare -> (52393 : 
Input : ((li1 : #1038832 list), (li2 : #1038894 list)) 
Output : bool
Body : 
 (match li2 with 
|[] -> true
|h::t -> (look ((h, li1)) && compare ((li1, t)))),

look -> (52389 : 
Input : (v, (li : #1038832 list)) 
Output : bool
Body : 
 (match li with 
|[] -> false
|h::t -> if (h = v) then true
 else look ((v, t)))}
Edge : 
{(52389, 52389) -> ,
(52390, 52390) -> ,
(52391, 52390) -> ,
(52391, 52391) -> ,
(52392, 52390) -> ,
(52392, 52392) -> ,
(52393, 52389) -> ,
(52393, 52393) -> ,
(52394, 52391) -> ,
(52394, 52392) -> ,
(52394, 52393) -> }
Starting : 52394
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{ch -> (52354 : 
Input : ((lambda : lambda), (lst : string list)) 
Output : bool
Body : 
 (match lambda with 
|V x -> mem ((x, lst))
|P (x, p) -> ch ((p, (x :: lst)))
|C (p, q) -> (ch ((p, lst)) && ch ((q, lst)))),

check -> (52353 : 
Input : (lambda : lambda) 
Output : bool
Body : ch ((lambda, [])),

mem -> (52352 : 
Input : (key, (lst : #1038101 list)) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = key) then true
 else (false || mem ((key, tl))))}
Edge : 
{(52352, 52352) -> ,
(52353, 52354) -> ,
(52354, 52352) -> ,
(52354, 52354) -> }
Starting : 52353
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
compare -> mem,
look -> ch}
------Remainings in submission ------
{add,collect1,collect2}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60624 : ?)

Decls : 
,Exp : Modify (60625 : false)

Decls : 
,Exp : Modify (60636 : if (? = ?) then true
 else (false || ? ((?, ?))))

Decls : 
,Exp : Modify (60655 : ? ((?, [])))

Decls : 
,Exp : Insert (C (p, q) -> (? ((?, ?)) && ? ((?, ?))) At label 60558

Decls : 
,Exp : Insert (P (x, p) -> ? ((?, (? :: ?))) At label 60558

Decls : 
,Exp : Insert (V x -> ? ((?, ?)) At label 60558

Decls : 
,Exp : Delete ([] -> false At label 60558

Decls : 
,Exp : Delete (h::t -> if (h = v) then true
 else look ((v, t)) At label 60558

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60624 : ?)

Decls : 
,Exp : Modify (60625 : false)

Decls : 
,Exp : Modify (60636 : if (? = ?) then true
 else (false || ? ((?, ?))))

Decls : 
,Exp : Modify (60655 : ? ((?, [])))

Decls : 
,Exp : Insert (C (p, q) -> (? ((?, ?)) && ? ((?, ?))) At label 60558

Decls : 
,Exp : Insert (P (x, p) -> ? ((?, (? :: ?))) At label 60558

Decls : 
,Exp : Insert (V x -> ? ((?, ?)) At label 60558

Decls : 
,Exp : Delete ([] -> false At label 60558

Decls : 
,Exp : Delete (h::t -> if (h = v) then true
 else look ((v, t)) At label 60558

Decls : 
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub2.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec comblist  = 
fun (l1, l2) -> 
 (match l1 with 
|[] -> l2
|hd::tl -> (hd :: comblist ((tl, l2))))

let rec searchlist  : ((string * string list) -> bool) = 
fun (a, l) -> 
 (match l with 
|[] -> false
|hd::tl -> if (hd = a) then true
 else searchlist ((a, tl)))

let rec complist  : (string list -> string list) = 
fun l -> 
 (match l with 
|[] -> []
|hd::tl -> if searchlist ((hd, tl)) then complist (tl)
 else (hd :: tl))

let rec vars  : (lambda -> string list) = 
fun e -> 
 (match e with 
|V x -> [x]
|P (x, e1) -> vars (e1)
|C (e1, e2) -> comblist ((vars (e1), vars (e2))))

let rec used  : (lambda -> string list) = 
fun e -> 
 (match e with 
|V x -> []
|P (x, e1) -> (x :: used (e1))
|C (e1, e2) -> comblist ((used (e1), used (e2))))

let rec matchvar  : ((string list * string list) -> bool) = 
fun (vr, us) -> 
 (match (vr, us) with 
|([], _) -> true
|(hd::tl, us) -> if searchlist ((hd, us)) then matchvar ((tl, us))
 else false)

let check  : (lambda -> bool) = 
fun e -> matchvar ((complist (vars (e)), used (e)))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec comblist  = (60556, 
fun (l1, l2) -> (60555, 
 (match (60546, l1 with 
|[] -> (60547, l2
|hd::tl -> (60554, ((60548, hd :: (60553, (60549, comblist ((60552, ((60550, tl, (60551, l2))))

let rec searchlist  : ((string * string list) -> bool) = (60570, 
fun (a, l) -> (60569, 
 (match (60557, l with 
|[] -> (60558, false
|hd::tl -> (60568, if (60561, ((60559, hd = (60560, a) then (60562, true
 else (60567, (60563, searchlist ((60566, ((60564, a, (60565, tl)))

let rec complist  : (string list -> string list) = (60586, 
fun l -> (60585, 
 (match (60571, l with 
|[] -> (60572, []
|hd::tl -> (60584, if (60577, (60573, searchlist ((60576, ((60574, hd, (60575, tl)) then (60580, (60578, complist ((60579, tl)
 else (60583, ((60581, hd :: (60582, tl))

let rec vars  : (lambda -> string list) = (60603, 
fun e -> (60602, 
 (match (60587, e with 
|V x -> (60589, [(60588, x]
|P (x, e1) -> (60592, (60590, vars ((60591, e1)
|C (e1, e2) -> (60601, (60593, comblist ((60600, ((60596, (60594, vars ((60595, e1), (60599, (60597, vars ((60598, e2))))

let rec used  : (lambda -> string list) = (60621, 
fun e -> (60620, 
 (match (60604, e with 
|V x -> (60605, []
|P (x, e1) -> (60610, ((60606, x :: (60609, (60607, used ((60608, e1))
|C (e1, e2) -> (60619, (60611, comblist ((60618, ((60614, (60612, used ((60613, e1), (60617, (60615, used ((60616, e2))))

let rec matchvar  : ((string list * string list) -> bool) = (60639, 
fun (vr, us) -> (60638, 
 (match (60624, ((60622, vr, (60623, us) with 
|([], _) -> (60625, true
|(hd::tl, us) -> (60637, if (60630, (60626, searchlist ((60629, ((60627, hd, (60628, us)) then (60635, (60631, matchvar ((60634, ((60632, tl, (60633, us))
 else (60636, false)

let check  : (lambda -> bool) = (60651, 
fun e -> (60650, (60640, matchvar ((60649, ((60645, (60641, complist ((60644, (60642, vars ((60643, e)), (60648, (60646, used ((60647, e)))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_16/sub97.ml Score : -1
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec mem  : ((var * var list) -> bool) = 
fun (key, lst) -> 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = key) then true
 else (false || mem ((key, tl))))

let check  : (lambda -> bool) = 
fun lambda -> 
let rec ch  : ((lambda * var list) -> bool) = 
fun (lambda, lst) -> 
 (match lambda with 
|V x -> mem ((x, lst))
|P (x, p) -> ch ((p, (x :: lst)))
|C (p, q) -> (ch ((p, lst)) && ch ((q, lst))))
 in 
ch ((lambda, []))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (53717 : 
Input : (e : lambda) 
Output : bool
Body : matchvar ((complist (vars (e)), used (e))),

comblist -> (53711 : 
Input : ((l1 : #1040148 list), (l2 : #1040148 list)) 
Output : #1040148 list
Body : 
 (match l1 with 
|[] -> l2
|hd::tl -> (hd :: comblist ((tl, l2)))),

complist -> (53713 : 
Input : (l : string list) 
Output : string list
Body : 
 (match l with 
|[] -> []
|hd::tl -> if searchlist ((hd, tl)) then complist (tl)
 else (hd :: tl)),

matchvar -> (53716 : 
Input : ((vr : #1040218 list), (us : #1040161 list)) 
Output : bool
Body : 
 (match (vr, us) with 
|([], _) -> true
|(hd::tl, us) -> if searchlist ((hd, us)) then matchvar ((tl, us))
 else false),

searchlist -> (53712 : 
Input : (a, (l : #1040161 list)) 
Output : bool
Body : 
 (match l with 
|[] -> false
|hd::tl -> if (hd = a) then true
 else searchlist ((a, tl))),

used -> (53715 : 
Input : (e : lambda) 
Output : string list
Body : 
 (match e with 
|V x -> []
|P (x, e1) -> (x :: used (e1))
|C (e1, e2) -> comblist ((used (e1), used (e2)))),

vars -> (53714 : 
Input : (e : lambda) 
Output : string list
Body : 
 (match e with 
|V x -> [x]
|P (x, e1) -> vars (e1)
|C (e1, e2) -> comblist ((vars (e1), vars (e2))))}
Edge : 
{(53711, 53711) -> ,
(53712, 53712) -> ,
(53713, 53712) -> ,
(53713, 53713) -> ,
(53714, 53711) -> ,
(53714, 53714) -> ,
(53715, 53711) -> ,
(53715, 53715) -> ,
(53716, 53712) -> ,
(53716, 53716) -> ,
(53717, 53713) -> ,
(53717, 53714) -> ,
(53717, 53715) -> ,
(53717, 53716) -> }
Starting : 53717
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{ch -> (53676 : 
Input : ((lambda : lambda), (lst : string list)) 
Output : bool
Body : 
 (match lambda with 
|V x -> mem ((x, lst))
|P (x, p) -> ch ((p, (x :: lst)))
|C (p, q) -> (ch ((p, lst)) && ch ((q, lst)))),

check -> (53675 : 
Input : (lambda : lambda) 
Output : bool
Body : ch ((lambda, [])),

mem -> (53674 : 
Input : (key, (lst : #1039421 list)) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = key) then true
 else (false || mem ((key, tl))))}
Edge : 
{(53674, 53674) -> ,
(53675, 53676) -> ,
(53676, 53674) -> ,
(53676, 53676) -> }
Starting : 53675
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
matchvar -> mem,
searchlist -> ch}
------Remainings in submission ------
{comblist,complist,used,vars}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60557 : ?)

Decls : 
,Exp : Modify (60624 : ?)

Decls : 
,Exp : Modify (60650 : ? ((?, [])))

Decls : 
,Exp : Insert (C (p, q) -> (? ((?, ?)) && ? ((?, ?))) At label 60569

Decls : 
,Exp : Insert (P (x, p) -> ? ((?, (? :: ?))) At label 60569

Decls : 
,Exp : Insert (V x -> ? ((?, ?)) At label 60569

Decls : 
,Exp : Insert ([] -> false At label 60638

Decls : 
,Exp : Insert (hd::tl -> if (? = ?) then true
 else (false || ? ((?, ?))) At label 60638

Decls : 
,Exp : Delete ([] -> false At label 60569

Decls : 
,Exp : Delete (hd::tl -> if (hd = a) then true
 else searchlist ((a, tl)) At label 60569

Decls : 
,Exp : Delete (([], _) -> true At label 60638

Decls : 
,Exp : Delete ((hd::tl, us) -> if searchlist ((hd, us)) then matchvar ((tl, us))
 else false At label 60638

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60557 : ?)

Decls : 
,Exp : Modify (60624 : ?)

Decls : 
,Exp : Modify (60650 : ? ((?, [])))

Decls : 
,Exp : Insert (C (p, q) -> (? ((?, ?)) && ? ((?, ?))) At label 60569

Decls : 
,Exp : Insert (P (x, p) -> ? ((?, (? :: ?))) At label 60569

Decls : 
,Exp : Insert (V x -> ? ((?, ?)) At label 60569

Decls : 
,Exp : Insert ([] -> false At label 60638

Decls : 
,Exp : Insert (hd::tl -> if (? = ?) then true
 else (false || ? ((?, ?))) At label 60638

Decls : 
,Exp : Delete ([] -> false At label 60569

Decls : 
,Exp : Delete (hd::tl -> if (hd = a) then true
 else searchlist ((a, tl)) At label 60569

Decls : 
,Exp : Delete (([], _) -> true At label 60638

Decls : 
,Exp : Delete ((hd::tl, us) -> if searchlist ((hd, us)) then matchvar ((tl, us))
 else false At label 60638

Decls : 
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub20.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------
type var = string
type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)

let check  : (lambda -> bool) = 
fun e -> true

-----------------------------
Submission
-----------------------------
type var = string
type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var

let check  : (lambda -> bool) = (60547, 
fun e -> (60546, true

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : e 
Output : bool
Body : true}
Edge : 
empty
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------
type var = string
type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let check  : (lambda -> bool) = 
fun e -> checking (e) ([])

Time : 0.00137901306152
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub21.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec extract  : (lambda -> var list) = 
fun e -> 
 (match e with 
|V v -> []
|P (v1, e1) -> ([v1] @ extract (e1))
|C (e1, e2) -> (extract (e1) @ extract (e2)))

let rec search  : ((var * var list) -> bool) = 
fun (v, lst) -> 
 (match lst with 
|[] -> false
|head::[] -> if (v = head) then true
 else false
|head::tail -> if ((v = head) || search ((v, tail))) then true
 else false)

let rec check2  : ((lambda * var list) -> bool) = 
fun (e, a) -> 
 (match e with 
|V v1 -> search ((v1, a))
|P (v1, e1) -> check2 ((e1, a))
|C (e1, e2) -> (check2 ((e1, a)) && check2 ((e2, a))))

let check  : (lambda -> bool) = 
fun e -> check2 ((e, extract (e)))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec extract  : (lambda -> var list) = (60562, 
fun e -> (60561, 
 (match (60546, e with 
|V v -> (60547, []
|P (v1, e1) -> (60553, ((60549, [(60548, v1] @ (60552, (60550, extract ((60551, e1))
|C (e1, e2) -> (60560, ((60556, (60554, extract ((60555, e1) @ (60559, (60557, extract ((60558, e2)))

let rec search  : ((var * var list) -> bool) = (60584, 
fun (v, lst) -> (60583, 
 (match (60563, lst with 
|[] -> (60564, false
|head::[] -> (60570, if (60567, ((60565, v = (60566, head) then (60568, true
 else (60569, false
|head::tail -> (60582, if (60579, ((60573, ((60571, v = (60572, head) || (60578, (60574, search ((60577, ((60575, v, (60576, tail))) then (60580, true
 else (60581, false)

let rec check2  : ((lambda * var list) -> bool) = (60608, 
fun (e, a) -> (60607, 
 (match (60585, e with 
|V v1 -> (60590, (60586, search ((60589, ((60587, v1, (60588, a))
|P (v1, e1) -> (60595, (60591, check2 ((60594, ((60592, e1, (60593, a))
|C (e1, e2) -> (60606, ((60600, (60596, check2 ((60599, ((60597, e1, (60598, a)) && (60605, (60601, check2 ((60604, ((60602, e2, (60603, a))))

let check  : (lambda -> bool) = (60616, 
fun e -> (60615, (60609, check2 ((60614, ((60610, e, (60613, (60611, extract ((60612, e)))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_16/sub97.ml Score : 2
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec mem  : ((var * var list) -> bool) = 
fun (key, lst) -> 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = key) then true
 else (false || mem ((key, tl))))

let check  : (lambda -> bool) = 
fun lambda -> 
let rec ch  : ((lambda * var list) -> bool) = 
fun (lambda, lst) -> 
 (match lambda with 
|V x -> mem ((x, lst))
|P (x, p) -> ch ((p, (x :: lst)))
|C (p, q) -> (ch ((p, lst)) && ch ((q, lst))))
 in 
ch ((lambda, []))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (49748 : 
Input : (e : lambda) 
Output : bool
Body : check2 ((e, extract (e))),

check2 -> (49747 : 
Input : ((e : lambda), (a : #996542 list)) 
Output : bool
Body : 
 (match e with 
|V v1 -> search ((v1, a))
|P (v1, e1) -> check2 ((e1, a))
|C (e1, e2) -> (check2 ((e1, a)) && check2 ((e2, a)))),

extract -> (49745 : 
Input : (e : lambda) 
Output : var list
Body : 
 (match e with 
|V v -> []
|P (v1, e1) -> ([v1] @ extract (e1))
|C (e1, e2) -> (extract (e1) @ extract (e2))),

search -> (49746 : 
Input : (v, (lst : #996542 list)) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|head::[] -> if (v = head) then true
 else false
|head::tail -> if ((v = head) || search ((v, tail))) then true
 else false)}
Edge : 
{(49745, 49745) -> ,
(49746, 49746) -> ,
(49747, 49746) -> ,
(49747, 49747) -> ,
(49748, 49745) -> ,
(49748, 49747) -> }
Starting : 49748
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{ch -> (49710 : 
Input : ((lambda : lambda), (lst : string list)) 
Output : bool
Body : 
 (match lambda with 
|V x -> mem ((x, lst))
|P (x, p) -> ch ((p, (x :: lst)))
|C (p, q) -> (ch ((p, lst)) && ch ((q, lst)))),

check -> (49709 : 
Input : (lambda : lambda) 
Output : bool
Body : ch ((lambda, [])),

mem -> (49708 : 
Input : (key, (lst : #995790 list)) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = key) then true
 else (false || mem ((key, tl))))}
Edge : 
{(49708, 49708) -> ,
(49709, 49710) -> ,
(49710, 49708) -> ,
(49710, 49710) -> }
Starting : 49709
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
check2 -> ch,
search -> mem}
------Remainings in submission ------
{extract}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60563 : ?)

Decls : 
,Exp : Modify (60579 : (? = ?))

Decls : 
,Exp : Modify (60581 : (false || ? ((?, ?))))

Decls : 
,Exp : Modify (60585 : ?)

Decls : 
,Exp : Modify (60590 : ? ((?, ?)))

Decls : 
,Exp : Modify (60595 : ? ((?, (? :: ?))))

Decls : 
,Exp : Modify (60600 : ? ((?, ?)))

Decls : 
,Exp : Modify (60605 : ? ((?, ?)))

Decls : 
,Exp : Modify (60615 : ? ((?, [])))

Decls : 
,Exp : Delete (head::[] -> if (v = head) then true
 else false At label 60583

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60563 : ?)

Decls : 
,Exp : Modify (60579 : (? = ?))

Decls : 
,Exp : Modify (60581 : (false || ? ((?, ?))))

Decls : 
,Exp : Modify (60585 : ?)

Decls : 
,Exp : Modify (60590 : ? ((?, ?)))

Decls : 
,Exp : Modify (60595 : ? ((?, (? :: ?))))

Decls : 
,Exp : Modify (60600 : ? ((?, ?)))

Decls : 
,Exp : Modify (60605 : ? ((?, ?)))

Decls : 
,Exp : Modify (60615 : ? ((?, [])))

Decls : 
,Exp : Delete (head::[] -> if (v = head) then true
 else false At label 60583

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec extract  : (lambda -> var list) = 
fun e -> 
 (match e with 
|V v -> []
|P (v1, e1) -> ([v1] @ extract (e1))
|C (e1, e2) -> (extract (e1) @ extract (e2)))

let rec search  : ((var * var list) -> bool) = 
fun (v, lst) -> 
 (match lst with 
|[] -> false
|head::[] -> if (v = head) then true
 else false
|head::tail -> if ((v = head) || search ((v, tail))) then true
 else false)

let rec check2  : ((lambda * var list) -> bool) = 
fun (e, a) -> 
 (match e with 
|V v1 -> search ((v1, a))
|P (v1, e1) -> check2 ((e1, (v1 :: a)))
|C (e1, e2) -> (check2 ((e1, a)) && check2 ((e2, a))))

let check  : (lambda -> bool) = 
fun e -> check2 ((e, []))

Time : 6.55844783783
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub35.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check  : (lambda -> bool) = 
fun e -> true

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check  : (lambda -> bool) = (60547, 
fun e -> (60546, true

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : e 
Output : bool
Body : true}
Edge : 
empty
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let check  : (lambda -> bool) = 
fun e -> checking (e) ([])

Time : 0.00143790245056
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub37.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec chars  : (lambda -> var) = 
fun e -> 
 (match e with 
|V a -> a
|P (v, e1) -> 
 (match e1 with 
|V b -> b
|P (b, e2) -> chars (e2)
|C (e1, e2) -> chars (e2))
|C (e1, e2) -> 
 (match (e1, e2) with 
|(V b, V c) -> c
|(V b, P (c, e3)) -> chars (e3)))

let check  : (lambda -> bool) = 
fun e -> 
 (match e with 
|V a -> true
|P (v, e1) -> 
 (match e1 with 
|V b -> if (v = b) then true
 else false
|P (b, e2) -> if ((chars (e2) = v) || (chars (e2) = b)) then true
 else false
|C (e1, e2) -> if ((chars (e1) = v) || (chars (e2) = v)) then true
 else false)
|C (e1, e2) -> 
 (match (e1, e2) with 
|(V b, V c) -> true
|(V b, P (c, e3)) -> if ((c = b) || (b = chars (e3))) then true
 else false))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec chars  : (lambda -> var) = (60566, 
fun e -> (60565, 
 (match (60546, e with 
|V a -> (60547, a
|P (v, e1) -> (60556, 
 (match (60548, e1 with 
|V b -> (60549, b
|P (b, e2) -> (60552, (60550, chars ((60551, e2)
|C (e1, e2) -> (60555, (60553, chars ((60554, e2))
|C (e1, e2) -> (60564, 
 (match (60559, ((60557, e1, (60558, e2) with 
|(V b, V c) -> (60560, c
|(V b, P (c, e3)) -> (60563, (60561, chars ((60562, e3)))

let check  : (lambda -> bool) = (60623, 
fun e -> (60622, 
 (match (60567, e with 
|V a -> (60568, true
|P (v, e1) -> (60604, 
 (match (60569, e1 with 
|V b -> (60575, if (60572, ((60570, v = (60571, b) then (60573, true
 else (60574, false
|P (b, e2) -> (60589, if (60586, ((60580, ((60578, (60576, chars ((60577, e2) = (60579, v) || (60585, ((60583, (60581, chars ((60582, e2) = (60584, b)) then (60587, true
 else (60588, false
|C (e1, e2) -> (60603, if (60600, ((60594, ((60592, (60590, chars ((60591, e1) = (60593, v) || (60599, ((60597, (60595, chars ((60596, e2) = (60598, v)) then (60601, true
 else (60602, false)
|C (e1, e2) -> (60621, 
 (match (60607, ((60605, e1, (60606, e2) with 
|(V b, V c) -> (60608, true
|(V b, P (c, e3)) -> (60620, if (60617, ((60611, ((60609, c = (60610, b) || (60616, ((60612, b = (60615, (60613, chars ((60614, e3))) then (60618, true
 else (60619, false))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : -1
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{chars -> (47099 : 
Input : (e : lambda) 
Output : var
Body : 
 (match e with 
|V a -> a
|P (v, e1) -> 
 (match e1 with 
|V b -> b
|P (b, e2) -> chars (e2)
|C (e1, e2) -> chars (e2))
|C (e1, e2) -> 
 (match (e1, e2) with 
|(V b, V c) -> c
|(V b, P (c, e3)) -> chars (e3))),

check -> (47100 : 
Input : (e : lambda) 
Output : bool
Body : 
 (match e with 
|V a -> true
|P (v, e1) -> 
 (match e1 with 
|V b -> if (v = b) then true
 else false
|P (b, e2) -> if ((chars (e2) = v) || (chars (e2) = b)) then true
 else false
|C (e1, e2) -> if ((chars (e1) = v) || (chars (e2) = v)) then true
 else false)
|C (e1, e2) -> 
 (match (e1, e2) with 
|(V b, V c) -> true
|(V b, P (c, e3)) -> if ((c = b) || (b = chars (e3))) then true
 else false))}
Edge : 
{(47099, 47099) -> ,
(47100, 47099) -> }
Starting : 47100
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (47065 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (47064 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(47064, 47064) -> ,
(47065, 47064) -> }
Starting : 47065
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{chars}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60622 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60622 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec chars  : (lambda -> var) = 
fun e -> 
 (match e with 
|V a -> a
|P (v, e1) -> 
 (match e1 with 
|V b -> b
|P (b, e2) -> chars (e2)
|C (e1, e2) -> chars (e2))
|C (e1, e2) -> 
 (match (e1, e2) with 
|(V b, V c) -> c
|(V b, P (c, e3)) -> chars (e3)))

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let check  : (lambda -> bool) = 
fun e -> checking (e) ([])

Time : 0.00153803825378
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub38.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun e -> 
 (match e with 
|P (v, e) -> 
 (match e with 
|V a -> (v = a)
|P (a, b) -> check (e)
|C (a, b) -> (check (a) && check (b)))
|C (a, b) -> (check (a) && check (b))
|V a -> true
|_ -> false)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = (60572, 
fun e -> (60571, 
 (match (60546, e with 
|P (v, e) -> (60561, 
 (match (60547, e with 
|V a -> (60550, ((60548, v = (60549, a)
|P (a, b) -> (60553, (60551, check ((60552, e)
|C (a, b) -> (60560, ((60556, (60554, check ((60555, a) && (60559, (60557, check ((60558, b)))
|C (a, b) -> (60568, ((60564, (60562, check ((60563, a) && (60567, (60565, check ((60566, b))
|V a -> (60569, true
|_ -> (60570, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : (e : lambda) 
Output : bool
Body : 
 (match e with 
|P (v, e) -> 
 (match e with 
|V a -> (v = a)
|P (a, b) -> check (e)
|C (a, b) -> (check (a) && check (b)))
|C (a, b) -> (check (a) && check (b))
|V a -> true
|_ -> false)}
Edge : 
{(45777, 45777) -> }
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60571 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60571 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun e -> checking (e) ([])

Time : 0.00145196914673
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub39.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec ptree  : ((var * lambda) -> bool) = 
fun (e1, e2) -> 
 (match e2 with 
|P (x, y) -> 
 (match y with 
|P (a, b) -> ((ptree ((a, b)) || ptree ((x, b))) || ptree ((e1, b)))
|C (a, b) -> ((ptree ((x, a)) || ptree ((x, b))) && (ptree ((e1, a)) || ptree ((e1, b))))
|V a -> (ptree ((x, y)) || ptree ((e1, y))))
|C (x, y) -> (ptree ((e1, x)) && ptree ((e1, y)))
|V x -> (e1 = x))

let rec ctree  : ((lambda * lambda) -> bool) = 
fun (e1, e2) -> 
 (match (e1, e2) with 
|(P (x1, y1), P (x2, y2)) -> (ptree ((x1, y1)) && ptree ((x2, y2)))
|(C (x1, y1), P (x2, y2)) -> (ctree ((x1, y1)) && ptree ((x2, y2)))
|(P (x1, y1), C (x2, y2)) -> (ptree ((x1, y1)) && ctree ((x2, y2)))
|(C (x1, y1), C (x2, y2)) -> (ctree ((x1, y1)) && ctree ((x2, y2)))
|(V x, _) -> false
|(_, V y) -> false)

let check  : (lambda -> bool) = 
fun e -> 
 (match e with 
|P (x, y) -> ptree ((x, y))
|C (x, y) -> ctree ((x, y))
|V x -> true)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec ptree  : ((var * lambda) -> bool) = (60615, 
fun (e1, e2) -> (60614, 
 (match (60546, e2 with 
|P (x, y) -> (60599, 
 (match (60547, y with 
|P (a, b) -> (60564, ((60558, ((60552, (60548, ptree ((60551, ((60549, a, (60550, b)) || (60557, (60553, ptree ((60556, ((60554, x, (60555, b))) || (60563, (60559, ptree ((60562, ((60560, e1, (60561, b)))
|C (a, b) -> (60587, ((60575, ((60569, (60565, ptree ((60568, ((60566, x, (60567, a)) || (60574, (60570, ptree ((60573, ((60571, x, (60572, b))) && (60586, ((60580, (60576, ptree ((60579, ((60577, e1, (60578, a)) || (60585, (60581, ptree ((60584, ((60582, e1, (60583, b))))
|V a -> (60598, ((60592, (60588, ptree ((60591, ((60589, x, (60590, y)) || (60597, (60593, ptree ((60596, ((60594, e1, (60595, y))))
|C (x, y) -> (60610, ((60604, (60600, ptree ((60603, ((60601, e1, (60602, x)) && (60609, (60605, ptree ((60608, ((60606, e1, (60607, y)))
|V x -> (60613, ((60611, e1 = (60612, x))

let rec ctree  : ((lambda * lambda) -> bool) = (60666, 
fun (e1, e2) -> (60665, 
 (match (60618, ((60616, e1, (60617, e2) with 
|(P (x1, y1), P (x2, y2)) -> (60629, ((60623, (60619, ptree ((60622, ((60620, x1, (60621, y1)) && (60628, (60624, ptree ((60627, ((60625, x2, (60626, y2)))
|(C (x1, y1), P (x2, y2)) -> (60640, ((60634, (60630, ctree ((60633, ((60631, x1, (60632, y1)) && (60639, (60635, ptree ((60638, ((60636, x2, (60637, y2)))
|(P (x1, y1), C (x2, y2)) -> (60651, ((60645, (60641, ptree ((60644, ((60642, x1, (60643, y1)) && (60650, (60646, ctree ((60649, ((60647, x2, (60648, y2)))
|(C (x1, y1), C (x2, y2)) -> (60662, ((60656, (60652, ctree ((60655, ((60653, x1, (60654, y1)) && (60661, (60657, ctree ((60660, ((60658, x2, (60659, y2)))
|(V x, _) -> (60663, false
|(_, V y) -> (60664, false)

let check  : (lambda -> bool) = (60680, 
fun e -> (60679, 
 (match (60667, e with 
|P (x, y) -> (60672, (60668, ptree ((60671, ((60669, x, (60670, y))
|C (x, y) -> (60677, (60673, ctree ((60676, ((60674, x, (60675, y))
|V x -> (60678, true)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/11/sub11.ml Score : 3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check m  = 
let rec valify (var_, covers)  = 
 (match covers with 
|V n -> false
|P (n, m_) -> if (n = var_) then true
 else valify ((var_, m_))
|C (m1, m2) -> false)
 in 

let rec findStation (cur, covers)  = 
 (match cur with 
|V n -> valify ((n, covers))
|P (n, m_) -> findStation ((m_, P ((n, covers))))
|C (m1, m2) -> (findStation ((m1, covers)) && findStation ((m2, covers))))
 in 
findStation ((m, V (" ")))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (48425 : 
Input : (e : lambda) 
Output : bool
Body : 
 (match e with 
|P (x, y) -> ptree ((x, y))
|C (x, y) -> ctree ((x, y))
|V x -> true),

ctree -> (48424 : 
Input : ((e1 : lambda), (e2 : lambda)) 
Output : bool
Body : 
 (match (e1, e2) with 
|(P (x1, y1), P (x2, y2)) -> (ptree ((x1, y1)) && ptree ((x2, y2)))
|(C (x1, y1), P (x2, y2)) -> (ctree ((x1, y1)) && ptree ((x2, y2)))
|(P (x1, y1), C (x2, y2)) -> (ptree ((x1, y1)) && ctree ((x2, y2)))
|(C (x1, y1), C (x2, y2)) -> (ctree ((x1, y1)) && ctree ((x2, y2)))
|(V x, _) -> false
|(_, V y) -> false),

ptree -> (48423 : 
Input : ((e1 : string), (e2 : lambda)) 
Output : bool
Body : 
 (match e2 with 
|P (x, y) -> 
 (match y with 
|P (a, b) -> ((ptree ((a, b)) || ptree ((x, b))) || ptree ((e1, b)))
|C (a, b) -> ((ptree ((x, a)) || ptree ((x, b))) && (ptree ((e1, a)) || ptree ((e1, b))))
|V a -> (ptree ((x, y)) || ptree ((e1, y))))
|C (x, y) -> (ptree ((e1, x)) && ptree ((e1, y)))
|V x -> (e1 = x))}
Edge : 
{(48423, 48423) -> ,
(48424, 48423) -> ,
(48424, 48424) -> ,
(48425, 48423) -> ,
(48425, 48424) -> }
Starting : 48425
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (48386 : 
Input : (m : lambda) 
Output : bool
Body : findStation ((m, V (" "))),

findStation -> (48388 : 
Input : ((cur : lambda), (covers : lambda)) 
Output : bool
Body : 
 (match cur with 
|V n -> valify ((n, covers))
|P (n, m_) -> findStation ((m_, P ((n, covers))))
|C (m1, m2) -> (findStation ((m1, covers)) && findStation ((m2, covers)))),

valify -> (48387 : 
Input : ((var_ : string), (covers : lambda)) 
Output : bool
Body : 
 (match covers with 
|V n -> false
|P (n, m_) -> if (n = var_) then true
 else valify ((var_, m_))
|C (m1, m2) -> false)}
Edge : 
{(48386, 48388) -> ,
(48387, 48387) -> ,
(48388, 48387) -> ,
(48388, 48388) -> }
Starting : 48386
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
ctree -> findStation,
ptree -> valify}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60599 : if (? = ?) then true
 else ? ((?, ?)))

Decls : 
,Exp : Modify (60610 : false)

Decls : 
,Exp : Modify (60613 : false)

Decls : 
,Exp : Modify (60618 : ?)

Decls : 
,Exp : Modify (60679 : ? ((?, V (" "))))

Decls : 
,Exp : Insert (C (m1, m2) -> (? ((?, ?)) && ? ((?, ?))) At label 60665

Decls : 
,Exp : Insert (P (n, m_) -> ? ((?, P ((?, ?)))) At label 60665

Decls : 
,Exp : Insert (V n -> ? ((?, ?)) At label 60665

Decls : 
,Exp : Delete ((_, V y) -> false At label 60665

Decls : 
,Exp : Delete ((C (x1, y1), C (x2, y2)) -> (ctree ((x1, y1)) && ctree ((x2, y2))) At label 60665

Decls : 
,Exp : Delete ((C (x1, y1), P (x2, y2)) -> (ctree ((x1, y1)) && ptree ((x2, y2))) At label 60665

Decls : 
,Exp : Delete ((P (x1, y1), C (x2, y2)) -> (ptree ((x1, y1)) && ctree ((x2, y2))) At label 60665

Decls : 
,Exp : Delete ((P (x1, y1), P (x2, y2)) -> (ptree ((x1, y1)) && ptree ((x2, y2))) At label 60665

Decls : 
,Exp : Delete ((V x, _) -> false At label 60665

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60599 : if (? = ?) then true
 else ? ((?, ?)))

Decls : 
,Exp : Modify (60610 : false)

Decls : 
,Exp : Modify (60613 : false)

Decls : 
,Exp : Modify (60679 : ? ((?, V (" "))))

Decls : 
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub47.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec change  : ((var * lambda) -> lambda) = 
fun (v, e) -> 
 (match e with 
|V v' -> V (v')
|P (v', e') -> change ((v', e'))
|C (e1, e2) -> if (V (v) = e1) then if (V (v) = e2) then change ((v, e1))
 else change ((v, e2))
 else if (V (v) = e2) then change ((v, e1))
 else change ((v, V (v))))

let check  : (lambda -> bool) = 
fun e -> 
 (match e with 
|V v -> false
|P (v, e') -> if (V (v) = change ((v, e'))) then true
 else false
|C (e1, e2) -> false)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec change  : ((var * lambda) -> lambda) = (60591, 
fun (v, e) -> (60590, 
 (match (60546, e with 
|V v' -> (60548, V ((60547, v')
|P (v', e') -> (60553, (60549, change ((60552, ((60550, v', (60551, e'))
|C (e1, e2) -> (60589, if (60557, ((60555, V ((60554, v) = (60556, e1) then (60572, if (60561, ((60559, V ((60558, v) = (60560, e2) then (60566, (60562, change ((60565, ((60563, v, (60564, e1))
 else (60571, (60567, change ((60570, ((60568, v, (60569, e2))
 else (60588, if (60576, ((60574, V ((60573, v) = (60575, e2) then (60581, (60577, change ((60580, ((60578, v, (60579, e1))
 else (60587, (60582, change ((60586, ((60583, v, (60585, V ((60584, v))))

let check  : (lambda -> bool) = (60607, 
fun e -> (60606, 
 (match (60592, e with 
|V v -> (60593, false
|P (v, e') -> (60604, if (60601, ((60595, V ((60594, v) = (60600, (60596, change ((60599, ((60597, v, (60598, e'))) then (60602, true
 else (60603, false
|C (e1, e2) -> (60605, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : -1
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{change -> (47099 : 
Input : ((v : string), (e : lambda)) 
Output : lambda
Body : 
 (match e with 
|V v' -> V (v')
|P (v', e') -> change ((v', e'))
|C (e1, e2) -> if (V (v) = e1) then if (V (v) = e2) then change ((v, e1))
 else change ((v, e2))
 else if (V (v) = e2) then change ((v, e1))
 else change ((v, V (v)))),

check -> (47100 : 
Input : (e : lambda) 
Output : bool
Body : 
 (match e with 
|V v -> false
|P (v, e') -> if (V (v) = change ((v, e'))) then true
 else false
|C (e1, e2) -> false)}
Edge : 
{(47099, 47099) -> ,
(47100, 47099) -> }
Starting : 47100
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (47065 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (47064 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(47064, 47064) -> ,
(47065, 47064) -> }
Starting : 47065
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{change}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60606 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60606 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec change  : ((var * lambda) -> lambda) = 
fun (v, e) -> 
 (match e with 
|V v' -> V (v')
|P (v', e') -> change ((v', e'))
|C (e1, e2) -> if (V (v) = e1) then if (V (v) = e2) then change ((v, e1))
 else change ((v, e2))
 else if (V (v) = e2) then change ((v, e1))
 else change ((v, V (v))))

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let check  : (lambda -> bool) = 
fun e -> checking (e) ([])

Time : 0.00155997276306
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub52.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check  : (lambda -> bool) = 
fun e -> true

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check  : (lambda -> bool) = (60547, 
fun e -> (60546, true

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : e 
Output : bool
Body : true}
Edge : 
empty
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let check  : (lambda -> bool) = 
fun e -> checking (e) ([])

Time : 0.00145697593689
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub53.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check_list (lambda, lst)  = 
 (match lambda with 
|V var -> if __list_mem__ (var) (lst) then true
 else false
|P (var, lambda) -> check_list ((lambda, (lst @ [var])))
|C (lambda1, lambda2) -> (check_list ((lambda2, lst)) && check_list ((lambda2, lst))))

let check  : (lambda -> bool) = 
fun e -> check_list ((e, []))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check_list (lambda, lst)  = (60574, 
 (match (60546, lambda with 
|V var -> (60554, if (60551, (60550, (60547, __list_mem__ ((60548, var) ((60549, lst) then (60552, true
 else (60553, false
|P (var, lambda) -> (60562, (60555, check_list ((60561, ((60556, lambda, (60560, ((60557, lst @ (60559, [(60558, var])))
|C (lambda1, lambda2) -> (60573, ((60567, (60563, check_list ((60566, ((60564, lambda2, (60565, lst)) && (60572, (60568, check_list ((60571, ((60569, lambda2, (60570, lst))))

let check  : (lambda -> bool) = (60580, 
fun e -> (60579, (60575, check_list ((60578, ((60576, e, (60577, []))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_16/sub35.ml Score : 3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec chklst (lambda, lst)  = 
 (match lambda with 
|P (var, lambda) -> chklst ((lambda, (lst @ [var])))
|C (lambda1, lambda2) -> if (chklst ((lambda1, lst)) && chklst ((lambda2, lst))) then true
 else false
|V var -> if (lst = []) then false
 else __list_exists__ (
fun x -> (x = var)) (lst))

let check  : (lambda -> bool) = 
fun lambda -> chklst ((lambda, []))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{__list_mem__ -> (47074 : 
Input : elem (lst : #957772 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (47100 : 
Input : (e : lambda) 
Output : bool
Body : check_list ((e, [])),

check_list -> (47099 : 
Input : ((lambda : lambda), (lst : string list)) 
Output : bool
Body : 
 (match lambda with 
|V var -> if __list_mem__ (var) (lst) then true
 else false
|P (var, lambda) -> check_list ((lambda, (lst @ [var])))
|C (lambda1, lambda2) -> (check_list ((lambda2, lst)) && check_list ((lambda2, lst))))}
Edge : 
{(47074, 47074) -> ,
(47099, 47074) -> ,
(47099, 47099) -> ,
(47100, 47099) -> }
Starting : 47100
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{__list_exists__ -> (47040 : 
Input : (pred : (#957061 -> bool)) (lst : #957061 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> (pred (hd) || __list_exists__ (pred) (tl))),

check -> (47065 : 
Input : (lambda : lambda) 
Output : bool
Body : chklst ((lambda, [])),

chklst -> (47064 : 
Input : ((lambda : lambda), (lst : string list)) 
Output : bool
Body : 
 (match lambda with 
|P (var, lambda) -> chklst ((lambda, (lst @ [var])))
|C (lambda1, lambda2) -> if (chklst ((lambda1, lst)) && chklst ((lambda2, lst))) then true
 else false
|V var -> if (lst = []) then false
 else __list_exists__ (
fun (x : string) -> (x = var)) (lst))}
Edge : 
{(47040, 47040) -> ,
(47064, 47040) -> ,
(47064, 47064) -> ,
(47065, 47064) -> }
Starting : 47065
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{__list_mem__ -> __list_exists__,
check -> check,
check_list -> chklst}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60551 : (? = []))

Decls : 
,Exp : Modify (60552 : false)

Decls : 
,Exp : Modify (60553 : ? (
fun (x : string) -> (? = ?)) (?))

Decls : 
,Exp : Modify (60562 : ? ((?, (? @ [?]))))

Decls : 
,Exp : Modify (60573 : if (? ((?, ?)) && ? ((?, ?))) then true
 else false)

Decls : 
,Exp : Modify (60579 : ? ((?, [])))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60551 : (? = []))

Decls : 
,Exp : Modify (60552 : false)

Decls : 
,Exp : Modify (60562 : ? ((?, (? @ [?]))))

Decls : 
,Exp : Modify (60573 : if (? ((?, ?)) && ? ((?, ?))) then true
 else false)

Decls : 
,Exp : Modify (60579 : ? ((?, [])))

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check_list (lambda, lst)  = 
 (match lambda with 
|V var -> if __list_mem__ (var) (lst) then true
 else false
|P (var, lambda) -> check_list ((lambda, (lst @ [var])))
|C (lambda1, lambda2) -> if (check_list ((lambda1, lst)) && check_list ((lambda2, lst))) then true
 else false)

let check  : (lambda -> bool) = 
fun e -> check_list ((e, []))

Time : 0.00628089904785
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub56.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec equi x l  = 
 (match l with 
|[] -> true
|hd::tl -> ((x = hd) && equi (x) (tl)))

let rec check_r  : (lambda -> (string list -> bool)) = 
fun e env -> 
 (match e with 
|V var -> if (env = []) then false
 else equi (var) (env)
|P (v, e) -> check_r (e) ((v :: env))
|C (e1, e2) -> (check_r (e1) (env) && check_r (e2) (env)))

let check  : (lambda -> bool) = 
fun e -> check_r (e) ([])

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec equi x l  = (60557, 
 (match (60546, l with 
|[] -> (60547, true
|hd::tl -> (60556, ((60550, ((60548, x = (60549, hd) && (60555, (60554, (60551, equi ((60552, x) ((60553, tl)))

let rec check_r  : (lambda -> (string list -> bool)) = (60589, 
fun e env -> (60587, 
 (match (60558, e with 
|V var -> (60568, if (60561, ((60559, env = (60560, []) then (60562, false
 else (60567, (60566, (60563, equi ((60564, var) ((60565, env)
|P (v, e) -> (60575, (60574, (60569, check_r ((60570, e) ((60573, ((60571, v :: (60572, env))
|C (e1, e2) -> (60586, ((60580, (60579, (60576, check_r ((60577, e1) ((60578, env) && (60585, (60584, (60581, check_r ((60582, e2) ((60583, env)))

let check  : (lambda -> bool) = (60595, 
fun e -> (60594, (60593, (60590, check_r ((60591, e) ((60592, [])

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub6.ml Score : 3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec find_stack  = 
fun v stack -> 
 (match stack with 
|hd::tl -> if (hd = v) then true
 else find_stack (v) (tl)
|[] -> false)

let rec check_inner  = 
fun lam stack -> 
 (match lam with 
|V v -> if find_stack (v) (stack) then true
 else false
|P (v, l) -> check_inner (l) ((v :: stack))
|C (l1, l2) -> (check_inner (l1) (stack) && check_inner (l2) (stack)))

let check  : (lambda -> bool) = 
fun lam -> check_inner (lam) ([])

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (48425 : 
Input : (e : lambda) 
Output : bool
Body : check_r (e) ([]),

check_r -> (48424 : 
Input : (e : lambda) (env : string list) 
Output : bool
Body : 
 (match e with 
|V var -> if (env = []) then false
 else equi (var) (env)
|P (v, e) -> check_r (e) ((v :: env))
|C (e1, e2) -> (check_r (e1) (env) && check_r (e2) (env))),

equi -> (48423 : 
Input : x (l : #964777 list) 
Output : bool
Body : 
 (match l with 
|[] -> true
|hd::tl -> ((x = hd) && equi (x) (tl)))}
Edge : 
{(48423, 48423) -> ,
(48424, 48423) -> ,
(48424, 48424) -> ,
(48425, 48424) -> }
Starting : 48425
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (48388 : 
Input : (lam : lambda) 
Output : bool
Body : check_inner (lam) ([]),

check_inner -> (48387 : 
Input : (lam : lambda) (stack : string list) 
Output : bool
Body : 
 (match lam with 
|V v -> if find_stack (v) (stack) then true
 else false
|P (v, l) -> check_inner (l) ((v :: stack))
|C (l1, l2) -> (check_inner (l1) (stack) && check_inner (l2) (stack))),

find_stack -> (48386 : 
Input : v (stack : #964062 list) 
Output : bool
Body : 
 (match stack with 
|hd::tl -> if (hd = v) then true
 else find_stack (v) (tl)
|[] -> false)}
Edge : 
{(48386, 48386) -> ,
(48387, 48386) -> ,
(48387, 48387) -> ,
(48388, 48387) -> }
Starting : 48388
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
check_r -> check_inner,
equi -> find_stack}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60547 : false)

Decls : 
,Exp : Modify (60556 : if (? = ?) then true
 else ? (?) (?))

Decls : 
,Exp : Modify (60558 : ?)

Decls : 
,Exp : Modify (60561 : ? (?) (?))

Decls : 
,Exp : Modify (60562 : true)

Decls : 
,Exp : Modify (60567 : false)

Decls : 
,Exp : Modify (60575 : ? (?) ((? :: ?)))

Decls : 
,Exp : Modify (60580 : ? (?) (?))

Decls : 
,Exp : Modify (60585 : ? (?) (?))

Decls : 
,Exp : Modify (60594 : ? (?) ([]))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60547 : false)

Decls : 
,Exp : Modify (60556 : if (? = ?) then true
 else ? (?) (?))

Decls : 
,Exp : Modify (60558 : ?)

Decls : 
,Exp : Modify (60561 : ? (?) (?))

Decls : 
,Exp : Modify (60567 : false)

Decls : 
,Exp : Modify (60575 : ? (?) ((? :: ?)))

Decls : 
,Exp : Modify (60580 : ? (?) (?))

Decls : 
,Exp : Modify (60585 : ? (?) (?))

Decls : 
,Exp : Modify (60594 : ? (?) ([]))

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec equi x l  = 
 (match l with 
|[] -> false
|hd::tl -> if (x = hd) then true
 else equi (x) (tl))

let rec check_r  : (lambda -> (string list -> bool)) = 
fun e env -> 
 (match e with 
|V var -> if (env = []) then false
 else equi (var) (env)
|P (v, e) -> check_r (e) ((v :: env))
|C (e1, e2) -> (check_r (e1) (env) && check_r (e2) (env)))

let check  : (lambda -> bool) = 
fun e -> check_r (e) ([])

Time : 1.14668011665
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub57.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun e -> checking ((e, makelist ((e, []))))
and makelist  : ((lambda * var list) -> var list) = 
fun (e, l) -> 
 (match (e, l) with 
|(V v, l) -> l
|(P (v, e), l) -> (v :: makelist ((e, l)))
|(C (e1, e2), l1) -> 
let l2  = makelist ((e1, l1))
 in 
makelist ((e2, l2)))
and checking  : ((lambda * var list) -> bool) = 
fun (e, l) -> 
 (match (e, l) with 
|(V v, l) -> findv ((v, l))
|(P (v, e), l) -> checking ((e, l))
|(C (e1, e2), l) -> (checking ((e1, l)) && checking ((e2, l))))
and findv  : ((var * var list) -> bool) = 
fun (v, l) -> 
 (match (v, l) with 
|(_, []) -> false
|(v, hd::tl) -> if (hd = v) then true
 else findv ((v, tl)))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = (60555, 
fun e -> (60554, (60546, checking ((60553, ((60547, e, (60552, (60548, makelist ((60551, ((60549, e, (60550, []))))
and makelist  : ((lambda * var list) -> var list) = (60579, 
fun (e, l) -> (60578, 
 (match (60558, ((60556, e, (60557, l) with 
|(V v, l) -> (60559, l
|(P (v, e), l) -> (60566, ((60560, v :: (60565, (60561, makelist ((60564, ((60562, e, (60563, l)))
|(C (e1, e2), l1) -> (60577, 
let l2  = (60571, (60567, makelist ((60570, ((60568, e1, (60569, l1))
 in 
(60576, (60572, makelist ((60575, ((60573, e2, (60574, l2)))
and checking  : ((lambda * var list) -> bool) = (60605, 
fun (e, l) -> (60604, 
 (match (60582, ((60580, e, (60581, l) with 
|(V v, l) -> (60587, (60583, findv ((60586, ((60584, v, (60585, l))
|(P (v, e), l) -> (60592, (60588, checking ((60591, ((60589, e, (60590, l))
|(C (e1, e2), l) -> (60603, ((60597, (60593, checking ((60596, ((60594, e1, (60595, l)) && (60602, (60598, checking ((60601, ((60599, e2, (60600, l))))
and findv  : ((var * var list) -> bool) = (60621, 
fun (v, l) -> (60620, 
 (match (60608, ((60606, v, (60607, l) with 
|(_, []) -> (60609, false
|(v, hd::tl) -> (60619, if (60612, ((60610, hd = (60611, v) then (60613, true
 else (60618, (60614, findv ((60617, ((60615, v, (60616, tl)))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_16/sub97.ml Score : 2
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec mem  : ((var * var list) -> bool) = 
fun (key, lst) -> 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = key) then true
 else (false || mem ((key, tl))))

let check  : (lambda -> bool) = 
fun lambda -> 
let rec ch  : ((lambda * var list) -> bool) = 
fun (lambda, lst) -> 
 (match lambda with 
|V x -> mem ((x, lst))
|P (x, p) -> ch ((p, (x :: lst)))
|C (p, q) -> (ch ((p, lst)) && ch ((q, lst))))
 in 
ch ((lambda, []))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (49745 : 
Input : (e : lambda) 
Output : bool
Body : checking ((e, makelist ((e, [])))),

checking -> (49747 : 
Input : ((e : lambda), (l : string list)) 
Output : bool
Body : 
 (match (e, l) with 
|(V v, l) -> findv ((v, l))
|(P (v, e), l) -> checking ((e, l))
|(C (e1, e2), l) -> (checking ((e1, l)) && checking ((e2, l)))),

findv -> (49748 : 
Input : ((v : string), (l : string list)) 
Output : bool
Body : 
 (match (v, l) with 
|(_, []) -> false
|(v, hd::tl) -> if (hd = v) then true
 else findv ((v, tl))),

makelist -> (49746 : 
Input : ((e : lambda), (l : string list)) 
Output : var list
Body : 
 (match (e, l) with 
|(V v, l) -> l
|(P (v, e), l) -> (v :: makelist ((e, l)))
|(C (e1, e2), l1) -> 
let l2  : string list = makelist ((e1, l1))
 in 
makelist ((e2, l2)))}
Edge : 
{(49745, 49746) -> ,
(49745, 49747) -> ,
(49746, 49746) -> ,
(49747, 49747) -> ,
(49747, 49748) -> ,
(49748, 49748) -> }
Starting : 49745
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{ch -> (49710 : 
Input : ((lambda : lambda), (lst : string list)) 
Output : bool
Body : 
 (match lambda with 
|V x -> mem ((x, lst))
|P (x, p) -> ch ((p, (x :: lst)))
|C (p, q) -> (ch ((p, lst)) && ch ((q, lst)))),

check -> (49709 : 
Input : (lambda : lambda) 
Output : bool
Body : ch ((lambda, [])),

mem -> (49708 : 
Input : (key, (lst : #1038096 list)) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = key) then true
 else (false || mem ((key, tl))))}
Edge : 
{(49708, 49708) -> ,
(49709, 49710) -> ,
(49710, 49708) -> ,
(49710, 49710) -> }
Starting : 49709
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
checking -> ch,
findv -> mem}
------Remainings in submission ------
{makelist}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60554 : ? ((?, [])))

Decls : 
,Exp : Modify (60582 : ?)

Decls : 
,Exp : Modify (60608 : ?)

Decls : 
,Exp : Insert (C (p, q) -> (? ((?, ?)) && ? ((?, ?))) At label 60604

Decls : 
,Exp : Insert (P (x, p) -> ? ((?, (? :: ?))) At label 60604

Decls : 
,Exp : Insert (V x -> ? ((?, ?)) At label 60604

Decls : 
,Exp : Insert ([] -> false At label 60620

Decls : 
,Exp : Insert (hd::tl -> if (? = ?) then true
 else (false || ? ((?, ?))) At label 60620

Decls : 
,Exp : Delete ((C (e1, e2), l) -> (checking ((e1, l)) && checking ((e2, l))) At label 60604

Decls : 
,Exp : Delete ((P (v, e), l) -> checking ((e, l)) At label 60604

Decls : 
,Exp : Delete ((V v, l) -> findv ((v, l)) At label 60604

Decls : 
,Exp : Delete ((_, []) -> false At label 60620

Decls : 
,Exp : Delete ((v, hd::tl) -> if (hd = v) then true
 else findv ((v, tl)) At label 60620

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60554 : ? ((?, [])))

Decls : 
,Exp : Modify (60582 : ?)

Decls : 
,Exp : Modify (60608 : ?)

Decls : 
,Exp : Insert (C (p, q) -> (? ((?, ?)) && ? ((?, ?))) At label 60604

Decls : 
,Exp : Insert (P (x, p) -> ? ((?, (? :: ?))) At label 60604

Decls : 
,Exp : Insert (V x -> ? ((?, ?)) At label 60604

Decls : 
,Exp : Insert ([] -> false At label 60620

Decls : 
,Exp : Insert (hd::tl -> if (? = ?) then true
 else (false || ? ((?, ?))) At label 60620

Decls : 
,Exp : Delete ((C (e1, e2), l) -> (checking ((e1, l)) && checking ((e2, l))) At label 60604

Decls : 
,Exp : Delete ((P (v, e), l) -> checking ((e, l)) At label 60604

Decls : 
,Exp : Delete ((V v, l) -> findv ((v, l)) At label 60604

Decls : 
,Exp : Delete ((_, []) -> false At label 60620

Decls : 
,Exp : Delete ((v, hd::tl) -> if (hd = v) then true
 else findv ((v, tl)) At label 60620

Decls : 
}
Fail to Repair
Error occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub58.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub60.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec ch  : ((lambda * var) -> bool) = 
fun (e, a) -> 
 (match e with 
|V b -> if (a = b) then true
 else false
|P (b, e) -> 
 (match e with 
|V c -> if ((c = b) || (c = a)) then true
 else false
|P (c, e) -> ((ch ((e, c)) || ch ((e, b))) || ch ((e, a)))
|C (e1, e2) -> if (a = b) then (ch ((e1, a)) && ch ((e2, a)))
 else ((ch ((e1, a)) || ch ((e1, b))) && (ch ((e2, a)) || ch ((e2, b)))))
|C (e1, e2) -> (ch ((e1, a)) && ch ((e2, a))))

let check  : (lambda -> bool) = 
fun e -> 
 (match e with 
|V a -> false
|P (a, e) -> ch ((e, a))
|C (e1, e2) -> false)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec ch  : ((lambda * var) -> bool) = (60632, 
fun (e, a) -> (60631, 
 (match (60546, e with 
|V b -> (60552, if (60549, ((60547, a = (60548, b) then (60550, true
 else (60551, false
|P (b, e) -> (60619, 
 (match (60553, e with 
|V c -> (60563, if (60560, ((60556, ((60554, c = (60555, b) || (60559, ((60557, c = (60558, a)) then (60561, true
 else (60562, false
|P (c, e) -> (60580, ((60574, ((60568, (60564, ch ((60567, ((60565, e, (60566, c)) || (60573, (60569, ch ((60572, ((60570, e, (60571, b))) || (60579, (60575, ch ((60578, ((60576, e, (60577, a)))
|C (e1, e2) -> (60618, if (60583, ((60581, a = (60582, b) then (60594, ((60588, (60584, ch ((60587, ((60585, e1, (60586, a)) && (60593, (60589, ch ((60592, ((60590, e2, (60591, a)))
 else (60617, ((60605, ((60599, (60595, ch ((60598, ((60596, e1, (60597, a)) || (60604, (60600, ch ((60603, ((60601, e1, (60602, b))) && (60616, ((60610, (60606, ch ((60609, ((60607, e2, (60608, a)) || (60615, (60611, ch ((60614, ((60612, e2, (60613, b)))))
|C (e1, e2) -> (60630, ((60624, (60620, ch ((60623, ((60621, e1, (60622, a)) && (60629, (60625, ch ((60628, ((60626, e2, (60627, a))))

let check  : (lambda -> bool) = (60642, 
fun e -> (60641, 
 (match (60633, e with 
|V a -> (60634, false
|P (a, e) -> (60639, (60635, ch ((60638, ((60636, e, (60637, a))
|C (e1, e2) -> (60640, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : -1
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{ch -> (47099 : 
Input : ((e : lambda), (a : string)) 
Output : bool
Body : 
 (match e with 
|V b -> if (a = b) then true
 else false
|P (b, e) -> 
 (match e with 
|V c -> if ((c = b) || (c = a)) then true
 else false
|P (c, e) -> ((ch ((e, c)) || ch ((e, b))) || ch ((e, a)))
|C (e1, e2) -> if (a = b) then (ch ((e1, a)) && ch ((e2, a)))
 else ((ch ((e1, a)) || ch ((e1, b))) && (ch ((e2, a)) || ch ((e2, b)))))
|C (e1, e2) -> (ch ((e1, a)) && ch ((e2, a)))),

check -> (47100 : 
Input : (e : lambda) 
Output : bool
Body : 
 (match e with 
|V a -> false
|P (a, e) -> ch ((e, a))
|C (e1, e2) -> false)}
Edge : 
{(47099, 47099) -> ,
(47100, 47099) -> }
Starting : 47100
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (47065 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (47064 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(47064, 47064) -> ,
(47065, 47064) -> }
Starting : 47065
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{ch}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60641 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60641 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec ch  : ((lambda * var) -> bool) = 
fun (e, a) -> 
 (match e with 
|V b -> if (a = b) then true
 else false
|P (b, e) -> 
 (match e with 
|V c -> if ((c = b) || (c = a)) then true
 else false
|P (c, e) -> ((ch ((e, c)) || ch ((e, b))) || ch ((e, a)))
|C (e1, e2) -> if (a = b) then (ch ((e1, a)) && ch ((e2, a)))
 else ((ch ((e1, a)) || ch ((e1, b))) && (ch ((e2, a)) || ch ((e2, b)))))
|C (e1, e2) -> (ch ((e1, a)) && ch ((e2, a))))

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let check  : (lambda -> bool) = 
fun e -> checking (e) ([])

Time : 0.00159788131714
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub61.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check  : (lambda -> bool) = 
fun e -> true

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check  : (lambda -> bool) = (60547, 
fun e -> (60546, true

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : e 
Output : bool
Body : true}
Edge : 
empty
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let check  : (lambda -> bool) = 
fun e -> checking (e) ([])

Time : 0.00150680541992
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub63.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check  : (lambda -> bool) = 
fun ex -> 
let rec var_list  : (lambda -> var list) = 
fun ex2 -> 
 (match ex2 with 
|V v -> [v]
|P (v2, ex3) -> var_list (ex3)
|C (ex3, ex4) -> (var_list (ex3) @ var_list (ex4)))
 in 

let rec proc_list  : (lambda -> var list) = 
fun ex2 -> 
 (match ex2 with 
|V v -> []
|P (v2, ex3) -> (v2 :: proc_list (ex3))
|C (ex3, ex4) -> (proc_list (ex3) @ proc_list (ex4)))
 in 

let rec _in_  : ((var list * var) -> bool) = 
fun (vlist, v) -> 
 (match vlist with 
|[] -> false
|hd::tl -> if (hd = v) then true
 else _in_ ((tl, v)))
 in 

let rec check2  : ((var list * var list) -> bool) = 
fun (vlist, plist) -> 
 (match vlist with 
|[] -> true
|hd::tl -> (_in_ ((plist, hd)) && check2 ((tl, plist))))
 in 
check2 ((var_list (ex), proc_list (ex)))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check  : (lambda -> bool) = (60619, 
fun ex -> (60618, 
let rec var_list  : (lambda -> var list) = (60560, 
fun ex2 -> (60559, 
 (match (60546, ex2 with 
|V v -> (60548, [(60547, v]
|P (v2, ex3) -> (60551, (60549, var_list ((60550, ex3)
|C (ex3, ex4) -> (60558, ((60554, (60552, var_list ((60553, ex3) @ (60557, (60555, var_list ((60556, ex4)))
 in 
(60617, 
let rec proc_list  : (lambda -> var list) = (60576, 
fun ex2 -> (60575, 
 (match (60561, ex2 with 
|V v -> (60562, []
|P (v2, ex3) -> (60567, ((60563, v2 :: (60566, (60564, proc_list ((60565, ex3))
|C (ex3, ex4) -> (60574, ((60570, (60568, proc_list ((60569, ex3) @ (60573, (60571, proc_list ((60572, ex4)))
 in 
(60616, 
let rec _in_  : ((var list * var) -> bool) = (60590, 
fun (vlist, v) -> (60589, 
 (match (60577, vlist with 
|[] -> (60578, false
|hd::tl -> (60588, if (60581, ((60579, hd = (60580, v) then (60582, true
 else (60587, (60583, _in_ ((60586, ((60584, tl, (60585, v)))
 in 
(60615, 
let rec check2  : ((var list * var list) -> bool) = (60605, 
fun (vlist, plist) -> (60604, 
 (match (60591, vlist with 
|[] -> (60592, true
|hd::tl -> (60603, ((60597, (60593, _in_ ((60596, ((60594, plist, (60595, hd)) && (60602, (60598, check2 ((60601, ((60599, tl, (60600, plist))))
 in 
(60614, (60606, check2 ((60613, ((60609, (60607, var_list ((60608, ex), (60612, (60610, proc_list ((60611, ex)))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/17/sub13.ml Score : -1
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec containCheck (n, ll)  : bool = 
 (match ll with 
|hd::tl -> if (hd = n) then true
 else containCheck ((n, tl))
|[] -> false)

let check lambda  : bool = 
let rec check (lambda, ll)  : bool = 
 (match lambda with 
|V n -> containCheck ((n, ll))
|P (n, met) -> check ((met, (n :: ll)))
|C (met1, met2) -> (check ((met1, ll)) && check ((met2, ll))))
 in 
check ((lambda, []))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{_in_ -> (51070 : 
Input : ((vlist : string list), (v : string)) 
Output : bool
Body : 
 (match vlist with 
|[] -> false
|hd::tl -> if (hd = v) then true
 else _in_ ((tl, v))),

check -> (51067 : 
Input : (ex : lambda) 
Output : bool
Body : check2 ((var_list (ex), proc_list (ex))),

check2 -> (51071 : 
Input : ((vlist : string list), (plist : string list)) 
Output : bool
Body : 
 (match vlist with 
|[] -> true
|hd::tl -> (_in_ ((plist, hd)) && check2 ((tl, plist)))),

proc_list -> (51069 : 
Input : (ex2 : lambda) 
Output : var list
Body : 
 (match ex2 with 
|V v -> []
|P (v2, ex3) -> (v2 :: proc_list (ex3))
|C (ex3, ex4) -> (proc_list (ex3) @ proc_list (ex4))),

var_list -> (51068 : 
Input : (ex2 : lambda) 
Output : var list
Body : 
 (match ex2 with 
|V v -> [v]
|P (v2, ex3) -> var_list (ex3)
|C (ex3, ex4) -> (var_list (ex3) @ var_list (ex4)))}
Edge : 
{(51067, 51068) -> ,
(51067, 51069) -> ,
(51067, 51071) -> ,
(51068, 51068) -> ,
(51069, 51069) -> ,
(51070, 51070) -> ,
(51071, 51070) -> ,
(51071, 51071) -> }
Starting : 51067
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (51031 : 
Input : (lambda : lambda) 
Output : bool
Body : check ((lambda, [])),

containCheck -> (51030 : 
Input : (n, (ll : #995792 list)) 
Output : bool
Body : 
 (match ll with 
|hd::tl -> if (hd = n) then true
 else containCheck ((n, tl))
|[] -> false)}
Edge : 
{(51030, 51030) -> ,
(51031, 51032) -> ,
(51032, 51030) -> ,
(51032, 51032) -> }
Starting : 51031
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
check2 -> containCheck}
------Remainings in submission ------
{_in_,proc_list,var_list}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60591 : ?)

Decls : 
,Exp : Modify (60592 : false)

Decls : 
,Exp : Modify (60603 : if (? = ?) then true
 else ? ((?, ?)))

Decls : 
,Exp : Modify (60614 : ? ((?, [])))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60591 : ?)

Decls : 
,Exp : Modify (60592 : false)

Decls : 
,Exp : Modify (60603 : if (? = ?) then true
 else ? ((?, ?)))

Decls : 
,Exp : Modify (60614 : ? ((?, [])))

Decls : 
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub67.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec comp va exorg  = 
 (match exorg with 
|V va1 -> false
|P (va1, ex1) -> if (va = va1) then true
 else comp (va) (ex1)
|C (ex1, ex2) -> (comp (va) (ex1) || comp (va) (ex2)))

let rec find ex exorg  = 
 (match ex with 
|V va1 -> comp (va1) (exorg)
|P (va1, ex1) -> find (ex1) (exorg)
|C (ex1, ex2) -> (find (ex1) (exorg) && find (ex2) (exorg)))

let rec check  : (lambda -> bool) = 
fun e -> 
 (match e with 
|V va -> false
|P (va, ex) -> find (ex) (e)
|C (ex1, ex2) -> (check (ex1) && check (ex2)))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec comp va exorg  = (60569, 
 (match (60546, exorg with 
|V va1 -> (60547, false
|P (va1, ex1) -> (60557, if (60550, ((60548, va = (60549, va1) then (60551, true
 else (60556, (60555, (60552, comp ((60553, va) ((60554, ex1)
|C (ex1, ex2) -> (60568, ((60562, (60561, (60558, comp ((60559, va) ((60560, ex1) || (60567, (60566, (60563, comp ((60564, va) ((60565, ex2)))

let rec find ex exorg  = (60592, 
 (match (60570, ex with 
|V va1 -> (60575, (60574, (60571, comp ((60572, va1) ((60573, exorg)
|P (va1, ex1) -> (60580, (60579, (60576, find ((60577, ex1) ((60578, exorg)
|C (ex1, ex2) -> (60591, ((60585, (60584, (60581, find ((60582, ex1) ((60583, exorg) && (60590, (60589, (60586, find ((60587, ex2) ((60588, exorg)))

let rec check  : (lambda -> bool) = (60608, 
fun e -> (60607, 
 (match (60593, e with 
|V va -> (60594, false
|P (va, ex) -> (60599, (60598, (60595, find ((60596, ex) ((60597, e)
|C (ex1, ex2) -> (60606, ((60602, (60600, check ((60601, ex1) && (60605, (60603, check ((60604, ex2)))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : -2
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (48423 : 
Input : (e : lambda) 
Output : bool
Body : 
 (match e with 
|V va -> false
|P (va, ex) -> find (ex) (e)
|C (ex1, ex2) -> (check (ex1) && check (ex2))),

comp -> (48421 : 
Input : (va : string) (exorg : lambda) 
Output : bool
Body : 
 (match exorg with 
|V va1 -> false
|P (va1, ex1) -> if (va = va1) then true
 else comp (va) (ex1)
|C (ex1, ex2) -> (comp (va) (ex1) || comp (va) (ex2))),

find -> (48422 : 
Input : (ex : lambda) (exorg : lambda) 
Output : bool
Body : 
 (match ex with 
|V va1 -> comp (va1) (exorg)
|P (va1, ex1) -> find (ex1) (exorg)
|C (ex1, ex2) -> (find (ex1) (exorg) && find (ex2) (exorg)))}
Edge : 
{(48421, 48421) -> ,
(48422, 48421) -> ,
(48422, 48422) -> ,
(48423, 48422) -> ,
(48423, 48423) -> }
Starting : 48423
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (48387 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (48386 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(48386, 48386) -> ,
(48387, 48386) -> }
Starting : 48387
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{comp,find}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60607 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60607 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec comp va exorg  = 
 (match exorg with 
|V va1 -> false
|P (va1, ex1) -> if (va = va1) then true
 else comp (va) (ex1)
|C (ex1, ex2) -> (comp (va) (ex1) || comp (va) (ex2)))

let rec find ex exorg  = 
 (match ex with 
|V va1 -> comp (va1) (exorg)
|P (va1, ex1) -> find (ex1) (exorg)
|C (ex1, ex2) -> (find (ex1) (exorg) && find (ex2) (exorg)))

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun e -> checking (e) ([])

Time : 0.00165200233459
Error occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub68.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub69.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun e -> 
 (match e with 
|V x -> false
|P (x, e1) -> 
 (match e1 with 
|V y -> (x = y)
|P (y, e2) -> 
 (match e2 with 
|C (e3, e4) -> ((check (P ((x, e3))) || check (P ((x, e4)))) && (check (P ((y, e3))) || check (P ((y, e4)))))
|_ -> (check (P ((x, e2))) || check (P ((y, e2)))))
|C (e2, e3) -> (check (P ((x, e2))) && check (P ((x, e3)))))
|C (e1, e2) -> (check (e1) && check (e2)))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = (60616, 
fun e -> (60615, 
 (match (60546, e with 
|V x -> (60547, false
|P (x, e1) -> (60607, 
 (match (60548, e1 with 
|V y -> (60551, ((60549, x = (60550, y)
|P (y, e2) -> (60593, 
 (match (60552, e2 with 
|C (e3, e4) -> (60579, ((60565, ((60558, (60553, check ((60557, P ((60556, ((60554, x, (60555, e3))) || (60564, (60559, check ((60563, P ((60562, ((60560, x, (60561, e4)))) && (60578, ((60571, (60566, check ((60570, P ((60569, ((60567, y, (60568, e3))) || (60577, (60572, check ((60576, P ((60575, ((60573, y, (60574, e4)))))
|_ -> (60592, ((60585, (60580, check ((60584, P ((60583, ((60581, x, (60582, e2))) || (60591, (60586, check ((60590, P ((60589, ((60587, y, (60588, e2)))))
|C (e2, e3) -> (60606, ((60599, (60594, check ((60598, P ((60597, ((60595, x, (60596, e2))) && (60605, (60600, check ((60604, P ((60603, ((60601, x, (60602, e3)))))
|C (e1, e2) -> (60614, ((60610, (60608, check ((60609, e1) && (60613, (60611, check ((60612, e2)))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : (e : lambda) 
Output : bool
Body : 
 (match e with 
|V x -> false
|P (x, e1) -> 
 (match e1 with 
|V y -> (x = y)
|P (y, e2) -> 
 (match e2 with 
|C (e3, e4) -> ((check (P ((x, e3))) || check (P ((x, e4)))) && (check (P ((y, e3))) || check (P ((y, e4)))))
|_ -> (check (P ((x, e2))) || check (P ((y, e2)))))
|C (e2, e3) -> (check (P ((x, e2))) && check (P ((x, e3)))))
|C (e1, e2) -> (check (e1) && check (e2)))}
Edge : 
{(45777, 45777) -> }
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60615 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60615 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun e -> checking (e) ([])

Time : 0.00148606300354
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub73.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check  : (lambda -> bool) = 
fun e -> true

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check  : (lambda -> bool) = (60547, 
fun e -> (60546, true

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : e 
Output : bool
Body : true}
Edge : 
empty
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let check  : (lambda -> bool) = 
fun e -> checking (e) ([])

Time : 0.00150895118713
Error occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub75.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub76.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun e -> 
let rec remove_var lambda var  = 
 (match lambda with 
|P (v, ex) -> P ((v, remove_var (ex) (var)))
|C (ex, ex') -> C ((remove_var (ex) (var), remove_var (ex') (var)))
|V v -> if (v = var) then V ("c")
 else V (v))
 in 

 (match e with 
|P (v, ex) -> check (remove_var (ex) (v))
|C (ex, ex') -> (check (ex) && check (ex'))
|V v -> if (v != "c") then false
 else true)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = (60599, 
fun e -> (60598, 
let rec remove_var lambda var  = (60575, 
 (match (60546, lambda with 
|P (v, ex) -> (60554, P ((60553, ((60547, v, (60552, (60551, (60548, remove_var ((60549, ex) ((60550, var)))
|C (ex, ex') -> (60566, C ((60565, ((60559, (60558, (60555, remove_var ((60556, ex) ((60557, var), (60564, (60563, (60560, remove_var ((60561, ex') ((60562, var)))
|V v -> (60574, if (60569, ((60567, v = (60568, var) then (60571, V ((60570, "c")
 else (60573, V ((60572, v))
 in 
(60597, 
 (match (60576, e with 
|P (v, ex) -> (60583, (60577, check ((60582, (60581, (60578, remove_var ((60579, ex) ((60580, v))
|C (ex, ex') -> (60590, ((60586, (60584, check ((60585, ex) && (60589, (60587, check ((60588, ex'))
|V v -> (60596, if (60593, ((60591, v != (60592, "c") then (60594, false
 else (60595, true)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : -1
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (47099 : 
Input : (e : lambda) 
Output : bool
Body : 
 (match e with 
|P (v, ex) -> check (remove_var (ex) (v))
|C (ex, ex') -> (check (ex) && check (ex'))
|V v -> if (v != "c") then false
 else true),

remove_var -> (47100 : 
Input : (lambda : lambda) (var : string) 
Output : lambda
Body : 
 (match lambda with 
|P (v, ex) -> P ((v, remove_var (ex) (var)))
|C (ex, ex') -> C ((remove_var (ex) (var), remove_var (ex') (var)))
|V v -> if (v = var) then V ("c")
 else V (v))}
Edge : 
{(47099, 47099) -> ,
(47099, 47100) -> ,
(47100, 47100) -> }
Starting : 47099
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (47065 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (47064 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(47064, 47064) -> ,
(47065, 47064) -> }
Starting : 47065
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{remove_var}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60597 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60597 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun e -> 
let rec remove_var lambda var  = 
 (match lambda with 
|P (v, ex) -> P ((v, remove_var (ex) (var)))
|C (ex, ex') -> C ((remove_var (ex) (var), remove_var (ex') (var)))
|V v -> if (v = var) then V ("c")
 else V (v))
 in 
checking (e) ([])

Time : 0.00158405303955
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub77.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec elist  : (lambda -> var list) = 
fun lambda -> 
 (match lambda with 
|V var -> []
|P (var, lambda1) -> 
 (match lambda1 with 
|V var2 -> [var]
|P (var2, lambda2) -> ([var; var2] @ elist (lambda2))
|C (lambda3, lambda4) -> ([var] @ (elist (lambda3) @ elist (lambda4))))
|C (lambda2, lambda3) -> 
 (match lambda2 with 
|V var -> elist (lambda3)
|P (var2, lambda4) -> ([var2] @ elist (lambda4))
|C (lambda5, lambda6) -> (elist (lambda5) @ (elist (lambda6) @ elist (lambda3)))))

let rec vlist lambda  = 
 (match lambda with 
|V var -> [var]
|P (var, lambda1) -> 
 (match lambda1 with 
|V var2 -> [var2]
|P (var2, lambda2) -> vlist (lambda2)
|C (lambda3, lambda4) -> (vlist (lambda3) @ vlist (lambda4)))
|C (lambda2, lambda3) -> 
 (match lambda2 with 
|V var -> ([var] @ vlist (lambda3))
|P (var2, lambda4) -> vlist (lambda4)
|C (lambda5, lambda6) -> (vlist (lambda5) @ (vlist (lambda6) @ vlist (lambda3)))))

let rec exist lambdalist varlist  = 
 (match varlist with 
|[] -> true
|vhd::vtl -> 
 (match lambdalist with 
|[] -> false
|ehd::etl -> if (vhd = ehd) then exist (lambdalist) (vtl)
 else (exist (etl) ([vhd]) || exist (etl) (varlist))))

let rec check  : (lambda -> bool) = 
fun lambda -> exist (elist (lambda)) (vlist (lambda))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec elist  : (lambda -> var list) = (60592, 
fun lambda -> (60591, 
 (match (60546, lambda with 
|V var -> (60547, []
|P (var, lambda1) -> (60568, 
 (match (60548, lambda1 with 
|V var2 -> (60550, [(60549, var]
|P (var2, lambda2) -> (60557, ((60553, [(60551, var; (60552, var2] @ (60556, (60554, elist ((60555, lambda2))
|C (lambda3, lambda4) -> (60567, ((60559, [(60558, var] @ (60566, ((60562, (60560, elist ((60561, lambda3) @ (60565, (60563, elist ((60564, lambda4))))
|C (lambda2, lambda3) -> (60590, 
 (match (60569, lambda2 with 
|V var -> (60572, (60570, elist ((60571, lambda3)
|P (var2, lambda4) -> (60578, ((60574, [(60573, var2] @ (60577, (60575, elist ((60576, lambda4))
|C (lambda5, lambda6) -> (60589, ((60581, (60579, elist ((60580, lambda5) @ (60588, ((60584, (60582, elist ((60583, lambda6) @ (60587, (60585, elist ((60586, lambda3)))))

let rec vlist lambda  = (60632, 
 (match (60593, lambda with 
|V var -> (60595, [(60594, var]
|P (var, lambda1) -> (60609, 
 (match (60596, lambda1 with 
|V var2 -> (60598, [(60597, var2]
|P (var2, lambda2) -> (60601, (60599, vlist ((60600, lambda2)
|C (lambda3, lambda4) -> (60608, ((60604, (60602, vlist ((60603, lambda3) @ (60607, (60605, vlist ((60606, lambda4)))
|C (lambda2, lambda3) -> (60631, 
 (match (60610, lambda2 with 
|V var -> (60616, ((60612, [(60611, var] @ (60615, (60613, vlist ((60614, lambda3))
|P (var2, lambda4) -> (60619, (60617, vlist ((60618, lambda4)
|C (lambda5, lambda6) -> (60630, ((60622, (60620, vlist ((60621, lambda5) @ (60629, ((60625, (60623, vlist ((60624, lambda6) @ (60628, (60626, vlist ((60627, lambda3)))))

let rec exist lambdalist varlist  = (60659, 
 (match (60633, varlist with 
|[] -> (60634, true
|vhd::vtl -> (60658, 
 (match (60635, lambdalist with 
|[] -> (60636, false
|ehd::etl -> (60657, if (60639, ((60637, vhd = (60638, ehd) then (60644, (60643, (60640, exist ((60641, lambdalist) ((60642, vtl)
 else (60656, ((60650, (60649, (60645, exist ((60646, etl) ((60648, [(60647, vhd]) || (60655, (60654, (60651, exist ((60652, etl) ((60653, varlist))))

let rec check  : (lambda -> bool) = (60669, 
fun lambda -> (60668, (60667, (60660, exist ((60663, (60661, elist ((60662, lambda)) ((60666, (60664, vlist ((60665, lambda))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_15/sub65.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec free_vars  = 
fun __fun__ -> 
 (match __fun__ with 
|V v -> [v]
|P (v, e) -> __list_filter__ (
fun x -> (x != v)) (free_vars (e))
|C (e1, e2) -> 
let f_e1  = free_vars (e1)
 in 

let f_e2  = free_vars (e2)
 in 
__list_append__ (f_e1) (__list_filter__ (
fun x -> not (__list_mem__ (x) (f_e1))) (f_e2)))

let rec fresh_var v1 l  = if __list_mem__ (v1) (l) then fresh_var ((v1 ^ "'")) (l)
 else v1

let check  : (lambda -> bool) = 
fun e -> if (free_vars (e) = []) then true
 else false

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (49748 : 
Input : (lambda : lambda) 
Output : bool
Body : exist (elist (lambda)) (vlist (lambda)),

elist -> (49745 : 
Input : (lambda : lambda) 
Output : var list
Body : 
 (match lambda with 
|V var -> []
|P (var, lambda1) -> 
 (match lambda1 with 
|V var2 -> [var]
|P (var2, lambda2) -> ([var; var2] @ elist (lambda2))
|C (lambda3, lambda4) -> ([var] @ (elist (lambda3) @ elist (lambda4))))
|C (lambda2, lambda3) -> 
 (match lambda2 with 
|V var -> elist (lambda3)
|P (var2, lambda4) -> ([var2] @ elist (lambda4))
|C (lambda5, lambda6) -> (elist (lambda5) @ (elist (lambda6) @ elist (lambda3))))),

exist -> (49747 : 
Input : (lambdalist : #1075936 list) (varlist : #1075936 list) 
Output : bool
Body : 
 (match varlist with 
|[] -> true
|vhd::vtl -> 
 (match lambdalist with 
|[] -> false
|ehd::etl -> if (vhd = ehd) then exist (lambdalist) (vtl)
 else (exist (etl) ([vhd]) || exist (etl) (varlist)))),

vlist -> (49746 : 
Input : (lambda : lambda) 
Output : string list
Body : 
 (match lambda with 
|V var -> [var]
|P (var, lambda1) -> 
 (match lambda1 with 
|V var2 -> [var2]
|P (var2, lambda2) -> vlist (lambda2)
|C (lambda3, lambda4) -> (vlist (lambda3) @ vlist (lambda4)))
|C (lambda2, lambda3) -> 
 (match lambda2 with 
|V var -> ([var] @ vlist (lambda3))
|P (var2, lambda4) -> vlist (lambda4)
|C (lambda5, lambda6) -> (vlist (lambda5) @ (vlist (lambda6) @ vlist (lambda3)))))}
Edge : 
{(49745, 49745) -> ,
(49746, 49746) -> ,
(49747, 49747) -> ,
(49748, 49745) -> ,
(49748, 49746) -> ,
(49748, 49747) -> }
Starting : 49748
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{__list_append__ -> (49686 : 
Input : (lst1 : #1074743 list) (lst2 : #1074743 list) 
Output : #1074680 list
Body : (lst1 @ lst2),

__list_filter__ -> (49685 : 
Input : (pred : (#1074736 -> bool)) (lst : #1074736 list) 
Output : #1074680 list
Body : 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl)),

__list_mem__ -> (49683 : 
Input : elem (lst : #1074712 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (49710 : 
Input : (e : lambda) 
Output : bool
Body : if (free_vars (e) = []) then true
 else false,

free_vars -> (49708 : 
Input : (__fun__ : lambda) 
Output : string list
Body : 
 (match __fun__ with 
|V v -> [v]
|P (v, e) -> __list_filter__ (
fun (x : string) -> (x != v)) (free_vars (e))
|C (e1, e2) -> 
let f_e1  : string list = free_vars (e1)
 in 

let f_e2  : string list = free_vars (e2)
 in 
__list_append__ (f_e1) (__list_filter__ (
fun (x : string) -> not (__list_mem__ (x) (f_e1))) (f_e2)))}
Edge : 
{(49683, 49683) -> ,
(49685, 49685) -> ,
(49708, 49683) -> ,
(49708, 49685) -> ,
(49708, 49686) -> ,
(49708, 49708) -> ,
(49710, 49708) -> }
Starting : 49710
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
exist -> __list_mem__,
vlist -> free_vars}
------Remainings in submission ------
{elist}
------Remainings in solution ------
{__list_append__,__list_filter__}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60593 : ?)

Decls : 
,Exp : Modify (60594 : ?)

Decls : 
,Exp : Modify (60609 : ? (
fun (x : string) -> (? != ?)) (? (?)))

Decls : 

let rec __list_filter__ (pred : (#1077964 -> bool)) (lst : #1077964 list)  : #1077908 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {vlist}
,Exp : Modify (60631 : 
let f_e1  : string list = ? (?)
 in 

let f_e2  : string list = ? (?)
 in 
? (?) (? (
fun (x : string) -> not (? (?) (?))) (?)))

Decls : 

let __list_append__ (lst1 : #1077971 list) (lst2 : #1077971 list)  : #1077908 list = (lst1 @ lst2)

Callers : {vlist}

let rec __list_filter__ (pred : (#1077964 -> bool)) (lst : #1077964 list)  : #1077908 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {vlist}
,Exp : Modify (60633 : ?)

Decls : 
,Exp : Modify (60634 : false)

Decls : 
,Exp : Modify (60658 : ((? = ?) || ? (?) (?)))

Decls : 
,Exp : Modify (60668 : if (? (?) = []) then true
 else false)

Decls : 

let __list_append__ (lst1 : #1077971 list) (lst2 : #1077971 list)  : #1077908 list = (lst1 @ lst2)

Callers : {vlist}

let rec __list_filter__ (pred : (#1077964 -> bool)) (lst : #1077964 list)  : #1077908 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {vlist}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60593 : ?)

Decls : 
,Exp : Modify (60594 : ?)

Decls : 
,Exp : Modify (60609 : ? (
fun (x : string) -> (? != ?)) (? (?)))

Decls : 

let rec __list_filter__ (pred : (#1077964 -> bool)) (lst : #1077964 list)  : #1077908 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {vlist}
,Exp : Modify (60631 : 
let f_e1  : string list = ? (?)
 in 

let f_e2  : string list = ? (?)
 in 
? (?) (? (
fun (x : string) -> not (? (?) (?))) (?)))

Decls : 

let __list_append__ (lst1 : #1077971 list) (lst2 : #1077971 list)  : #1077908 list = (lst1 @ lst2)

Callers : {vlist}

let rec __list_filter__ (pred : (#1077964 -> bool)) (lst : #1077964 list)  : #1077908 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {vlist}
,Exp : Modify (60633 : ?)

Decls : 
,Exp : Modify (60634 : false)

Decls : 
,Exp : Modify (60658 : ((? = ?) || ? (?) (?)))

Decls : 
,Exp : Modify (60668 : if (? (?) = []) then true
 else false)

Decls : 

let __list_append__ (lst1 : #1077971 list) (lst2 : #1077971 list)  : #1077908 list = (lst1 @ lst2)

Callers : {vlist}

let rec __list_filter__ (pred : (#1077964 -> bool)) (lst : #1077964 list)  : #1077908 list = 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl))

Callers : {vlist}
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub79.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checklist  : ((string list * string) -> bool) = 
fun (l, s) -> 
 (match l with 
|[] -> false
|h::t -> if (h = s) then true
 else checklist ((t, s)))

let rec extend  : ((lambda * string list) -> string list) = 
fun (x, env) -> 
 (match x with 
|V var -> if checklist ((env, var)) then env
 else (var :: env)
|P (v, e) -> extend ((e, env))
|C (e1, e2) -> extend ((e1, extend ((e2, env)))))

let rec check  : (lambda -> bool) = 
fun e -> 
 (match e with 
|V var -> true
|P (v, e1) -> (check (e1) && checklist ((extend ((e1, [])), v)))
|C (e1, e2) -> (check (e1) && check (e2)))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec checklist  : ((string list * string) -> bool) = (60559, 
fun (l, s) -> (60558, 
 (match (60546, l with 
|[] -> (60547, false
|h::t -> (60557, if (60550, ((60548, h = (60549, s) then (60551, true
 else (60556, (60552, checklist ((60555, ((60553, t, (60554, s)))

let rec extend  : ((lambda * string list) -> string list) = (60586, 
fun (x, env) -> (60585, 
 (match (60560, x with 
|V var -> (60570, if (60565, (60561, checklist ((60564, ((60562, env, (60563, var)) then (60566, env
 else (60569, ((60567, var :: (60568, env)
|P (v, e) -> (60575, (60571, extend ((60574, ((60572, e, (60573, env))
|C (e1, e2) -> (60584, (60576, extend ((60583, ((60577, e1, (60582, (60578, extend ((60581, ((60579, e2, (60580, env)))))

let rec check  : (lambda -> bool) = (60610, 
fun e -> (60609, 
 (match (60587, e with 
|V var -> (60588, true
|P (v, e1) -> (60601, ((60591, (60589, check ((60590, e1) && (60600, (60592, checklist ((60599, ((60597, (60593, extend ((60596, ((60594, e1, (60595, [])), (60598, v)))
|C (e1, e2) -> (60608, ((60604, (60602, check ((60603, e1) && (60607, (60605, check ((60606, e2)))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/17/sub13.ml Score : 1
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec containCheck (n, ll)  : bool = 
 (match ll with 
|hd::tl -> if (hd = n) then true
 else containCheck ((n, tl))
|[] -> false)

let check lambda  : bool = 
let rec check (lambda, ll)  : bool = 
 (match lambda with 
|V n -> containCheck ((n, ll))
|P (n, met) -> check ((met, (n :: ll)))
|C (met1, met2) -> (check ((met1, ll)) && check ((met2, ll))))
 in 
check ((lambda, []))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (48425 : 
Input : (e : lambda) 
Output : bool
Body : 
 (match e with 
|V var -> true
|P (v, e1) -> (check (e1) && checklist ((extend ((e1, [])), v)))
|C (e1, e2) -> (check (e1) && check (e2))),

checklist -> (48423 : 
Input : ((l : #991233 list), s) 
Output : bool
Body : 
 (match l with 
|[] -> false
|h::t -> if (h = s) then true
 else checklist ((t, s))),

extend -> (48424 : 
Input : ((x : lambda), (env : string list)) 
Output : string list
Body : 
 (match x with 
|V var -> if checklist ((env, var)) then env
 else (var :: env)
|P (v, e) -> extend ((e, env))
|C (e1, e2) -> extend ((e1, extend ((e2, env)))))}
Edge : 
{(48423, 48423) -> ,
(48424, 48423) -> ,
(48424, 48424) -> ,
(48425, 48423) -> ,
(48425, 48424) -> ,
(48425, 48425) -> }
Starting : 48425
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (48387 : 
Input : (lambda : lambda) 
Output : bool
Body : check ((lambda, [])),

containCheck -> (48386 : 
Input : (n, (ll : #990502 list)) 
Output : bool
Body : 
 (match ll with 
|hd::tl -> if (hd = n) then true
 else containCheck ((n, tl))
|[] -> false)}
Edge : 
{(48386, 48386) -> ,
(48387, 48388) -> ,
(48388, 48386) -> ,
(48388, 48388) -> }
Starting : 48387
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
checklist -> containCheck}
------Remainings in submission ------
{extend}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60548 : ?)

Decls : 
,Exp : Modify (60549 : ?)

Decls : 
,Exp : Modify (60556 : ? ((?, ?)))

Decls : 
,Exp : Modify (60609 : ? ((?, [])))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60548 : ?)

Decls : 
,Exp : Modify (60549 : ?)

Decls : 
,Exp : Modify (60556 : ? ((?, ?)))

Decls : 
,Exp : Modify (60609 : ? ((?, [])))

Decls : 
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub81.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check input  = 
let rec helpCheck a lst  = 
 (match a with 
|V a -> __list_exists__ (
fun a -> (a = a)) (lst)
|P (a, b) -> helpCheck (b) ((a :: lst))
|C (a, b) -> (helpCheck (a) (lst) && helpCheck (b) (lst)))
 in 
helpCheck (input) ([])

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check input  = (60579, 
let rec helpCheck a lst  = (60573, 
 (match (60546, a with 
|V a -> (60554, (60553, (60547, __list_exists__ ((60551, 
fun a -> (60550, ((60548, a = (60549, a)) ((60552, lst)
|P (a, b) -> (60561, (60560, (60555, helpCheck ((60556, b) ((60559, ((60557, a :: (60558, lst))
|C (a, b) -> (60572, ((60566, (60565, (60562, helpCheck ((60563, a) ((60564, lst) && (60571, (60570, (60567, helpCheck ((60568, b) ((60569, lst)))
 in 
(60578, (60577, (60574, helpCheck ((60575, input) ((60576, [])

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub6.ml Score : 3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec find_stack  = 
fun v stack -> 
 (match stack with 
|hd::tl -> if (hd = v) then true
 else find_stack (v) (tl)
|[] -> false)

let rec check_inner  = 
fun lam stack -> 
 (match lam with 
|V v -> if find_stack (v) (stack) then true
 else false
|P (v, l) -> check_inner (l) ((v :: stack))
|C (l1, l2) -> (check_inner (l1) (stack) && check_inner (l2) (stack)))

let check  : (lambda -> bool) = 
fun lam -> check_inner (lam) ([])

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{__list_exists__ -> (47077 : 
Input : (pred : (#953816 -> bool)) (lst : #953816 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> (pred (hd) || __list_exists__ (pred) (tl))),

check -> (47101 : 
Input : (input : lambda) 
Output : bool
Body : helpCheck (input) ([]),

helpCheck -> (47102 : 
Input : (a : lambda) (lst : string list) 
Output : bool
Body : 
 (match a with 
|V a -> __list_exists__ (
fun (a : string) -> (a = a)) (lst)
|P (a, b) -> helpCheck (b) ((a :: lst))
|C (a, b) -> (helpCheck (a) (lst) && helpCheck (b) (lst)))}
Edge : 
{(47077, 47077) -> ,
(47101, 47102) -> ,
(47102, 47077) -> ,
(47102, 47102) -> }
Starting : 47101
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (47066 : 
Input : (lam : lambda) 
Output : bool
Body : check_inner (lam) ([]),

check_inner -> (47065 : 
Input : (lam : lambda) (stack : string list) 
Output : bool
Body : 
 (match lam with 
|V v -> if find_stack (v) (stack) then true
 else false
|P (v, l) -> check_inner (l) ((v :: stack))
|C (l1, l2) -> (check_inner (l1) (stack) && check_inner (l2) (stack))),

find_stack -> (47064 : 
Input : v (stack : #953486 list) 
Output : bool
Body : 
 (match stack with 
|hd::tl -> if (hd = v) then true
 else find_stack (v) (tl)
|[] -> false)}
Edge : 
{(47064, 47064) -> ,
(47065, 47064) -> ,
(47065, 47065) -> ,
(47066, 47065) -> }
Starting : 47066
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{__list_exists__ -> find_stack,
check -> check,
helpCheck -> check_inner}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60554 : if ? (?) (?) then true
 else false)

Decls : 
,Exp : Modify (60561 : ? (?) ((? :: ?)))

Decls : 
,Exp : Modify (60566 : ? (?) (?))

Decls : 
,Exp : Modify (60571 : ? (?) (?))

Decls : 
,Exp : Modify (60578 : ? (?) ([]))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60554 : if ? (?) (?) then true
 else false)

Decls : 
,Exp : Modify (60561 : ? (?) ((? :: ?)))

Decls : 
,Exp : Modify (60566 : ? (?) (?))

Decls : 
,Exp : Modify (60571 : ? (?) (?))

Decls : 
,Exp : Modify (60578 : ? (?) ([]))

Decls : 
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_15/sub83.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec exist v lst  = 
 (match lst with 
|[] -> false
|hd::tl -> if (v = hd) then true
 else exist (v) (tl))

let rec checker e lst  = 
 (match e with 
|V v -> exist (v) (lst)
|P (v, e) -> checker (e) ((lst @ [v]))
|C (e1, e2) -> if (checker (e1) (lst) = checker (e2) (lst)) then true
 else false)

let rec check  : (lambda -> bool) = 
fun e -> checker (e) ([])

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec exist v lst  = (60558, 
 (match (60546, lst with 
|[] -> (60547, false
|hd::tl -> (60557, if (60550, ((60548, v = (60549, hd) then (60551, true
 else (60556, (60555, (60552, exist ((60553, v) ((60554, tl))

let rec checker e lst  = (60587, 
 (match (60559, e with 
|V v -> (60564, (60563, (60560, exist ((60561, v) ((60562, lst)
|P (v, e) -> (60572, (60571, (60565, checker ((60566, e) ((60570, ((60567, lst @ (60569, [(60568, v]))
|C (e1, e2) -> (60586, if (60583, ((60577, (60576, (60573, checker ((60574, e1) ((60575, lst) = (60582, (60581, (60578, checker ((60579, e2) ((60580, lst)) then (60584, true
 else (60585, false)

let rec check  : (lambda -> bool) = (60593, 
fun e -> (60592, (60591, (60588, checker ((60589, e) ((60590, [])

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub6.ml Score : 3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec find_stack  = 
fun v stack -> 
 (match stack with 
|hd::tl -> if (hd = v) then true
 else find_stack (v) (tl)
|[] -> false)

let rec check_inner  = 
fun lam stack -> 
 (match lam with 
|V v -> if find_stack (v) (stack) then true
 else false
|P (v, l) -> check_inner (l) ((v :: stack))
|C (l1, l2) -> (check_inner (l1) (stack) && check_inner (l2) (stack)))

let check  : (lambda -> bool) = 
fun lam -> check_inner (lam) ([])

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (48425 : 
Input : (e : lambda) 
Output : bool
Body : checker (e) ([]),

checker -> (48424 : 
Input : (e : lambda) (lst : string list) 
Output : bool
Body : 
 (match e with 
|V v -> exist (v) (lst)
|P (v, e) -> checker (e) ((lst @ [v]))
|C (e1, e2) -> if (checker (e1) (lst) = checker (e2) (lst)) then true
 else false),

exist -> (48423 : 
Input : v (lst : #964778 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> if (v = hd) then true
 else exist (v) (tl))}
Edge : 
{(48423, 48423) -> ,
(48424, 48423) -> ,
(48424, 48424) -> ,
(48425, 48424) -> }
Starting : 48425
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (48388 : 
Input : (lam : lambda) 
Output : bool
Body : check_inner (lam) ([]),

check_inner -> (48387 : 
Input : (lam : lambda) (stack : string list) 
Output : bool
Body : 
 (match lam with 
|V v -> if find_stack (v) (stack) then true
 else false
|P (v, l) -> check_inner (l) ((v :: stack))
|C (l1, l2) -> (check_inner (l1) (stack) && check_inner (l2) (stack))),

find_stack -> (48386 : 
Input : v (stack : #964063 list) 
Output : bool
Body : 
 (match stack with 
|hd::tl -> if (hd = v) then true
 else find_stack (v) (tl)
|[] -> false)}
Edge : 
{(48386, 48386) -> ,
(48387, 48386) -> ,
(48387, 48387) -> ,
(48388, 48387) -> }
Starting : 48388
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
checker -> check_inner,
exist -> find_stack}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60548 : ?)

Decls : 
,Exp : Modify (60549 : ?)

Decls : 
,Exp : Modify (60556 : ? (?) (?))

Decls : 
,Exp : Modify (60559 : ?)

Decls : 
,Exp : Modify (60564 : if ? (?) (?) then true
 else false)

Decls : 
,Exp : Modify (60572 : ? (?) ((? :: ?)))

Decls : 
,Exp : Modify (60586 : (? (?) (?) && ? (?) (?)))

Decls : 
,Exp : Modify (60592 : ? (?) ([]))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60559 : ?)

Decls : 
,Exp : Modify (60564 : if ? (?) (?) then true
 else false)

Decls : 
,Exp : Modify (60586 : (? (?) (?) && ? (?) (?)))

Decls : 
,Exp : Modify (60592 : ? (?) ([]))

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec exist v lst  = 
 (match lst with 
|[] -> false
|hd::tl -> if (v = hd) then true
 else exist (v) (tl))

let rec checker e lst  = 
 (match e with 
|V v -> exist (v) (lst)
|P (v, e) -> checker (e) ((lst @ [v]))
|C (e1, e2) -> (checker (e1) (lst) && checker (e2) (lst)))

let rec check  : (lambda -> bool) = 
fun e -> checker (e) ([])

Time : 0.00654006004333
Error occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub1.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub10.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V v -> true
|P (v, e) -> true
|C (e1, e2) -> true)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = (60551, 
fun lambda -> (60550, 
 (match (60546, lambda with 
|V v -> (60547, true
|P (v, e) -> (60548, true
|C (e1, e2) -> (60549, true)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|V v -> true
|P (v, e) -> true
|C (e1, e2) -> true)}
Edge : 
empty
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60550 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60550 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lambda -> checking (lambda) ([])

Time : 0.00144004821777
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub101.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|P (s, V a) -> if (s = a) then true
 else false
|P (s, P (s1, e1)) -> 
 (match e1 with 
|C (e2, e3) -> ((check (P ((s, e2))) || check (P ((s1, e2)))) && (check (P ((s, e3))) || check (P ((s1, e3)))))
|_ -> if ((check (P ((s1, e1))) = true) || check (P ((s, e1)))) then true
 else false)
|P (s, C (e1, e2)) -> 
 (match (e1, e2) with 
|(P (s1, e3), e) -> if (check (P ((s, P ((s1, e3))))) && check (P ((s, P ((s1, e)))))) then true
 else false
|(e, P (s1, e3)) -> if (check (P ((s, P ((s1, e3))))) && check (P ((s, P ((s1, e)))))) then true
 else false
|_ -> if (check (P ((s, e1))) && check (P ((s, e2)))) then true
 else false)
|_ -> false)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = (60666, 
fun lambda -> (60665, 
 (match (60546, lambda with 
|P (s, V a) -> (60552, if (60549, ((60547, s = (60548, a) then (60550, true
 else (60551, false
|P (s, P (s1, e1)) -> (60599, 
 (match (60553, e1 with 
|C (e2, e3) -> (60580, ((60566, ((60559, (60554, check ((60558, P ((60557, ((60555, s, (60556, e2))) || (60565, (60560, check ((60564, P ((60563, ((60561, s1, (60562, e2)))) && (60579, ((60572, (60567, check ((60571, P ((60570, ((60568, s, (60569, e3))) || (60578, (60573, check ((60577, P ((60576, ((60574, s1, (60575, e3)))))
|_ -> (60598, if (60595, ((60588, ((60586, (60581, check ((60585, P ((60584, ((60582, s1, (60583, e1))) = (60587, true) || (60594, (60589, check ((60593, P ((60592, ((60590, s, (60591, e1)))) then (60596, true
 else (60597, false)
|P (s, C (e1, e2)) -> (60663, 
 (match (60602, ((60600, e1, (60601, e2) with 
|(P (s1, e3), e) -> (60624, if (60621, ((60611, (60603, check ((60610, P ((60609, ((60604, s, (60608, P ((60607, ((60605, s1, (60606, e3))))) && (60620, (60612, check ((60619, P ((60618, ((60613, s, (60617, P ((60616, ((60614, s1, (60615, e)))))) then (60622, true
 else (60623, false
|(e, P (s1, e3)) -> (60646, if (60643, ((60633, (60625, check ((60632, P ((60631, ((60626, s, (60630, P ((60629, ((60627, s1, (60628, e3))))) && (60642, (60634, check ((60641, P ((60640, ((60635, s, (60639, P ((60638, ((60636, s1, (60637, e)))))) then (60644, true
 else (60645, false
|_ -> (60662, if (60659, ((60652, (60647, check ((60651, P ((60650, ((60648, s, (60649, e1))) && (60658, (60653, check ((60657, P ((60656, ((60654, s, (60655, e2)))) then (60660, true
 else (60661, false)
|_ -> (60664, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|P (s, V a) -> if (s = a) then true
 else false
|P (s, P (s1, e1)) -> 
 (match e1 with 
|C (e2, e3) -> ((check (P ((s, e2))) || check (P ((s1, e2)))) && (check (P ((s, e3))) || check (P ((s1, e3)))))
|_ -> if ((check (P ((s1, e1))) = true) || check (P ((s, e1)))) then true
 else false)
|P (s, C (e1, e2)) -> 
 (match (e1, e2) with 
|(P (s1, e3), e) -> if (check (P ((s, P ((s1, e3))))) && check (P ((s, P ((s1, e)))))) then true
 else false
|(e, P (s1, e3)) -> if (check (P ((s, P ((s1, e3))))) && check (P ((s, P ((s1, e)))))) then true
 else false
|_ -> if (check (P ((s, e1))) && check (P ((s, e2)))) then true
 else false)
|_ -> false)}
Edge : 
{(45777, 45777) -> }
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60665 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60665 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lambda -> checking (lambda) ([])

Time : 0.00147795677185
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub102.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec find  : ((var list * var) -> bool) = 
fun (lst, v) -> 
 (match lst with 
|hd::tl -> if (hd = v) then true
 else find ((tl, v))
|_ -> false)

let rec f  : ((var list * lambda) -> bool) = 
fun (lst, e) -> 
 (match e with 
|V v -> if find ((lst, v)) then true
 else false
|P (v, e) -> if f (((lst @ [v]), e)) then true
 else false
|C (e1, e2) -> if (check (e1) && check (e2)) then true
 else false)
and check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V v -> false
|P (v, e) -> if f (([v], e)) then true
 else false
|C (e1, e2) -> if (check (e1) && check (e2)) then true
 else false)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec find  : ((var list * var) -> bool) = (60559, 
fun (lst, v) -> (60558, 
 (match (60546, lst with 
|hd::tl -> (60556, if (60549, ((60547, hd = (60548, v) then (60550, true
 else (60555, (60551, find ((60554, ((60552, tl, (60553, v))
|_ -> (60557, false)

let rec f  : ((var list * lambda) -> bool) = (60591, 
fun (lst, e) -> (60590, 
 (match (60560, e with 
|V v -> (60568, if (60565, (60561, find ((60564, ((60562, lst, (60563, v)) then (60566, true
 else (60567, false
|P (v, e) -> (60579, if (60576, (60569, f ((60575, ((60573, ((60570, lst @ (60572, [(60571, v]), (60574, e)) then (60577, true
 else (60578, false
|C (e1, e2) -> (60589, if (60586, ((60582, (60580, check ((60581, e1) && (60585, (60583, check ((60584, e2)) then (60587, true
 else (60588, false)
and check  : (lambda -> bool) = (60614, 
fun lambda -> (60613, 
 (match (60592, lambda with 
|V v -> (60593, false
|P (v, e) -> (60602, if (60599, (60594, f ((60598, ((60596, [(60595, v], (60597, e)) then (60600, true
 else (60601, false
|C (e1, e2) -> (60612, if (60609, ((60605, (60603, check ((60604, e1) && (60608, (60606, check ((60607, e2)) then (60610, true
 else (60611, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/17/sub117.ml Score : 3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun lambda -> 
let rec checkArea  : ((string list * lambda) -> bool) = 
fun (nl, m) -> 
 (match m with 
|V s -> 
let rec isExist  : ((string list * string) -> bool) = 
fun (str_list, str) -> 
 (match str_list with 
|[] -> false
|e::e_list -> if (e = str) then true
 else isExist ((e_list, str)))
 in 
isExist ((nl, s))
|P (a, b) -> checkArea (((a :: nl), b))
|C (a, b) -> (checkArea ((nl, a)) && checkArea ((nl, b))))
 in 

 (match lambda with 
|V n -> false
|P (n, m) -> checkArea (([n], m))
|C (m1, m2) -> (check (m1) && check (m2)))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (48425 : 
Input : (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|V v -> false
|P (v, e) -> if f (([v], e)) then true
 else false
|C (e1, e2) -> if (check (e1) && check (e2)) then true
 else false),

f -> (48424 : 
Input : ((lst : string list), (e : lambda)) 
Output : bool
Body : 
 (match e with 
|V v -> if find ((lst, v)) then true
 else false
|P (v, e) -> if f (((lst @ [v]), e)) then true
 else false
|C (e1, e2) -> if (check (e1) && check (e2)) then true
 else false),

find -> (48423 : 
Input : ((lst : #982002 list), v) 
Output : bool
Body : 
 (match lst with 
|hd::tl -> if (hd = v) then true
 else find ((tl, v))
|_ -> false)}
Edge : 
{(48423, 48423) -> ,
(48424, 48423) -> ,
(48424, 48424) -> ,
(48424, 48425) -> ,
(48425, 48424) -> ,
(48425, 48425) -> }
Starting : 48425
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (48386 : 
Input : (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|V n -> false
|P (n, m) -> checkArea (([n], m))
|C (m1, m2) -> (check (m1) && check (m2))),

checkArea -> (48387 : 
Input : ((nl : string list), (m : lambda)) 
Output : bool
Body : 
 (match m with 
|V s -> isExist ((nl, s))
|P (a, b) -> checkArea (((a :: nl), b))
|C (a, b) -> (checkArea ((nl, a)) && checkArea ((nl, b)))),

isExist -> (48388 : 
Input : ((str_list : string list), (str : string)) 
Output : bool
Body : 
 (match str_list with 
|[] -> false
|e::e_list -> if (e = str) then true
 else isExist ((e_list, str)))}
Edge : 
{(48386, 48386) -> ,
(48386, 48387) -> ,
(48387, 48387) -> ,
(48387, 48388) -> ,
(48388, 48388) -> }
Starting : 48386
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
f -> checkArea,
find -> isExist}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60547 : ?)

Decls : 
,Exp : Modify (60548 : ?)

Decls : 
,Exp : Modify (60555 : ? ((?, ?)))

Decls : 
,Exp : Modify (60560 : ?)

Decls : 
,Exp : Modify (60568 : ? ((?, ?)))

Decls : 
,Exp : Modify (60579 : ? (((? :: ?), ?)))

Decls : 
,Exp : Modify (60589 : (? ((?, ?)) && ? ((?, ?))))

Decls : 
,Exp : Modify (60592 : ?)

Decls : 
,Exp : Modify (60602 : ? (([?], ?)))

Decls : 
,Exp : Modify (60612 : (? (?) && ? (?)))

Decls : 
,Exp : Insert ([] -> false At label 60558

Decls : 
,Exp : Delete (_ -> false At label 60558

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60547 : ?)

Decls : 
,Exp : Modify (60548 : ?)

Decls : 
,Exp : Modify (60555 : ? ((?, ?)))

Decls : 
,Exp : Modify (60560 : ?)

Decls : 
,Exp : Modify (60568 : ? ((?, ?)))

Decls : 
,Exp : Modify (60579 : ? (((? :: ?), ?)))

Decls : 
,Exp : Modify (60589 : (? ((?, ?)) && ? ((?, ?))))

Decls : 
,Exp : Modify (60592 : ?)

Decls : 
,Exp : Modify (60602 : ? (([?], ?)))

Decls : 
,Exp : Modify (60612 : (? (?) && ? (?)))

Decls : 
,Exp : Insert ([] -> false At label 60558

Decls : 
,Exp : Delete (_ -> false At label 60558

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec find  : ((var list * var) -> bool) = 
fun (lst, v) -> 
 (match lst with 
|hd::tl -> if (hd = v) then true
 else find ((tl, v))
|_ -> false)

let rec f  : ((var list * lambda) -> bool) = 
fun (lst, e) -> 
 (match e with 
|V v -> if find ((lst, v)) then true
 else false
|P (v, e) -> if f (((lst @ [v]), e)) then true
 else false
|C (e1, e2) -> (f ((lst, e1)) && f ((lst, e2))))
and check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V v -> false
|P (v, e) -> if f (([v], e)) then true
 else false
|C (e1, e2) -> if (check (e1) && check (e2)) then true
 else false)

Time : 0.0162620544434
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub109.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec var_find lambda  = 
 (match lambda with 
|V a -> []
|P (a, lambda1) -> (a :: var_find (lambda1))
|C (lambda1, lambda2) -> (var_find (lambda1) @ var_find (lambda2)))

let rec lambda_find lambda  = 
 (match lambda with 
|V a -> [a]
|P (a, lambda1) -> lambda_find (lambda1)
|C (lambda1, lambda2) -> (lambda_find (lambda1) @ lambda_find (lambda2)))

let rec find s l  = 
 (match l with 
|[] -> false
|hd::tl -> if (s = hd) then true
 else find (s) (tl))

let rec find_match l1 l2  = 
 (match l2 with 
|[] -> true
|hd::tl -> (find (hd) (l1) && find_match (l1) (tl)))

let check  : (lambda -> bool) = 
fun lambda -> find_match (var_find (lambda)) (lambda_find (lambda))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec var_find lambda  = (60560, 
 (match (60546, lambda with 
|V a -> (60547, []
|P (a, lambda1) -> (60552, ((60548, a :: (60551, (60549, var_find ((60550, lambda1))
|C (lambda1, lambda2) -> (60559, ((60555, (60553, var_find ((60554, lambda1) @ (60558, (60556, var_find ((60557, lambda2)))

let rec lambda_find lambda  = (60574, 
 (match (60561, lambda with 
|V a -> (60563, [(60562, a]
|P (a, lambda1) -> (60566, (60564, lambda_find ((60565, lambda1)
|C (lambda1, lambda2) -> (60573, ((60569, (60567, lambda_find ((60568, lambda1) @ (60572, (60570, lambda_find ((60571, lambda2)))

let rec find s l  = (60587, 
 (match (60575, l with 
|[] -> (60576, false
|hd::tl -> (60586, if (60579, ((60577, s = (60578, hd) then (60580, true
 else (60585, (60584, (60581, find ((60582, s) ((60583, tl))

let rec find_match l1 l2  = (60601, 
 (match (60588, l2 with 
|[] -> (60589, true
|hd::tl -> (60600, ((60594, (60593, (60590, find ((60591, hd) ((60592, l1) && (60599, (60598, (60595, find_match ((60596, l1) ((60597, tl)))

let check  : (lambda -> bool) = (60611, 
fun lambda -> (60610, (60609, (60602, find_match ((60605, (60603, var_find ((60604, lambda)) ((60608, (60606, lambda_find ((60607, lambda))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub6.ml Score : 1
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec find_stack  = 
fun v stack -> 
 (match stack with 
|hd::tl -> if (hd = v) then true
 else find_stack (v) (tl)
|[] -> false)

let rec check_inner  = 
fun lam stack -> 
 (match lam with 
|V v -> if find_stack (v) (stack) then true
 else false
|P (v, l) -> check_inner (l) ((v :: stack))
|C (l1, l2) -> (check_inner (l1) (stack) && check_inner (l2) (stack)))

let check  : (lambda -> bool) = 
fun lam -> check_inner (lam) ([])

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (51071 : 
Input : (lambda : lambda) 
Output : bool
Body : find_match (var_find (lambda)) (lambda_find (lambda)),

find -> (51069 : 
Input : s (l : #991253 list) 
Output : bool
Body : 
 (match l with 
|[] -> false
|hd::tl -> if (s = hd) then true
 else find (s) (tl)),

find_match -> (51070 : 
Input : (l1 : #991261 list) (l2 : #991261 list) 
Output : bool
Body : 
 (match l2 with 
|[] -> true
|hd::tl -> (find (hd) (l1) && find_match (l1) (tl))),

lambda_find -> (51068 : 
Input : (lambda : lambda) 
Output : string list
Body : 
 (match lambda with 
|V a -> [a]
|P (a, lambda1) -> lambda_find (lambda1)
|C (lambda1, lambda2) -> (lambda_find (lambda1) @ lambda_find (lambda2))),

var_find -> (51067 : 
Input : (lambda : lambda) 
Output : string list
Body : 
 (match lambda with 
|V a -> []
|P (a, lambda1) -> (a :: var_find (lambda1))
|C (lambda1, lambda2) -> (var_find (lambda1) @ var_find (lambda2)))}
Edge : 
{(51067, 51067) -> ,
(51068, 51068) -> ,
(51069, 51069) -> ,
(51070, 51069) -> ,
(51070, 51070) -> ,
(51071, 51067) -> ,
(51071, 51068) -> ,
(51071, 51070) -> }
Starting : 51071
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (51032 : 
Input : (lam : lambda) 
Output : bool
Body : check_inner (lam) ([]),

check_inner -> (51031 : 
Input : (lam : lambda) (stack : string list) 
Output : bool
Body : 
 (match lam with 
|V v -> if find_stack (v) (stack) then true
 else false
|P (v, l) -> check_inner (l) ((v :: stack))
|C (l1, l2) -> (check_inner (l1) (stack) && check_inner (l2) (stack))),

find_stack -> (51030 : 
Input : v (stack : #990507 list) 
Output : bool
Body : 
 (match stack with 
|hd::tl -> if (hd = v) then true
 else find_stack (v) (tl)
|[] -> false)}
Edge : 
{(51030, 51030) -> ,
(51031, 51030) -> ,
(51031, 51031) -> ,
(51032, 51031) -> }
Starting : 51032
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
find -> check_inner,
find_match -> find_stack}
------Remainings in submission ------
{lambda_find,var_find}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60575 : ?)

Decls : 
,Exp : Modify (60588 : ?)

Decls : 
,Exp : Modify (60589 : false)

Decls : 
,Exp : Modify (60600 : if (? = ?) then true
 else ? (?) (?))

Decls : 
,Exp : Modify (60610 : ? (?) ([]))

Decls : 
,Exp : Insert (C (l1, l2) -> (? (?) (?) && ? (?) (?)) At label 60587

Decls : 
,Exp : Insert (P (v, l) -> ? (?) ((? :: ?)) At label 60587

Decls : 
,Exp : Insert (V v -> if ? (?) (?) then true
 else false At label 60587

Decls : 
,Exp : Delete ([] -> false At label 60587

Decls : 
,Exp : Delete (hd::tl -> if (s = hd) then true
 else find (s) (tl) At label 60587

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60575 : ?)

Decls : 
,Exp : Modify (60588 : ?)

Decls : 
,Exp : Modify (60589 : false)

Decls : 
,Exp : Modify (60600 : if (? = ?) then true
 else ? (?) (?))

Decls : 
,Exp : Modify (60610 : ? (?) ([]))

Decls : 
,Exp : Insert (C (l1, l2) -> (? (?) (?) && ? (?) (?)) At label 60587

Decls : 
,Exp : Insert (P (v, l) -> ? (?) ((? :: ?)) At label 60587

Decls : 
,Exp : Insert (V v -> if ? (?) (?) then true
 else false At label 60587

Decls : 
,Exp : Delete ([] -> false At label 60587

Decls : 
,Exp : Delete (hd::tl -> if (s = hd) then true
 else find (s) (tl) At label 60587

Decls : 
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub11.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec isexist  : (var list -> (var -> bool)) = 
fun vars v -> 
 (match vars with 
|[] -> false
|hd::tl -> if (hd = v) then true
 else isexist (tl) (v))

let rec chkvars  : (lambda -> (var list -> bool)) = 
fun lambda vars -> 
 (match lambda with 
|V v -> isexist (vars) (v)
|P (v, e) -> chkvars (e) ((v :: vars))
|C (V v, e) -> chkvars (e) ((v :: vars)))

let check  : (lambda -> bool) = 
fun lambda -> chkvars (lambda) ([])

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec isexist  : (var list -> (var -> bool)) = (60560, 
fun vars v -> (60558, 
 (match (60546, vars with 
|[] -> (60547, false
|hd::tl -> (60557, if (60550, ((60548, hd = (60549, v) then (60551, true
 else (60556, (60555, (60552, isexist ((60553, tl) ((60554, v))

let rec chkvars  : (lambda -> (var list -> bool)) = (60583, 
fun lambda vars -> (60581, 
 (match (60561, lambda with 
|V v -> (60566, (60565, (60562, isexist ((60563, vars) ((60564, v)
|P (v, e) -> (60573, (60572, (60567, chkvars ((60568, e) ((60571, ((60569, v :: (60570, vars))
|C (V v, e) -> (60580, (60579, (60574, chkvars ((60575, e) ((60578, ((60576, v :: (60577, vars)))

let check  : (lambda -> bool) = (60589, 
fun lambda -> (60588, (60587, (60584, chkvars ((60585, lambda) ((60586, [])

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub51.ml Score : 3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec findlst  : (var list -> (var -> bool)) = 
fun lst v -> 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = v) then true
 else findlst (tl) (v))

let rec mycheck  : (lambda -> (var list -> bool)) = 
fun lam lst -> 
 (match lam with 
|V x -> findlst (lst) (x)
|P (x, e) -> mycheck (e) ((x :: lst))
|C (e1, e2) -> (mycheck (e1) (lst) && mycheck (e2) (lst)))

let check  : (lambda -> bool) = 
fun lam -> mycheck (lam) ([])

let t1  = P (("a", V ("a")))

let t2  = P (("a", P (("a", V ("a")))))

let t3  = P (("a", P (("b", C ((V ("a"), V ("b")))))))

let t4  = P (("a", C ((V ("a"), P (("b", V ("a")))))))

let t5  = P (("a", V ("b")))

let t6  = P (("a", C ((V ("a"), P (("b", V ("c")))))))

let t7  = P (("a", P (("b", C ((V ("a"), V ("c")))))))

let _  = check (t1)

let _  = check (t2)

let _  = check (t3)

let _  = check (t4)

let _  = check (t5)

let _  = check (t6)

let _  = check (t7)

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (48425 : 
Input : (lambda : lambda) 
Output : bool
Body : chkvars (lambda) ([]),

chkvars -> (48424 : 
Input : (lambda : lambda) (vars : string list) 
Output : bool
Body : 
 (match lambda with 
|V v -> isexist (vars) (v)
|P (v, e) -> chkvars (e) ((v :: vars))
|C (V v, e) -> chkvars (e) ((v :: vars))),

isexist -> (48423 : 
Input : (vars : #7532 list) (v : string) 
Output : bool
Body : 
 (match vars with 
|[] -> false
|hd::tl -> if (hd = v) then true
 else isexist (tl) (v))}
Edge : 
{(48423, 48423) -> ,
(48424, 48423) -> ,
(48424, 48424) -> ,
(48425, 48424) -> }
Starting : 48425
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (48388 : 
Input : (lam : lambda) 
Output : bool
Body : mycheck (lam) ([]),

findlst -> (48386 : 
Input : (lst : #7469 list) (v : string) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = v) then true
 else findlst (tl) (v)),

mycheck -> (48387 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lam with 
|V x -> findlst (lst) (x)
|P (x, e) -> mycheck (e) ((x :: lst))
|C (e1, e2) -> (mycheck (e1) (lst) && mycheck (e2) (lst)))}
Edge : 
{(48386, 48386) -> ,
(48387, 48386) -> ,
(48387, 48387) -> ,
(48388, 48387) -> }
Starting : 48388
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
chkvars -> mycheck,
isexist -> findlst}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60548 : ?)

Decls : 
,Exp : Modify (60549 : ?)

Decls : 
,Exp : Modify (60556 : ? (?) (?))

Decls : 
,Exp : Modify (60561 : ?)

Decls : 
,Exp : Modify (60566 : ? (?) (?))

Decls : 
,Exp : Modify (60573 : ? (?) ((? :: ?)))

Decls : 
,Exp : Modify (60588 : ? (?) ([]))

Decls : 
,Exp : Insert (C (e1, e2) -> (? (?) (?) && ? (?) (?)) At label 60581

Decls : 
,Exp : Delete (C (V v, e) -> chkvars (e) ((v :: vars)) At label 60581

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60548 : ?)

Decls : 
,Exp : Modify (60549 : ?)

Decls : 
,Exp : Modify (60556 : ? (?) (?))

Decls : 
,Exp : Modify (60561 : ?)

Decls : 
,Exp : Modify (60566 : ? (?) (?))

Decls : 
,Exp : Modify (60573 : ? (?) ((? :: ?)))

Decls : 
,Exp : Modify (60588 : ? (?) ([]))

Decls : 
,Exp : Insert (C (e1, e2) -> (? (?) (?) && ? (?) (?)) At label 60581

Decls : 
,Exp : Delete (C (V v, e) -> chkvars (e) ((v :: vars)) At label 60581

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec isexist  : (var list -> (var -> bool)) = 
fun vars v -> 
 (match vars with 
|[] -> false
|hd::tl -> if (hd = v) then true
 else isexist (tl) (v))

let rec chkvars  : (lambda -> (var list -> bool)) = 
fun lambda vars -> 
 (match lambda with 
|V v -> isexist (vars) (v)
|P (v, e) -> chkvars (e) ((v :: vars))
|C (e1, e2) -> (chkvars (e2) (vars) && chkvars (e1) (vars))
|C (V v, e) -> chkvars (e) ((v :: vars)))

let check  : (lambda -> bool) = 
fun lambda -> chkvars (lambda) ([])

Time : 0.210289955139
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub112.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check  : (lambda -> bool) = 
fun lambda -> false

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check  : (lambda -> bool) = (60547, 
fun lambda -> (60546, false

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : lambda 
Output : bool
Body : false}
Edge : 
empty
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let check  : (lambda -> bool) = 
fun lambda -> checking (lambda) ([])

Time : 0.00136804580688
Error occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub121.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub123.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec makePList lambda pl  = 
 (match lambda with 
|V v -> pl
|P (v, e) -> (pl @ ([v] @ makePList (e) (pl)))
|C (e1, e2) -> (makePList (e1) (pl) @ makePList (e2) (pl)))

let rec makeVList lambda vl  = 
 (match lambda with 
|V v -> (vl @ [v])
|P (v, e) -> (vl @ makeVList (e) (vl))
|C (e1, e2) -> (makeVList (e1) (vl) @ makeVList (e2) (vl)))

let rec compareToPlist pl e  = 
 (match pl with 
|[] -> false
|hd::tl -> ((e = hd) || compareToPlist (tl) (e)))

let rec compareList pl vl  = 
 (match vl with 
|[] -> true
|hd::tl -> (compareList (pl) (tl) && compareToPlist (pl) (hd)))

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V v -> false
|P (v, e) -> 
let pl  = makePList (lambda) ([])
 in 

let vl  = makeVList (lambda) ([])
 in 
compareList (pl) (vl)
|C (e1, e2) -> (check (e1) && check (e2)))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec makePList lambda pl  = (60569, 
 (match (60546, lambda with 
|V v -> (60547, pl
|P (v, e) -> (60557, ((60548, pl @ (60556, ((60550, [(60549, v] @ (60555, (60554, (60551, makePList ((60552, e) ((60553, pl)))
|C (e1, e2) -> (60568, ((60562, (60561, (60558, makePList ((60559, e1) ((60560, pl) @ (60567, (60566, (60563, makePList ((60564, e2) ((60565, pl)))

let rec makeVList lambda vl  = (60593, 
 (match (60570, lambda with 
|V v -> (60574, ((60571, vl @ (60573, [(60572, v])
|P (v, e) -> (60581, ((60575, vl @ (60580, (60579, (60576, makeVList ((60577, e) ((60578, vl))
|C (e1, e2) -> (60592, ((60586, (60585, (60582, makeVList ((60583, e1) ((60584, vl) @ (60591, (60590, (60587, makeVList ((60588, e2) ((60589, vl)))

let rec compareToPlist pl e  = (60605, 
 (match (60594, pl with 
|[] -> (60595, false
|hd::tl -> (60604, ((60598, ((60596, e = (60597, hd) || (60603, (60602, (60599, compareToPlist ((60600, tl) ((60601, e)))

let rec compareList pl vl  = (60619, 
 (match (60606, vl with 
|[] -> (60607, true
|hd::tl -> (60618, ((60612, (60611, (60608, compareList ((60609, pl) ((60610, tl) && (60617, (60616, (60613, compareToPlist ((60614, pl) ((60615, hd)))

let rec check  : (lambda -> bool) = (60647, 
fun lambda -> (60646, 
 (match (60620, lambda with 
|V v -> (60621, false
|P (v, e) -> (60638, 
let pl  = (60626, (60625, (60622, makePList ((60623, lambda) ((60624, [])
 in 
(60637, 
let vl  = (60631, (60630, (60627, makeVList ((60628, lambda) ((60629, [])
 in 
(60636, (60635, (60632, compareList ((60633, pl) ((60634, vl)
|C (e1, e2) -> (60645, ((60641, (60639, check ((60640, e1) && (60644, (60642, check ((60643, e2)))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub55.ml Score : 1
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checklambda  : (var list -> (lambda -> bool)) = 
fun lst lam -> 
 (match lam with 
|V x -> __list_mem__ (x) (lst)
|P (x, l) -> checklambda ((x :: lst)) (l)
|C (l1, l2) -> (checklambda (lst) (l1) && checklambda (lst) (l2)))

let check  : (lambda -> bool) = 
fun lam -> checklambda ([]) (lam)

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (51069 : 
Input : (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|V v -> false
|P (v, e) -> 
let pl  : string list = makePList (lambda) ([])
 in 

let vl  : string list = makeVList (lambda) ([])
 in 
compareList (pl) (vl)
|C (e1, e2) -> (check (e1) && check (e2))),

compareList -> (51068 : 
Input : (pl : #1024308 list) (vl : #1024308 list) 
Output : bool
Body : 
 (match vl with 
|[] -> true
|hd::tl -> (compareList (pl) (tl) && compareToPlist (pl) (hd))),

compareToPlist -> (51067 : 
Input : (pl : #1024300 list) e 
Output : bool
Body : 
 (match pl with 
|[] -> false
|hd::tl -> ((e = hd) || compareToPlist (tl) (e))),

makePList -> (51065 : 
Input : (lambda : lambda) (pl : string list) 
Output : string list
Body : 
 (match lambda with 
|V v -> pl
|P (v, e) -> (pl @ ([v] @ makePList (e) (pl)))
|C (e1, e2) -> (makePList (e1) (pl) @ makePList (e2) (pl))),

makeVList -> (51066 : 
Input : (lambda : lambda) (vl : string list) 
Output : string list
Body : 
 (match lambda with 
|V v -> (vl @ [v])
|P (v, e) -> (vl @ makeVList (e) (vl))
|C (e1, e2) -> (makeVList (e1) (vl) @ makeVList (e2) (vl)))}
Edge : 
{(51065, 51065) -> ,
(51066, 51066) -> ,
(51067, 51067) -> ,
(51068, 51067) -> ,
(51068, 51068) -> ,
(51069, 51065) -> ,
(51069, 51066) -> ,
(51069, 51068) -> ,
(51069, 51069) -> }
Starting : 51069
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{__list_mem__ -> (51005 : 
Input : elem (lst : #1023162 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (51031 : 
Input : (lam : lambda) 
Output : bool
Body : checklambda ([]) (lam),

checklambda -> (51030 : 
Input : (lst : string list) (lam : lambda) 
Output : bool
Body : 
 (match lam with 
|V x -> __list_mem__ (x) (lst)
|P (x, l) -> checklambda ((x :: lst)) (l)
|C (l1, l2) -> (checklambda (lst) (l1) && checklambda (lst) (l2)))}
Edge : 
{(51005, 51005) -> ,
(51030, 51005) -> ,
(51030, 51030) -> ,
(51031, 51030) -> }
Starting : 51031
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
compareList -> __list_mem__,
compareToPlist -> checklambda}
------Remainings in submission ------
{makePList,makeVList}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60594 : ?)

Decls : 
,Exp : Modify (60606 : ?)

Decls : 
,Exp : Modify (60607 : false)

Decls : 
,Exp : Modify (60618 : ((? = ?) || ? (?) (?)))

Decls : 
,Exp : Modify (60646 : ? ([]) (?))

Decls : 
,Exp : Insert (C (l1, l2) -> (? (?) (?) && ? (?) (?)) At label 60605

Decls : 
,Exp : Insert (P (x, l) -> ? ((? :: ?)) (?) At label 60605

Decls : 
,Exp : Insert (V x -> ? (?) (?) At label 60605

Decls : 
,Exp : Delete ([] -> false At label 60605

Decls : 
,Exp : Delete (hd::tl -> ((e = hd) || compareToPlist (tl) (e)) At label 60605

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60594 : ?)

Decls : 
,Exp : Modify (60606 : ?)

Decls : 
,Exp : Modify (60607 : false)

Decls : 
,Exp : Modify (60618 : ((? = ?) || ? (?) (?)))

Decls : 
,Exp : Modify (60646 : ? ([]) (?))

Decls : 
,Exp : Insert (C (l1, l2) -> (? (?) (?) && ? (?) (?)) At label 60605

Decls : 
,Exp : Insert (P (x, l) -> ? ((? :: ?)) (?) At label 60605

Decls : 
,Exp : Insert (V x -> ? (?) (?) At label 60605

Decls : 
,Exp : Delete ([] -> false At label 60605

Decls : 
,Exp : Delete (hd::tl -> ((e = hd) || compareToPlist (tl) (e)) At label 60605

Decls : 
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub124.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec bound  : (lambda -> var list) = 
fun lambda -> 
 (match lambda with 
|V var -> []
|P (var, ex) -> (var :: bound (ex))
|C (ex1, ex2) -> (bound (ex1) @ bound (ex2)))

let rec variables  : (lambda -> var list) = 
fun lambda -> 
 (match lambda with 
|V var -> [var]
|P (var, ex) -> variables (ex)
|C (ex1, ex2) -> (variables (ex1) @ variables (ex2)))

let rec containHelper  : ((var list * var) -> bool) = 
fun (bound, a) -> 
 (match (bound, a) with 
|([], a) -> false
|(x::tl, a) -> if (x = a) then true
 else containHelper ((tl, a)))

let rec contain  : ((var list * var list) -> bool) = 
fun (bound, variables) -> 
 (match (bound, variables) with 
|([], variables) -> false
|(bound, []) -> true
|(bound, a::tl) -> if (containHelper ((bound, a)) = false) then false
 else contain ((bound, tl)))

let check  : (lambda -> bool) = 
fun lambda -> contain ((bound (lambda), variables (lambda)))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec bound  : (lambda -> var list) = (60561, 
fun lambda -> (60560, 
 (match (60546, lambda with 
|V var -> (60547, []
|P (var, ex) -> (60552, ((60548, var :: (60551, (60549, bound ((60550, ex))
|C (ex1, ex2) -> (60559, ((60555, (60553, bound ((60554, ex1) @ (60558, (60556, bound ((60557, ex2)))

let rec variables  : (lambda -> var list) = (60576, 
fun lambda -> (60575, 
 (match (60562, lambda with 
|V var -> (60564, [(60563, var]
|P (var, ex) -> (60567, (60565, variables ((60566, ex)
|C (ex1, ex2) -> (60574, ((60570, (60568, variables ((60569, ex1) @ (60573, (60571, variables ((60572, ex2)))

let rec containHelper  : ((var list * var) -> bool) = (60592, 
fun (bound, a) -> (60591, 
 (match (60579, ((60577, bound, (60578, a) with 
|([], a) -> (60580, false
|(x::tl, a) -> (60590, if (60583, ((60581, x = (60582, a) then (60584, true
 else (60589, (60585, containHelper ((60588, ((60586, tl, (60587, a)))

let rec contain  : ((var list * var list) -> bool) = (60613, 
fun (bound, variables) -> (60612, 
 (match (60595, ((60593, bound, (60594, variables) with 
|([], variables) -> (60596, false
|(bound, []) -> (60597, true
|(bound, a::tl) -> (60611, if (60604, ((60602, (60598, containHelper ((60601, ((60599, bound, (60600, a)) = (60603, false) then (60605, false
 else (60610, (60606, contain ((60609, ((60607, bound, (60608, tl)))

let check  : (lambda -> bool) = (60623, 
fun lambda -> (60622, (60614, contain ((60621, ((60617, (60615, bound ((60616, lambda), (60620, (60618, variables ((60619, lambda)))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/15/sub60.ml Score : 1
-----------------------------
type var = string
type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)

let rec contains  = 
fun (l, item) -> 
 (match l with 
|[] -> false
|h::tail -> if (item = h) then true
 else contains ((tail, item)))

let rec lambda  = 
fun (l, m) -> 
 (match m with 
|V n -> contains ((l, n))
|P (id, area) -> lambda (((id :: l), area))
|C (m1, m2) -> (lambda ((l, m1)) && lambda ((l, m2))))

let check  = 
fun m -> lambda (([], m))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{bound -> (51067 : 
Input : (lambda : lambda) 
Output : var list
Body : 
 (match lambda with 
|V var -> []
|P (var, ex) -> (var :: bound (ex))
|C (ex1, ex2) -> (bound (ex1) @ bound (ex2))),

check -> (51071 : 
Input : (lambda : lambda) 
Output : bool
Body : contain ((bound (lambda), variables (lambda))),

contain -> (51070 : 
Input : ((bound : #1024340 list), (variables : #1024340 list)) 
Output : bool
Body : 
 (match (bound, variables) with 
|([], variables) -> false
|(bound, []) -> true
|(bound, a::tl) -> if (containHelper ((bound, a)) = false) then false
 else contain ((bound, tl))),

containHelper -> (51069 : 
Input : ((bound : #1024324 list), a) 
Output : bool
Body : 
 (match (bound, a) with 
|([], a) -> false
|(x::tl, a) -> if (x = a) then true
 else containHelper ((tl, a))),

variables -> (51068 : 
Input : (lambda : lambda) 
Output : var list
Body : 
 (match lambda with 
|V var -> [var]
|P (var, ex) -> variables (ex)
|C (ex1, ex2) -> (variables (ex1) @ variables (ex2)))}
Edge : 
{(51067, 51067) -> ,
(51068, 51068) -> ,
(51069, 51069) -> ,
(51070, 51069) -> ,
(51070, 51070) -> ,
(51071, 51067) -> ,
(51071, 51068) -> ,
(51071, 51070) -> }
Starting : 51071
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (51032 : 
Input : (m : lambda) 
Output : bool
Body : lambda (([], m)),

contains -> (51030 : 
Input : ((l : #1023554 list), item) 
Output : bool
Body : 
 (match l with 
|[] -> false
|h::tail -> if (item = h) then true
 else contains ((tail, item))),

lambda -> (51031 : 
Input : ((l : string list), (m : lambda)) 
Output : bool
Body : 
 (match m with 
|V n -> contains ((l, n))
|P (id, area) -> lambda (((id :: l), area))
|C (m1, m2) -> (lambda ((l, m1)) && lambda ((l, m2))))}
Edge : 
{(51030, 51030) -> ,
(51031, 51030) -> ,
(51031, 51031) -> ,
(51032, 51031) -> }
Starting : 51032
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
contain -> contains,
containHelper -> lambda}
------Remainings in submission ------
{bound,variables}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60579 : ?)

Decls : 
,Exp : Modify (60595 : ?)

Decls : 
,Exp : Modify (60622 : ? (([], ?)))

Decls : 
,Exp : Insert (C (m1, m2) -> (? ((?, ?)) && ? ((?, ?))) At label 60591

Decls : 
,Exp : Insert (P (id, area) -> ? (((? :: ?), ?)) At label 60591

Decls : 
,Exp : Insert (V n -> ? ((?, ?)) At label 60591

Decls : 
,Exp : Insert ([] -> false At label 60612

Decls : 
,Exp : Insert (h::tail -> if (? = ?) then true
 else ? ((?, ?)) At label 60612

Decls : 
,Exp : Delete (([], a) -> false At label 60591

Decls : 
,Exp : Delete ((x::tl, a) -> if (x = a) then true
 else containHelper ((tl, a)) At label 60591

Decls : 
,Exp : Delete ((bound, []) -> true At label 60612

Decls : 
,Exp : Delete ((bound, a::tl) -> if (containHelper ((bound, a)) = false) then false
 else contain ((bound, tl)) At label 60612

Decls : 
,Exp : Delete (([], variables) -> false At label 60612

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60579 : ?)

Decls : 
,Exp : Modify (60595 : ?)

Decls : 
,Exp : Modify (60622 : ? (([], ?)))

Decls : 
,Exp : Insert (C (m1, m2) -> (? ((?, ?)) && ? ((?, ?))) At label 60591

Decls : 
,Exp : Insert (P (id, area) -> ? (((? :: ?), ?)) At label 60591

Decls : 
,Exp : Insert (V n -> ? ((?, ?)) At label 60591

Decls : 
,Exp : Insert ([] -> false At label 60612

Decls : 
,Exp : Insert (h::tail -> if (? = ?) then true
 else ? ((?, ?)) At label 60612

Decls : 
,Exp : Delete (([], a) -> false At label 60591

Decls : 
,Exp : Delete ((x::tl, a) -> if (x = a) then true
 else containHelper ((tl, a)) At label 60591

Decls : 
,Exp : Delete ((bound, []) -> true At label 60612

Decls : 
,Exp : Delete ((bound, a::tl) -> if (containHelper ((bound, a)) = false) then false
 else contain ((bound, tl)) At label 60612

Decls : 
,Exp : Delete (([], variables) -> false At label 60612

Decls : 
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub125.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V var -> false
|P (var1, V var2) -> if (var1 = var2) then true
 else false
|P (var1, C (V var2, P (var3, V var4))) -> if (((var1 = var4) || (var2 = var4)) || (var3 = var4)) then true
 else false
|P (var1, P (var2, V var3)) -> if ((var1 = var3) || (var2 = var3)) then true
 else false
|P (var1, P (var2, C (V var3, V var4))) -> if (((var1 = var3) || (var2 = var3)) && ((var1 = var4) || (var2 = var4))) then true
 else false
|C (V var1, V var2) -> false
|P (var1, P (var2, P (var3, V var4))) -> if (((var1 = var4) || (var2 = var4)) || (var3 = var4)) then true
 else false)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check  : (lambda -> bool) = (60612, 
fun lambda -> (60611, 
 (match (60546, lambda with 
|V var -> (60547, false
|P (var1, V var2) -> (60553, if (60550, ((60548, var1 = (60549, var2) then (60551, true
 else (60552, false
|P (var1, C (V var2, P (var3, V var4))) -> (60567, if (60564, ((60560, ((60556, ((60554, var1 = (60555, var4) || (60559, ((60557, var2 = (60558, var4)) || (60563, ((60561, var3 = (60562, var4)) then (60565, true
 else (60566, false
|P (var1, P (var2, V var3)) -> (60577, if (60574, ((60570, ((60568, var1 = (60569, var3) || (60573, ((60571, var2 = (60572, var3)) then (60575, true
 else (60576, false
|P (var1, P (var2, C (V var3, V var4))) -> (60595, if (60592, ((60584, ((60580, ((60578, var1 = (60579, var3) || (60583, ((60581, var2 = (60582, var3)) && (60591, ((60587, ((60585, var1 = (60586, var4) || (60590, ((60588, var2 = (60589, var4))) then (60593, true
 else (60594, false
|C (V var1, V var2) -> (60596, false
|P (var1, P (var2, P (var3, V var4))) -> (60610, if (60607, ((60603, ((60599, ((60597, var1 = (60598, var4) || (60602, ((60600, var2 = (60601, var4)) || (60606, ((60604, var3 = (60605, var4)) then (60608, true
 else (60609, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|V var -> false
|P (var1, V var2) -> if (var1 = var2) then true
 else false
|P (var1, C (V var2, P (var3, V var4))) -> if (((var1 = var4) || (var2 = var4)) || (var3 = var4)) then true
 else false
|P (var1, P (var2, V var3)) -> if ((var1 = var3) || (var2 = var3)) then true
 else false
|P (var1, P (var2, C (V var3, V var4))) -> if (((var1 = var3) || (var2 = var3)) && ((var1 = var4) || (var2 = var4))) then true
 else false
|C (V var1, V var2) -> false
|P (var1, P (var2, P (var3, V var4))) -> if (((var1 = var4) || (var2 = var4)) || (var3 = var4)) then true
 else false)}
Edge : 
empty
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60611 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60611 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let check  : (lambda -> bool) = 
fun lambda -> checking (lambda) ([])

Time : 0.00138902664185
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub128.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V _ -> false
|C (_, _) -> false
|P (x, V y) -> if (x = y) then true
 else false
|P (x, P (y, z)) -> if ((x = y) && check (P ((x, z)))) then true
 else false
|P (x, C (y, z)) -> (check (P ((x, y))) && check (P ((x, z)))))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = (60582, 
fun lambda -> (60581, 
 (match (60546, lambda with 
|V _ -> (60547, false
|C (_, _) -> (60548, false
|P (x, V y) -> (60554, if (60551, ((60549, x = (60550, y) then (60552, true
 else (60553, false
|P (x, P (y, z)) -> (60567, if (60564, ((60557, ((60555, x = (60556, y) && (60563, (60558, check ((60562, P ((60561, ((60559, x, (60560, z)))) then (60565, true
 else (60566, false
|P (x, C (y, z)) -> (60580, ((60573, (60568, check ((60572, P ((60571, ((60569, x, (60570, y))) && (60579, (60574, check ((60578, P ((60577, ((60575, x, (60576, z)))))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|V _ -> false
|C (_, _) -> false
|P (x, V y) -> if (x = y) then true
 else false
|P (x, P (y, z)) -> if ((x = y) && check (P ((x, z)))) then true
 else false
|P (x, C (y, z)) -> (check (P ((x, y))) && check (P ((x, z)))))}
Edge : 
{(45777, 45777) -> }
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60581 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60581 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lambda -> checking (lambda) ([])

Time : 0.00147104263306
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub13.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let isinthelist l a  = 
let temp  = __list_filter__ (
fun x y -> if (x != y) then false
 else true (a)) (l)
 in 

 (match temp with 
|[] -> false
|hd::tl -> true)

let isnotinthelist l a  = 
let temp  = __list_filter__ (
fun x y -> if (x != y) then false
 else true (a)) (l)
 in 

 (match temp with 
|[] -> true
|hd::tl -> false)

let rec pvar e  = 
 (match e with 
|P (s0, e0) -> (s0 :: pvar (e0))
|C (e0, e1) -> (pvar (e0) @ pvar (e1))
|V s0 -> [])

let rec vvar e  = 
 (match e with 
|P (s0, e0) -> vvar (e0)
|C (e0, e1) -> (vvar (e0) @ vvar (e1))
|V s0 -> (s0 :: []))

let rec check e  = 
let l0  = pvar (e)
 in 

let l1  = vvar (e)
 in 

 (match __list_filter__ (isnotinthelist (l0)) (l1) with 
|[] -> true
|hd::tl -> false)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let isinthelist l a  = (60564, 
let temp  = (60559, (60558, (60546, __list_filter__ ((60556, (60554, 
fun x y -> (60552, if (60549, ((60547, x != (60548, y) then (60550, false
 else (60551, true ((60555, a)) ((60557, l)
 in 
(60563, 
 (match (60560, temp with 
|[] -> (60561, false
|hd::tl -> (60562, true)

let isnotinthelist l a  = (60583, 
let temp  = (60578, (60577, (60565, __list_filter__ ((60575, (60573, 
fun x y -> (60571, if (60568, ((60566, x != (60567, y) then (60569, false
 else (60570, true ((60574, a)) ((60576, l)
 in 
(60582, 
 (match (60579, temp with 
|[] -> (60580, true
|hd::tl -> (60581, false)

let rec pvar e  = (60598, 
 (match (60584, e with 
|P (s0, e0) -> (60589, ((60585, s0 :: (60588, (60586, pvar ((60587, e0))
|C (e0, e1) -> (60596, ((60592, (60590, pvar ((60591, e0) @ (60595, (60593, pvar ((60594, e1))
|V s0 -> (60597, [])

let rec vvar e  = (60613, 
 (match (60599, e with 
|P (s0, e0) -> (60602, (60600, vvar ((60601, e0)
|C (e0, e1) -> (60609, ((60605, (60603, vvar ((60604, e0) @ (60608, (60606, vvar ((60607, e1))
|V s0 -> (60612, ((60610, s0 :: (60611, []))

let rec check e  = (60631, 
let l0  = (60616, (60614, pvar ((60615, e)
 in 
(60630, 
let l1  = (60619, (60617, vvar ((60618, e)
 in 
(60629, 
 (match (60626, (60625, (60620, __list_filter__ ((60623, (60621, isnotinthelist ((60622, l0)) ((60624, l1) with 
|[] -> (60627, true
|hd::tl -> (60628, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_15/sub65.ml Score : 2
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec free_vars  = 
fun __fun__ -> 
 (match __fun__ with 
|V v -> [v]
|P (v, e) -> __list_filter__ (
fun x -> (x != v)) (free_vars (e))
|C (e1, e2) -> 
let f_e1  = free_vars (e1)
 in 

let f_e2  = free_vars (e2)
 in 
__list_append__ (f_e1) (__list_filter__ (
fun x -> not (__list_mem__ (x) (f_e1))) (f_e2)))

let rec fresh_var v1 l  = if __list_mem__ (v1) (l) then fresh_var ((v1 ^ "'")) (l)
 else v1

let check  : (lambda -> bool) = 
fun e -> if (free_vars (e) = []) then true
 else false

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{__list_filter__ -> (51044 : 
Input : (pred : (#1006728 -> bool)) (lst : #1006728 list) 
Output : #1006672 list
Body : 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl)),

check -> (51071 : 
Input : (e : lambda) 
Output : bool
Body : 
let l0  : string list = pvar (e)
 in 

let l1  : string list = vvar (e)
 in 

 (match __list_filter__ (isnotinthelist (l0)) (l1) with 
|[] -> true
|hd::tl -> false),

isnotinthelist -> (51068 : 
Input : (l : #1007116 list) a 
Output : bool
Body : 
let temp  : #1007116 list = __list_filter__ (
fun x y -> if (x != y) then false
 else true (a)) (l)
 in 

 (match temp with 
|[] -> true
|hd::tl -> false),

pvar -> (51069 : 
Input : (e : lambda) 
Output : string list
Body : 
 (match e with 
|P (s0, e0) -> (s0 :: pvar (e0))
|C (e0, e1) -> (pvar (e0) @ pvar (e1))
|V s0 -> []),

vvar -> (51070 : 
Input : (e : lambda) 
Output : string list
Body : 
 (match e with 
|P (s0, e0) -> vvar (e0)
|C (e0, e1) -> (vvar (e0) @ vvar (e1))
|V s0 -> (s0 :: []))}
Edge : 
{(51044, 51044) -> ,
(51068, 51044) -> ,
(51069, 51069) -> ,
(51070, 51070) -> ,
(51071, 51044) -> ,
(51071, 51068) -> ,
(51071, 51069) -> ,
(51071, 51070) -> }
Starting : 51071
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{__list_append__ -> (51008 : 
Input : (lst1 : #1006012 list) (lst2 : #1006012 list) 
Output : #1005949 list
Body : (lst1 @ lst2),

__list_filter__ -> (51007 : 
Input : (pred : (#1006005 -> bool)) (lst : #1006005 list) 
Output : #1005949 list
Body : 
 (match lst with 
|[] -> []
|hd::tl -> if pred (hd) then (hd :: __list_filter__ (pred) (tl))
 else __list_filter__ (pred) (tl)),

__list_mem__ -> (51005 : 
Input : elem (lst : #1005981 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (51032 : 
Input : (e : lambda) 
Output : bool
Body : if (free_vars (e) = []) then true
 else false,

free_vars -> (51030 : 
Input : (__fun__ : lambda) 
Output : string list
Body : 
 (match __fun__ with 
|V v -> [v]
|P (v, e) -> __list_filter__ (
fun (x : string) -> (x != v)) (free_vars (e))
|C (e1, e2) -> 
let f_e1  : string list = free_vars (e1)
 in 

let f_e2  : string list = free_vars (e2)
 in 
__list_append__ (f_e1) (__list_filter__ (
fun (x : string) -> not (__list_mem__ (x) (f_e1))) (f_e2)))}
Edge : 
{(51005, 51005) -> ,
(51007, 51007) -> ,
(51030, 51005) -> ,
(51030, 51007) -> ,
(51030, 51008) -> ,
(51030, 51030) -> ,
(51032, 51030) -> }
Starting : 51032
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{__list_filter__ -> __list_filter__,
check -> check,
isnotinthelist -> __list_mem__,
pvar -> free_vars}
------Remainings in submission ------
{vvar}
------Remainings in solution ------
{__list_append__}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60583 : 
 (match ? with 
|[] -> false
|hd::tl -> ((? = ?) || ? (?) (?))))

Decls : 
,Exp : Modify (60584 : ?)

Decls : 
,Exp : Modify (60589 : ? (
fun (x : string) -> (? != ?)) (? (?)))

Decls : 
,Exp : Modify (60596 : 
let f_e1  : string list = ? (?)
 in 

let f_e2  : string list = ? (?)
 in 
? (?) (? (
fun (x : string) -> not (? (?) (?))) (?)))

Decls : 

let __list_append__ (lst1 : #1009032 list) (lst2 : #1009032 list)  : #1008969 list = (lst1 @ lst2)

Callers : {pvar}
,Exp : Modify (60597 : [?])

Decls : 
,Exp : Modify (60631 : if (? (?) = []) then true
 else false)

Decls : 

let __list_append__ (lst1 : #1009032 list) (lst2 : #1009032 list)  : #1008969 list = (lst1 @ lst2)

Callers : {pvar}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60583 : 
 (match ? with 
|[] -> false
|hd::tl -> ((? = ?) || ? (?) (?))))

Decls : 
,Exp : Modify (60584 : ?)

Decls : 
,Exp : Modify (60589 : ? (
fun (x : string) -> (? != ?)) (? (?)))

Decls : 
,Exp : Modify (60596 : 
let f_e1  : string list = ? (?)
 in 

let f_e2  : string list = ? (?)
 in 
? (?) (? (
fun (x : string) -> not (? (?) (?))) (?)))

Decls : 

let __list_append__ (lst1 : #1009032 list) (lst2 : #1009032 list)  : #1008969 list = (lst1 @ lst2)

Callers : {pvar}
,Exp : Modify (60597 : [?])

Decls : 
,Exp : Modify (60631 : if (? (?) = []) then true
 else false)

Decls : 

let __list_append__ (lst1 : #1009032 list) (lst2 : #1009032 list)  : #1008969 list = (lst1 @ lst2)

Callers : {pvar}
}
Fail to Repair
Error occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub16.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub20.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec isin  : ((var * var list) -> bool) = 
fun (str, lst) -> 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = str) then true
 else isin ((str, tl)))

let rec filter lst lst2  = 
 (match lst with 
|[] -> true
|hd::tl -> if (isin ((hd, lst2)) = true) then filter (tl) (lst2)
 else false)

let rec bool_check  : ((lambda * var list) -> var list) = 
fun (lambda, lst) -> 
 (match lambda with 
|V str -> lst
|P (e1, e2) -> bool_check ((e2, ([e1] @ lst)))
|C (e1, e2) -> (bool_check ((e1, lst)) @ bool_check ((e2, lst))))

let rec cal_check  : ((lambda * var list) -> var list) = 
fun (lambda, lst) -> 
 (match lambda with 
|V str -> (str :: lst)
|P (e1, e2) -> cal_check ((e2, lst))
|C (e1, e2) -> (cal_check ((e1, lst)) @ cal_check ((e2, lst))))

let check  : (lambda -> bool) = 
fun lambda -> if (filter (cal_check ((lambda, []))) (bool_check ((lambda, []))) = true) then true
 else false

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec isin  : ((var * var list) -> bool) = (60559, 
fun (str, lst) -> (60558, 
 (match (60546, lst with 
|[] -> (60547, false
|hd::tl -> (60557, if (60550, ((60548, hd = (60549, str) then (60551, true
 else (60556, (60552, isin ((60555, ((60553, str, (60554, tl)))

let rec filter lst lst2  = (60576, 
 (match (60560, lst with 
|[] -> (60561, true
|hd::tl -> (60575, if (60568, ((60566, (60562, isin ((60565, ((60563, hd, (60564, lst2)) = (60567, true) then (60573, (60572, (60569, filter ((60570, tl) ((60571, lst2)
 else (60574, false)

let rec bool_check  : ((lambda * var list) -> var list) = (60599, 
fun (lambda, lst) -> (60598, 
 (match (60577, lambda with 
|V str -> (60578, lst
|P (e1, e2) -> (60586, (60579, bool_check ((60585, ((60580, e2, (60584, ((60582, [(60581, e1] @ (60583, lst)))
|C (e1, e2) -> (60597, ((60591, (60587, bool_check ((60590, ((60588, e1, (60589, lst)) @ (60596, (60592, bool_check ((60595, ((60593, e2, (60594, lst))))

let rec cal_check  : ((lambda * var list) -> var list) = (60621, 
fun (lambda, lst) -> (60620, 
 (match (60600, lambda with 
|V str -> (60603, ((60601, str :: (60602, lst)
|P (e1, e2) -> (60608, (60604, cal_check ((60607, ((60605, e2, (60606, lst))
|C (e1, e2) -> (60619, ((60613, (60609, cal_check ((60612, ((60610, e1, (60611, lst)) @ (60618, (60614, cal_check ((60617, ((60615, e2, (60616, lst))))

let check  : (lambda -> bool) = (60640, 
fun lambda -> (60639, if (60636, ((60634, (60633, (60622, filter ((60627, (60623, cal_check ((60626, ((60624, lambda, (60625, []))) ((60632, (60628, bool_check ((60631, ((60629, lambda, (60630, []))) = (60635, true) then (60637, true
 else (60638, false

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_15/sub9.ml Score : 1
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check  : (lambda -> bool) = 
fun e -> true

let rec ch (e, l)  = 
 (match e with 
|V v -> if __list_mem__ (v) (l) then true
 else false
|P (v, ex) -> ch ((ex, (l @ [v])))
|C (e1, e2) -> (ch ((e1, l)) && ch ((e2, l))))

let check e  = ch ((e, []))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{bool_check -> (51069 : 
Input : ((lambda : lambda), (lst : string list)) 
Output : var list
Body : 
 (match lambda with 
|V str -> lst
|P (e1, e2) -> bool_check ((e2, ([e1] @ lst)))
|C (e1, e2) -> (bool_check ((e1, lst)) @ bool_check ((e2, lst)))),

cal_check -> (51070 : 
Input : ((lambda : lambda), (lst : string list)) 
Output : var list
Body : 
 (match lambda with 
|V str -> (str :: lst)
|P (e1, e2) -> cal_check ((e2, lst))
|C (e1, e2) -> (cal_check ((e1, lst)) @ cal_check ((e2, lst)))),

check -> (51071 : 
Input : (lambda : lambda) 
Output : bool
Body : if (filter (cal_check ((lambda, []))) (bool_check ((lambda, []))) = true) then true
 else false,

filter -> (51068 : 
Input : (lst : #1020303 list) (lst2 : #1020303 list) 
Output : bool
Body : 
 (match lst with 
|[] -> true
|hd::tl -> if (isin ((hd, lst2)) = true) then filter (tl) (lst2)
 else false),

isin -> (51067 : 
Input : (str, (lst : #1020303 list)) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = str) then true
 else isin ((str, tl)))}
Edge : 
{(51067, 51067) -> ,
(51068, 51067) -> ,
(51068, 51068) -> ,
(51069, 51069) -> ,
(51070, 51070) -> ,
(51071, 51068) -> ,
(51071, 51069) -> ,
(51071, 51070) -> }
Starting : 51071
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{__list_mem__ -> (51005 : 
Input : elem (lst : #1019191 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

ch -> (51031 : 
Input : ((e : lambda), (l : string list)) 
Output : bool
Body : 
 (match e with 
|V v -> if __list_mem__ (v) (l) then true
 else false
|P (v, ex) -> ch ((ex, (l @ [v])))
|C (e1, e2) -> (ch ((e1, l)) && ch ((e2, l)))),

check -> (51032 : 
Input : (e : lambda) 
Output : bool
Body : ch ((e, []))}
Edge : 
{(51005, 51005) -> ,
(51031, 51005) -> ,
(51031, 51031) -> ,
(51032, 51031) -> }
Starting : 51032
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
filter -> __list_mem__,
isin -> ch}
------Remainings in submission ------
{bool_check,cal_check}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60560 : ?)

Decls : 
,Exp : Modify (60561 : false)

Decls : 
,Exp : Modify (60575 : ((? = ?) || ? (?) (?)))

Decls : 
,Exp : Modify (60639 : ? ((?, [])))

Decls : 
,Exp : Insert (C (e1, e2) -> (? ((?, ?)) && ? ((?, ?))) At label 60558

Decls : 
,Exp : Insert (P (v, ex) -> ? ((?, (? @ [?]))) At label 60558

Decls : 
,Exp : Insert (V v -> if ? (?) (?) then true
 else false At label 60558

Decls : 
,Exp : Delete ([] -> false At label 60558

Decls : 
,Exp : Delete (hd::tl -> if (hd = str) then true
 else isin ((str, tl)) At label 60558

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60560 : ?)

Decls : 
,Exp : Modify (60561 : false)

Decls : 
,Exp : Modify (60575 : ((? = ?) || ? (?) (?)))

Decls : 
,Exp : Modify (60639 : ? ((?, [])))

Decls : 
,Exp : Insert (C (e1, e2) -> (? ((?, ?)) && ? ((?, ?))) At label 60558

Decls : 
,Exp : Insert (P (v, ex) -> ? ((?, (? @ [?]))) At label 60558

Decls : 
,Exp : Insert (V v -> if ? (?) (?) then true
 else false At label 60558

Decls : 
,Exp : Delete ([] -> false At label 60558

Decls : 
,Exp : Delete (hd::tl -> if (hd = str) then true
 else isin ((str, tl)) At label 60558

Decls : 
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub25.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

exception NotImplemented

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec result  : (lambda -> var) = 
fun lambda -> 
 (match lambda with 
|V var -> var
|P (v, e) -> result (e)
|C (e1, e2) -> result (e2))

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V var -> false
|P (v1, V v2) -> if (v1 = v2) then true
 else false
|P (v1, P (v2, e2)) -> if (check (P ((v2, e2))) || (v1 = result (e2))) then true
 else false
|P (v1, C (e1, e2)) -> if (v1 = result (e2)) then true
 else false
|_ -> raise NotImplemented)

-----------------------------
Submission
-----------------------------

exception NotImplemented

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec result  : (lambda -> var) = (60555, 
fun lambda -> (60554, 
 (match (60546, lambda with 
|V var -> (60547, var
|P (v, e) -> (60550, (60548, result ((60549, e)
|C (e1, e2) -> (60553, (60551, result ((60552, e2))

let rec check  : (lambda -> bool) = (60590, 
fun lambda -> (60589, 
 (match (60556, lambda with 
|V var -> (60557, false
|P (v1, V v2) -> (60563, if (60560, ((60558, v1 = (60559, v2) then (60561, true
 else (60562, false
|P (v1, P (v2, e2)) -> (60578, if (60575, ((60569, (60564, check ((60568, P ((60567, ((60565, v2, (60566, e2))) || (60574, ((60570, v1 = (60573, (60571, result ((60572, e2))) then (60576, true
 else (60577, false
|P (v1, C (e1, e2)) -> (60586, if (60583, ((60579, v1 = (60582, (60580, result ((60581, e2)) then (60584, true
 else (60585, false
|_ -> (60588, raise (60587, NotImplemented))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : -1
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (47100 : 
Input : (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|V var -> false
|P (v1, V v2) -> if (v1 = v2) then true
 else false
|P (v1, P (v2, e2)) -> if (check (P ((v2, e2))) || (v1 = result (e2))) then true
 else false
|P (v1, C (e1, e2)) -> if (v1 = result (e2)) then true
 else false
|_ -> raise NotImplemented),

result -> (47099 : 
Input : (lambda : lambda) 
Output : var
Body : 
 (match lambda with 
|V var -> var
|P (v, e) -> result (e)
|C (e1, e2) -> result (e2))}
Edge : 
{(47099, 47099) -> ,
(47100, 47099) -> ,
(47100, 47100) -> }
Starting : 47100
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (47065 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (47064 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(47064, 47064) -> ,
(47065, 47064) -> }
Starting : 47065
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{result}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60589 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60589 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

exception NotImplemented

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec result  : (lambda -> var) = 
fun lambda -> 
 (match lambda with 
|V var -> var
|P (v, e) -> result (e)
|C (e1, e2) -> result (e2))

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lambda -> checking (lambda) ([])

Time : 0.00151991844177
Error occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub26.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub36.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check  : (lambda -> bool) = 
fun lambda -> 
let rec make_list  : (lambda -> ((var list * var list) -> (var list * var list))) = 
fun lambda' (lst1, lst2) -> 
 (match lambda' with 
|V v -> (lst1, (v :: lst2))
|P (v, e) -> make_list (e) (((v :: lst1), lst2))
|C (e1, e2) -> make_list (e1) (make_list (e2) ((lst1, lst2))))
 in 

let rec exist  : (var list -> (var -> bool)) = 
fun lst v -> 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = v) then true
 else exist (tl) (v))
 in 

let rec real_check  : ((var list * var list) -> bool) = 
fun (lst1, lst2) -> 
 (match lst2 with 
|[] -> true
|hd::tl -> if exist (lst1) (hd) then real_check ((lst1, tl))
 else false)
 in 
real_check (make_list (lambda) (([], [])))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check  : (lambda -> bool) = (60618, 
fun lambda -> (60617, 
let rec make_list  : (lambda -> ((var list * var list) -> (var list * var list))) = (60574, 
fun lambda' (lst1, lst2) -> (60572, 
 (match (60546, lambda' with 
|V v -> (60551, ((60547, lst1, (60550, ((60548, v :: (60549, lst2))
|P (v, e) -> (60560, (60559, (60552, make_list ((60553, e) ((60558, ((60556, ((60554, v :: (60555, lst1), (60557, lst2))
|C (e1, e2) -> (60571, (60570, (60561, make_list ((60562, e1) ((60569, (60568, (60563, make_list ((60564, e2) ((60567, ((60565, lst1, (60566, lst2))))
 in 
(60616, 
let rec exist  : (var list -> (var -> bool)) = (60589, 
fun lst v -> (60587, 
 (match (60575, lst with 
|[] -> (60576, false
|hd::tl -> (60586, if (60579, ((60577, hd = (60578, v) then (60580, true
 else (60585, (60584, (60581, exist ((60582, tl) ((60583, v))
 in 
(60615, 
let rec real_check  : ((var list * var list) -> bool) = (60605, 
fun (lst1, lst2) -> (60604, 
 (match (60590, lst2 with 
|[] -> (60591, true
|hd::tl -> (60603, if (60596, (60595, (60592, exist ((60593, lst1) ((60594, hd) then (60601, (60597, real_check ((60600, ((60598, lst1, (60599, tl))
 else (60602, false)
 in 
(60614, (60606, real_check ((60613, (60612, (60607, make_list ((60608, lambda) ((60611, ((60609, [], (60610, [])))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/17/sub13.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec containCheck (n, ll)  : bool = 
 (match ll with 
|hd::tl -> if (hd = n) then true
 else containCheck ((n, tl))
|[] -> false)

let check lambda  : bool = 
let rec check (lambda, ll)  : bool = 
 (match lambda with 
|V n -> containCheck ((n, ll))
|P (n, met) -> check ((met, (n :: ll)))
|C (met1, met2) -> (check ((met1, ll)) && check ((met2, ll))))
 in 
check ((lambda, []))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (49745 : 
Input : (lambda : lambda) 
Output : bool
Body : real_check (make_list (lambda) (([], []))),

exist -> (49747 : 
Input : (lst : string list) (v : string) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = v) then true
 else exist (tl) (v)),

make_list -> (49746 : 
Input : (lambda' : lambda) ((lst1 : string list), (lst2 : string list)) 
Output : (var list * var list)
Body : 
 (match lambda' with 
|V v -> (lst1, (v :: lst2))
|P (v, e) -> make_list (e) (((v :: lst1), lst2))
|C (e1, e2) -> make_list (e1) (make_list (e2) ((lst1, lst2)))),

real_check -> (49748 : 
Input : ((lst1 : string list), (lst2 : string list)) 
Output : bool
Body : 
 (match lst2 with 
|[] -> true
|hd::tl -> if exist (lst1) (hd) then real_check ((lst1, tl))
 else false)}
Edge : 
{(49745, 49746) -> ,
(49745, 49748) -> ,
(49746, 49746) -> ,
(49747, 49747) -> ,
(49748, 49747) -> ,
(49748, 49748) -> }
Starting : 49745
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (49709 : 
Input : (lambda : lambda) 
Output : bool
Body : check ((lambda, [])),

containCheck -> (49708 : 
Input : (n, (ll : #986539 list)) 
Output : bool
Body : 
 (match ll with 
|hd::tl -> if (hd = n) then true
 else containCheck ((n, tl))
|[] -> false)}
Edge : 
{(49708, 49708) -> ,
(49709, 49710) -> ,
(49710, 49708) -> ,
(49710, 49710) -> }
Starting : 49709
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
real_check -> containCheck}
------Remainings in submission ------
{exist,make_list}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60590 : ?)

Decls : 
,Exp : Modify (60591 : false)

Decls : 
,Exp : Modify (60596 : (? = ?))

Decls : 
,Exp : Modify (60601 : true)

Decls : 
,Exp : Modify (60602 : ? ((?, ?)))

Decls : 
,Exp : Modify (60614 : ? ((?, [])))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60590 : ?)

Decls : 
,Exp : Modify (60591 : false)

Decls : 
,Exp : Modify (60596 : (? = ?))

Decls : 
,Exp : Modify (60601 : true)

Decls : 
,Exp : Modify (60614 : ? ((?, [])))

Decls : 
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub37.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

exception NotImplemented

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V v -> true
|P (v, p) -> true
|_ -> raise NotImplemented)

-----------------------------
Submission
-----------------------------

exception NotImplemented

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = (60552, 
fun lambda -> (60551, 
 (match (60546, lambda with 
|V v -> (60547, true
|P (v, p) -> (60548, true
|_ -> (60550, raise (60549, NotImplemented))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|V v -> true
|P (v, p) -> true
|_ -> raise NotImplemented)}
Edge : 
empty
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60551 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60551 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

exception NotImplemented

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lambda -> checking (lambda) ([])

Time : 0.00139880180359
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub39.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V _ -> false
|P (a, e) -> 
let l  = cklist (e)
 in 

 (match l with 
|[] -> true
|hd::tl -> if mtlist ((a, l)) then if (remlist ((a, l)) = []) then true
 else 
 (match e with 
|V _ -> true
|P (_, _) -> check (e)
|C (V a, V b) -> true
|C (V _, e1) -> check (e1)
|C (e1, V _) -> check (e1)
|C (e1, e2) -> check (e))
 else false)
|C (e1, e2) -> (check (e1) && check (e2)))
and cklist lambda  = 
 (match lambda with 
|V a -> [a]
|P (a, e) -> cklist (e)
|C (e1, e2) -> (cklist (e1) @ cklist (e2)))
and mtlist (a, l)  = 
 (match l with 
|[] -> false
|hd::tl -> if (hd = a) then true
 else mtlist ((a, tl)))
and remlist (a, l)  = 
 (match l with 
|[] -> []
|hd::tl -> if (hd = a) then remlist ((a, tl))
 else ([a] @ remlist ((a, tl))))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = (60595, 
fun lambda -> (60594, 
 (match (60546, lambda with 
|V _ -> (60547, false
|P (a, e) -> (60586, 
let l  = (60550, (60548, cklist ((60549, e)
 in 
(60585, 
 (match (60551, l with 
|[] -> (60552, true
|hd::tl -> (60584, if (60557, (60553, mtlist ((60556, ((60554, a, (60555, l)) then (60582, if (60564, ((60562, (60558, remlist ((60561, ((60559, a, (60560, l)) = (60563, []) then (60565, true
 else (60581, 
 (match (60566, e with 
|V _ -> (60567, true
|P (_, _) -> (60570, (60568, check ((60569, e)
|C (V a, V b) -> (60571, true
|C (V _, e1) -> (60574, (60572, check ((60573, e1)
|C (e1, V _) -> (60577, (60575, check ((60576, e1)
|C (e1, e2) -> (60580, (60578, check ((60579, e))
 else (60583, false)
|C (e1, e2) -> (60593, ((60589, (60587, check ((60588, e1) && (60592, (60590, check ((60591, e2)))
and cklist lambda  = (60609, 
 (match (60596, lambda with 
|V a -> (60598, [(60597, a]
|P (a, e) -> (60601, (60599, cklist ((60600, e)
|C (e1, e2) -> (60608, ((60604, (60602, cklist ((60603, e1) @ (60607, (60605, cklist ((60606, e2)))
and mtlist (a, l)  = (60622, 
 (match (60610, l with 
|[] -> (60611, false
|hd::tl -> (60621, if (60614, ((60612, hd = (60613, a) then (60615, true
 else (60620, (60616, mtlist ((60619, ((60617, a, (60618, tl)))
and remlist (a, l)  = (60642, 
 (match (60623, l with 
|[] -> (60624, []
|hd::tl -> (60641, if (60627, ((60625, hd = (60626, a) then (60632, (60628, remlist ((60631, ((60629, a, (60630, tl))
 else (60640, ((60634, [(60633, a] @ (60639, (60635, remlist ((60638, ((60636, a, (60637, tl))))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/17/sub13.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec containCheck (n, ll)  : bool = 
 (match ll with 
|hd::tl -> if (hd = n) then true
 else containCheck ((n, tl))
|[] -> false)

let check lambda  : bool = 
let rec check (lambda, ll)  : bool = 
 (match lambda with 
|V n -> containCheck ((n, ll))
|P (n, met) -> check ((met, (n :: ll)))
|C (met1, met2) -> (check ((met1, ll)) && check ((met2, ll))))
 in 
check ((lambda, []))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (49745 : 
Input : (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|V _ -> false
|P (a, e) -> 
let l  : string list = cklist (e)
 in 

 (match l with 
|[] -> true
|hd::tl -> if mtlist ((a, l)) then if (remlist ((a, l)) = []) then true
 else 
 (match e with 
|V _ -> true
|P (_, _) -> check (e)
|C (V a, V b) -> true
|C (V _, e1) -> check (e1)
|C (e1, V _) -> check (e1)
|C (e1, e2) -> check (e))
 else false)
|C (e1, e2) -> (check (e1) && check (e2))),

cklist -> (49746 : 
Input : (lambda : lambda) 
Output : string list
Body : 
 (match lambda with 
|V a -> [a]
|P (a, e) -> cklist (e)
|C (e1, e2) -> (cklist (e1) @ cklist (e2))),

mtlist -> (49747 : 
Input : ((a : string), (l : string list)) 
Output : bool
Body : 
 (match l with 
|[] -> false
|hd::tl -> if (hd = a) then true
 else mtlist ((a, tl))),

remlist -> (49748 : 
Input : ((a : string), (l : string list)) 
Output : string list
Body : 
 (match l with 
|[] -> []
|hd::tl -> if (hd = a) then remlist ((a, tl))
 else ([a] @ remlist ((a, tl))))}
Edge : 
{(49745, 49745) -> ,
(49745, 49746) -> ,
(49745, 49747) -> ,
(49745, 49748) -> ,
(49746, 49746) -> ,
(49747, 49747) -> ,
(49748, 49748) -> }
Starting : 49745
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (49709 : 
Input : (lambda : lambda) 
Output : bool
Body : check ((lambda, [])),

containCheck -> (49708 : 
Input : (n, (ll : #1042065 list)) 
Output : bool
Body : 
 (match ll with 
|hd::tl -> if (hd = n) then true
 else containCheck ((n, tl))
|[] -> false)}
Edge : 
{(49708, 49708) -> ,
(49709, 49710) -> ,
(49710, 49708) -> ,
(49710, 49710) -> }
Starting : 49709
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
mtlist -> containCheck}
------Remainings in submission ------
{cklist,remlist}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60594 : ? ((?, [])))

Decls : 
,Exp : Modify (60610 : ?)

Decls : 
,Exp : Modify (60612 : ?)

Decls : 
,Exp : Modify (60613 : ?)

Decls : 
,Exp : Modify (60620 : ? ((?, ?)))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60594 : ? ((?, [])))

Decls : 
,Exp : Modify (60610 : ?)

Decls : 
,Exp : Modify (60612 : ?)

Decls : 
,Exp : Modify (60613 : ?)

Decls : 
,Exp : Modify (60620 : ? ((?, ?)))

Decls : 
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub40.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let listP  = [""]

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V x -> __list_mem__ (x) (listP)
|P (x, e1) -> 
let listP  = (listP @ [x])
 in 
check (e1)
|C (e1, e2) -> (check (e1) && check (e2)))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let listP  = (60547, [(60546, ""]

let rec check  : (lambda -> bool) = (60570, 
fun lambda -> (60569, 
 (match (60548, lambda with 
|V x -> (60553, (60552, (60549, __list_mem__ ((60550, x) ((60551, listP)
|P (x, e1) -> (60561, 
let listP  = (60557, ((60554, listP @ (60556, [(60555, x])
 in 
(60560, (60558, check ((60559, e1)
|C (e1, e2) -> (60568, ((60564, (60562, check ((60563, e1) && (60567, (60565, check ((60566, e2)))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 2
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{__list_mem__ -> (45752 : 
Input : elem (lst : #945987 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (45777 : 
Input : (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|V x -> __list_mem__ (x) (listP)
|P (x, e1) -> 
let listP  : string list = (listP @ [x])
 in 
check (e1)
|C (e1, e2) -> (check (e1) && check (e2)))}
Edge : 
{(45752, 45752) -> ,
(45777, 45752) -> ,
(45777, 45777) -> }
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{__list_mem__ -> checking,
check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60569 : ? (?) ([]))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60569 : ? (?) ([]))

Decls : 
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub47.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V _ -> false
|C (_, _) -> false
|P (v1, V v2) -> if (v1 = v2) then true
 else false
|P (v1, P (v2, e1)) -> if ((v1 = v2) && check (P ((v1, e1)))) then true
 else false
|P (v1, C (e1, e2)) -> (check (P ((v1, e1))) && check (P ((v1, e2)))))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = (60582, 
fun lambda -> (60581, 
 (match (60546, lambda with 
|V _ -> (60547, false
|C (_, _) -> (60548, false
|P (v1, V v2) -> (60554, if (60551, ((60549, v1 = (60550, v2) then (60552, true
 else (60553, false
|P (v1, P (v2, e1)) -> (60567, if (60564, ((60557, ((60555, v1 = (60556, v2) && (60563, (60558, check ((60562, P ((60561, ((60559, v1, (60560, e1)))) then (60565, true
 else (60566, false
|P (v1, C (e1, e2)) -> (60580, ((60573, (60568, check ((60572, P ((60571, ((60569, v1, (60570, e1))) && (60579, (60574, check ((60578, P ((60577, ((60575, v1, (60576, e2)))))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|V _ -> false
|C (_, _) -> false
|P (v1, V v2) -> if (v1 = v2) then true
 else false
|P (v1, P (v2, e1)) -> if ((v1 = v2) && check (P ((v1, e1)))) then true
 else false
|P (v1, C (e1, e2)) -> (check (P ((v1, e1))) && check (P ((v1, e2)))))}
Edge : 
{(45777, 45777) -> }
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60581 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60581 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lambda -> checking (lambda) ([])

Time : 0.00147294998169
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub54.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

exception NotImplemented

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec varOfExp  : (lambda -> var) = 
fun lambda -> 
 (match lambda with 
|V var -> var
|P (var, e) -> varOfExp (e)
|C (e1, e2) -> varOfExp (e2))

let check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|P (var1, P (var2, e)) -> if ((varOfExp (e) = var2) || (varOfExp (e) = var1)) then true
 else false
|P (var1, C (e1, e2)) -> if (varOfExp (e2) = var1) then true
 else false
|P (var1, V var2) -> if (var1 = var2) then true
 else false
|_ -> raise NotImplemented)

-----------------------------
Submission
-----------------------------

exception NotImplemented

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec varOfExp  : (lambda -> var) = (60555, 
fun lambda -> (60554, 
 (match (60546, lambda with 
|V var -> (60547, var
|P (var, e) -> (60550, (60548, varOfExp ((60549, e)
|C (e1, e2) -> (60553, (60551, varOfExp ((60552, e2))

let check  : (lambda -> bool) = (60588, 
fun lambda -> (60587, 
 (match (60556, lambda with 
|P (var1, P (var2, e)) -> (60570, if (60567, ((60561, ((60559, (60557, varOfExp ((60558, e) = (60560, var2) || (60566, ((60564, (60562, varOfExp ((60563, e) = (60565, var1)) then (60568, true
 else (60569, false
|P (var1, C (e1, e2)) -> (60578, if (60575, ((60573, (60571, varOfExp ((60572, e2) = (60574, var1) then (60576, true
 else (60577, false
|P (var1, V var2) -> (60584, if (60581, ((60579, var1 = (60580, var2) then (60582, true
 else (60583, false
|_ -> (60586, raise (60585, NotImplemented))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : -1
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (47100 : 
Input : (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|P (var1, P (var2, e)) -> if ((varOfExp (e) = var2) || (varOfExp (e) = var1)) then true
 else false
|P (var1, C (e1, e2)) -> if (varOfExp (e2) = var1) then true
 else false
|P (var1, V var2) -> if (var1 = var2) then true
 else false
|_ -> raise NotImplemented),

varOfExp -> (47099 : 
Input : (lambda : lambda) 
Output : var
Body : 
 (match lambda with 
|V var -> var
|P (var, e) -> varOfExp (e)
|C (e1, e2) -> varOfExp (e2))}
Edge : 
{(47099, 47099) -> ,
(47100, 47099) -> }
Starting : 47100
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (47065 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (47064 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(47064, 47064) -> ,
(47065, 47064) -> }
Starting : 47065
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{varOfExp}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60587 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60587 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

exception NotImplemented

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec varOfExp  : (lambda -> var) = 
fun lambda -> 
 (match lambda with 
|V var -> var
|P (var, e) -> varOfExp (e)
|C (e1, e2) -> varOfExp (e2))

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let check  : (lambda -> bool) = 
fun lambda -> checking (lambda) ([])

Time : 0.00150489807129
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub57.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec has  : (string -> (lambda -> bool)) = 
fun str lambdaression -> 
 (match lambdaression with 
|V v -> false
|P (v, e) -> if (v = str) then true
 else false
|C (e1, e2) -> (has (str) (e1) || has (str) (e2)))

let rec checkOriginal  : (lambda -> (lambda -> bool)) = 
fun lambda original -> 
 (match lambda with 
|V v -> has (v) (original)
|P (v, e) -> checkOriginal (e) (original)
|C (e1, e2) -> (checkOriginal (e1) (original) && checkOriginal (e2) (original)))

let rec check  : (lambda -> bool) = 
fun lambda -> checkOriginal (lambda) (lambda)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec has  : (string -> (lambda -> bool)) = (60567, 
fun str lambdaression -> (60565, 
 (match (60546, lambdaression with 
|V v -> (60547, false
|P (v, e) -> (60553, if (60550, ((60548, v = (60549, str) then (60551, true
 else (60552, false
|C (e1, e2) -> (60564, ((60558, (60557, (60554, has ((60555, str) ((60556, e1) || (60563, (60562, (60559, has ((60560, str) ((60561, e2)))

let rec checkOriginal  : (lambda -> (lambda -> bool)) = (60592, 
fun lambda original -> (60590, 
 (match (60568, lambda with 
|V v -> (60573, (60572, (60569, has ((60570, v) ((60571, original)
|P (v, e) -> (60578, (60577, (60574, checkOriginal ((60575, e) ((60576, original)
|C (e1, e2) -> (60589, ((60583, (60582, (60579, checkOriginal ((60580, e1) ((60581, original) && (60588, (60587, (60584, checkOriginal ((60585, e2) ((60586, original)))

let rec check  : (lambda -> bool) = (60598, 
fun lambda -> (60597, (60596, (60593, checkOriginal ((60594, lambda) ((60595, lambda)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : -2
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (48423 : 
Input : (lambda : lambda) 
Output : bool
Body : checkOriginal (lambda) (lambda),

checkOriginal -> (48422 : 
Input : (lambda : lambda) (original : lambda) 
Output : bool
Body : 
 (match lambda with 
|V v -> has (v) (original)
|P (v, e) -> checkOriginal (e) (original)
|C (e1, e2) -> (checkOriginal (e1) (original) && checkOriginal (e2) (original))),

has -> (48421 : 
Input : (str : string) (lambdaression : lambda) 
Output : bool
Body : 
 (match lambdaression with 
|V v -> false
|P (v, e) -> if (v = str) then true
 else false
|C (e1, e2) -> (has (str) (e1) || has (str) (e2)))}
Edge : 
{(48421, 48421) -> ,
(48422, 48421) -> ,
(48422, 48422) -> ,
(48423, 48422) -> }
Starting : 48423
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (48387 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (48386 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(48386, 48386) -> ,
(48387, 48386) -> }
Starting : 48387
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{checkOriginal,has}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60597 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60597 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec has  : (string -> (lambda -> bool)) = 
fun str lambdaression -> 
 (match lambdaression with 
|V v -> false
|P (v, e) -> if (v = str) then true
 else false
|C (e1, e2) -> (has (str) (e1) || has (str) (e2)))

let rec checkOriginal  : (lambda -> (lambda -> bool)) = 
fun lambda original -> 
 (match lambda with 
|V v -> has (v) (original)
|P (v, e) -> checkOriginal (e) (original)
|C (e1, e2) -> (checkOriginal (e1) (original) && checkOriginal (e2) (original)))

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lambda -> checking (lambda) ([])

Time : 0.00167798995972
Error occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub60.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub62.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec getBoundValues  : (lambda -> var list) = 
fun lambda -> 
 (match lambda with 
|V v -> []
|P (v, e) -> (v :: getBoundValues (e))
|C (e1, e2) -> (getBoundValues (e1) @ getBoundValues (e2)))

let rec getValues  : (lambda -> var list) = 
fun lambda -> 
 (match lambda with 
|V v -> [v]
|P (v, e) -> getValues (e)
|C (e1, e2) -> (getValues (e1) @ getValues (e2)))

let rec compareHelper  : ((var * var list) -> bool) = 
fun (var, varL) -> 
 (match (var, varL) with 
|(v, hd::tl) -> if (v = hd) then true
 else if (tl = []) then false
 else compareHelper ((v, tl)))

let rec compare  : ((var list * var list) -> bool) = 
fun (values, bound) -> 
 (match (values, bound) with 
|(valueHd::valueTl, bound) -> if (valueTl = []) then compareHelper ((valueHd, bound))
 else if compareHelper ((valueHd, bound)) then compare ((valueTl, bound))
 else false)

let check  : (lambda -> bool) = 
fun lambda -> compare ((getValues (lambda), getBoundValues (lambda)))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec getBoundValues  : (lambda -> var list) = (60561, 
fun lambda -> (60560, 
 (match (60546, lambda with 
|V v -> (60547, []
|P (v, e) -> (60552, ((60548, v :: (60551, (60549, getBoundValues ((60550, e))
|C (e1, e2) -> (60559, ((60555, (60553, getBoundValues ((60554, e1) @ (60558, (60556, getBoundValues ((60557, e2)))

let rec getValues  : (lambda -> var list) = (60576, 
fun lambda -> (60575, 
 (match (60562, lambda with 
|V v -> (60564, [(60563, v]
|P (v, e) -> (60567, (60565, getValues ((60566, e)
|C (e1, e2) -> (60574, ((60570, (60568, getValues ((60569, e1) @ (60573, (60571, getValues ((60572, e2)))

let rec compareHelper  : ((var * var list) -> bool) = (60596, 
fun (var, varL) -> (60595, 
 (match (60579, ((60577, var, (60578, varL) with 
|(v, hd::tl) -> (60594, if (60582, ((60580, v = (60581, hd) then (60583, true
 else (60593, if (60586, ((60584, tl = (60585, []) then (60587, false
 else (60592, (60588, compareHelper ((60591, ((60589, v, (60590, tl)))

let rec compare  : ((var list * var list) -> bool) = (60622, 
fun (values, bound) -> (60621, 
 (match (60599, ((60597, values, (60598, bound) with 
|(valueHd::valueTl, bound) -> (60620, if (60602, ((60600, valueTl = (60601, []) then (60607, (60603, compareHelper ((60606, ((60604, valueHd, (60605, bound))
 else (60619, if (60612, (60608, compareHelper ((60611, ((60609, valueHd, (60610, bound)) then (60617, (60613, compare ((60616, ((60614, valueTl, (60615, bound))
 else (60618, false)

let check  : (lambda -> bool) = (60632, 
fun lambda -> (60631, (60623, compare ((60630, ((60626, (60624, getValues ((60625, lambda), (60629, (60627, getBoundValues ((60628, lambda)))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_16/sub97.ml Score : 1
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec mem  : ((var * var list) -> bool) = 
fun (key, lst) -> 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = key) then true
 else (false || mem ((key, tl))))

let check  : (lambda -> bool) = 
fun lambda -> 
let rec ch  : ((lambda * var list) -> bool) = 
fun (lambda, lst) -> 
 (match lambda with 
|V x -> mem ((x, lst))
|P (x, p) -> ch ((p, (x :: lst)))
|C (p, q) -> (ch ((p, lst)) && ch ((q, lst))))
 in 
ch ((lambda, []))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (51071 : 
Input : (lambda : lambda) 
Output : bool
Body : compare ((getValues (lambda), getBoundValues (lambda))),

compare -> (51070 : 
Input : ((values : #1016406 list), (bound : #1016387 list)) 
Output : bool
Body : 
 (match (values, bound) with 
|(valueHd::valueTl, bound) -> if (valueTl = []) then compareHelper ((valueHd, bound))
 else if compareHelper ((valueHd, bound)) then compare ((valueTl, bound))
 else false),

compareHelper -> (51069 : 
Input : (var, (varL : #1016387 list)) 
Output : bool
Body : 
 (match (var, varL) with 
|(v, hd::tl) -> if (v = hd) then true
 else if (tl = []) then false
 else compareHelper ((v, tl))),

getBoundValues -> (51067 : 
Input : (lambda : lambda) 
Output : var list
Body : 
 (match lambda with 
|V v -> []
|P (v, e) -> (v :: getBoundValues (e))
|C (e1, e2) -> (getBoundValues (e1) @ getBoundValues (e2))),

getValues -> (51068 : 
Input : (lambda : lambda) 
Output : var list
Body : 
 (match lambda with 
|V v -> [v]
|P (v, e) -> getValues (e)
|C (e1, e2) -> (getValues (e1) @ getValues (e2)))}
Edge : 
{(51067, 51067) -> ,
(51068, 51068) -> ,
(51069, 51069) -> ,
(51070, 51069) -> ,
(51070, 51070) -> ,
(51071, 51067) -> ,
(51071, 51068) -> ,
(51071, 51070) -> }
Starting : 51071
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{ch -> (51032 : 
Input : ((lambda : lambda), (lst : string list)) 
Output : bool
Body : 
 (match lambda with 
|V x -> mem ((x, lst))
|P (x, p) -> ch ((p, (x :: lst)))
|C (p, q) -> (ch ((p, lst)) && ch ((q, lst)))),

check -> (51031 : 
Input : (lambda : lambda) 
Output : bool
Body : ch ((lambda, [])),

mem -> (51030 : 
Input : (key, (lst : #1015621 list)) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = key) then true
 else (false || mem ((key, tl))))}
Edge : 
{(51030, 51030) -> ,
(51031, 51032) -> ,
(51032, 51030) -> ,
(51032, 51032) -> }
Starting : 51031
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
compare -> mem,
compareHelper -> ch}
------Remainings in submission ------
{getBoundValues,getValues}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60579 : ?)

Decls : 
,Exp : Modify (60599 : ?)

Decls : 
,Exp : Modify (60631 : ? ((?, [])))

Decls : 
,Exp : Insert (C (p, q) -> (? ((?, ?)) && ? ((?, ?))) At label 60595

Decls : 
,Exp : Insert (P (x, p) -> ? ((?, (? :: ?))) At label 60595

Decls : 
,Exp : Insert (V x -> ? ((?, ?)) At label 60595

Decls : 
,Exp : Insert ([] -> false At label 60621

Decls : 
,Exp : Insert (hd::tl -> if (? = ?) then true
 else (false || ? ((?, ?))) At label 60621

Decls : 
,Exp : Delete ((v, hd::tl) -> if (v = hd) then true
 else if (tl = []) then false
 else compareHelper ((v, tl)) At label 60595

Decls : 
,Exp : Delete ((valueHd::valueTl, bound) -> if (valueTl = []) then compareHelper ((valueHd, bound))
 else if compareHelper ((valueHd, bound)) then compare ((valueTl, bound))
 else false At label 60621

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60579 : ?)

Decls : 
,Exp : Modify (60599 : ?)

Decls : 
,Exp : Modify (60631 : ? ((?, [])))

Decls : 
,Exp : Insert (C (p, q) -> (? ((?, ?)) && ? ((?, ?))) At label 60595

Decls : 
,Exp : Insert (P (x, p) -> ? ((?, (? :: ?))) At label 60595

Decls : 
,Exp : Insert (V x -> ? ((?, ?)) At label 60595

Decls : 
,Exp : Insert ([] -> false At label 60621

Decls : 
,Exp : Insert (hd::tl -> if (? = ?) then true
 else (false || ? ((?, ?))) At label 60621

Decls : 
,Exp : Delete ((v, hd::tl) -> if (v = hd) then true
 else if (tl = []) then false
 else compareHelper ((v, tl)) At label 60595

Decls : 
,Exp : Delete ((valueHd::valueTl, bound) -> if (valueTl = []) then compareHelper ((valueHd, bound))
 else if compareHelper ((valueHd, bound)) then compare ((valueTl, bound))
 else false At label 60621

Decls : 
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub66.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec helpcheck  : (lambda -> lambda list) = 
fun lambda -> 
 (match lambda with 
|P (a, b) -> (V (a) :: helpcheck (b))
|C (a, b) -> (helpcheck (a) @ helpcheck (b))
|V a -> [])

let rec varcheck  : (lambda -> lambda list) = 
fun lambda -> 
 (match lambda with 
|V a -> (V (a) :: [])
|C (a, b) -> (varcheck (a) @ varcheck (b))
|P (a, b) -> varcheck (b))

let rec findvar  : (lambda -> lambda list) = 
fun lambda -> 
 (match lambda with 
|V a -> (V (a) :: [])
|P (a, b) -> (V (a) :: findvar (b))
|C (a, b) -> (findvar (a) @ findvar (b)))

let rec helpcheck2  : ((lambda * lambda) -> lambda list) = 
fun (ex, lambda) -> 
 (match ex with 
|P (a, b) -> if (b = lambda) then (V (a) :: helpcheck2 ((b, lambda)))
 else (V (a) :: helpcheck2 ((b, lambda)))
|C (a, b) -> if (a = lambda) then []
 else if (b = lambda) then helpcheck2 ((a, lambda))
 else (helpcheck2 ((a, lambda)) @ helpcheck2 ((b, lambda)))
|V a -> [])

let rec confi  : ((lambda list * lambda) -> bool) = 
fun (a, b) -> 
 (match a with 
|hd::tl -> if (hd = b) then true
 else confi ((tl, b))
|_ -> false)

let rec last  : ((lambda list * lambda) -> bool) = 
fun (a, b) -> 
 (match a with 
|hd::tl -> (confi ((helpcheck2 ((b, hd)), hd)) && last ((tl, b)))
|[] -> true)

let rec check  : (lambda -> bool) = 
fun lambda -> if last ((varcheck (lambda), lambda)) then true
 else false

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec helpcheck  : (lambda -> lambda list) = (60562, 
fun lambda -> (60561, 
 (match (60546, lambda with 
|P (a, b) -> (60552, ((60548, V ((60547, a) :: (60551, (60549, helpcheck ((60550, b))
|C (a, b) -> (60559, ((60555, (60553, helpcheck ((60554, a) @ (60558, (60556, helpcheck ((60557, b))
|V a -> (60560, [])

let rec varcheck  : (lambda -> lambda list) = (60579, 
fun lambda -> (60578, 
 (match (60563, lambda with 
|V a -> (60567, ((60565, V ((60564, a) :: (60566, [])
|C (a, b) -> (60574, ((60570, (60568, varcheck ((60569, a) @ (60573, (60571, varcheck ((60572, b))
|P (a, b) -> (60577, (60575, varcheck ((60576, b))

let rec findvar  : (lambda -> lambda list) = (60599, 
fun lambda -> (60598, 
 (match (60580, lambda with 
|V a -> (60584, ((60582, V ((60581, a) :: (60583, [])
|P (a, b) -> (60590, ((60586, V ((60585, a) :: (60589, (60587, findvar ((60588, b))
|C (a, b) -> (60597, ((60593, (60591, findvar ((60592, a) @ (60596, (60594, findvar ((60595, b)))

let rec helpcheck2  : ((lambda * lambda) -> lambda list) = (60648, 
fun (ex, lambda) -> (60647, 
 (match (60600, ex with 
|P (a, b) -> (60620, if (60603, ((60601, b = (60602, lambda) then (60611, ((60605, V ((60604, a) :: (60610, (60606, helpcheck2 ((60609, ((60607, b, (60608, lambda)))
 else (60619, ((60613, V ((60612, a) :: (60618, (60614, helpcheck2 ((60617, ((60615, b, (60616, lambda)))
|C (a, b) -> (60645, if (60623, ((60621, a = (60622, lambda) then (60624, []
 else (60644, if (60627, ((60625, b = (60626, lambda) then (60632, (60628, helpcheck2 ((60631, ((60629, a, (60630, lambda))
 else (60643, ((60637, (60633, helpcheck2 ((60636, ((60634, a, (60635, lambda)) @ (60642, (60638, helpcheck2 ((60641, ((60639, b, (60640, lambda)))
|V a -> (60646, [])

let rec confi  : ((lambda list * lambda) -> bool) = (60662, 
fun (a, b) -> (60661, 
 (match (60649, a with 
|hd::tl -> (60659, if (60652, ((60650, hd = (60651, b) then (60653, true
 else (60658, (60654, confi ((60657, ((60655, tl, (60656, b))
|_ -> (60660, false)

let rec last  : ((lambda list * lambda) -> bool) = (60681, 
fun (a, b) -> (60680, 
 (match (60663, a with 
|hd::tl -> (60678, ((60672, (60664, confi ((60671, ((60669, (60665, helpcheck2 ((60668, ((60666, b, (60667, hd)), (60670, hd)) && (60677, (60673, last ((60676, ((60674, tl, (60675, b)))
|[] -> (60679, true)

let rec check  : (lambda -> bool) = (60692, 
fun lambda -> (60691, if (60688, (60682, last ((60687, ((60685, (60683, varcheck ((60684, lambda), (60686, lambda)) then (60689, true
 else (60690, false

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/15/sub38.ml Score : 1
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec isIncluded (lst, elem)  = 
 (match lst with 
|head::tail -> if (head = elem) then true
 else isIncluded ((tail, elem))
|_ -> false)

let rec checkPartial (areaNameLst, mtr)  = 
 (match mtr with 
|V stnName -> isIncluded ((areaNameLst, stnName))
|C (m1, m2) -> if (checkPartial ((areaNameLst, m1)) = false) then false
 else checkPartial ((areaNameLst, m2))
|P (subName, subMtr) -> checkPartial (((subName :: areaNameLst), subMtr)))

let check mtr  = 
 (match mtr with 
|V _ -> false
|C (m1, m2) -> if (checkPartial (([], m1)) = false) then false
 else checkPartial (([], m2))
|P (n, m) -> checkPartial (([], P ((n, m)))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (53717 : 
Input : (lambda : lambda) 
Output : bool
Body : if last ((varcheck (lambda), lambda)) then true
 else false,

confi -> (53715 : 
Input : ((a : #1066717 list), b) 
Output : bool
Body : 
 (match a with 
|hd::tl -> if (hd = b) then true
 else confi ((tl, b))
|_ -> false),

helpcheck2 -> (53714 : 
Input : ((ex : lambda), (lambda : lambda)) 
Output : lambda list
Body : 
 (match ex with 
|P (a, b) -> if (b = lambda) then (V (a) :: helpcheck2 ((b, lambda)))
 else (V (a) :: helpcheck2 ((b, lambda)))
|C (a, b) -> if (a = lambda) then []
 else if (b = lambda) then helpcheck2 ((a, lambda))
 else (helpcheck2 ((a, lambda)) @ helpcheck2 ((b, lambda)))
|V a -> []),

last -> (53716 : 
Input : ((a : lambda list), (b : lambda)) 
Output : bool
Body : 
 (match a with 
|hd::tl -> (confi ((helpcheck2 ((b, hd)), hd)) && last ((tl, b)))
|[] -> true),

varcheck -> (53712 : 
Input : (lambda : lambda) 
Output : lambda list
Body : 
 (match lambda with 
|V a -> (V (a) :: [])
|C (a, b) -> (varcheck (a) @ varcheck (b))
|P (a, b) -> varcheck (b))}
Edge : 
{(53712, 53712) -> ,
(53714, 53714) -> ,
(53715, 53715) -> ,
(53716, 53714) -> ,
(53716, 53715) -> ,
(53716, 53716) -> ,
(53717, 53712) -> ,
(53717, 53716) -> }
Starting : 53717
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (53676 : 
Input : (mtr : lambda) 
Output : bool
Body : 
 (match mtr with 
|V _ -> false
|C (m1, m2) -> if (checkPartial (([], m1)) = false) then false
 else checkPartial (([], m2))
|P (n, m) -> checkPartial (([], P ((n, m))))),

checkPartial -> (53675 : 
Input : ((areaNameLst : string list), (mtr : lambda)) 
Output : bool
Body : 
 (match mtr with 
|V stnName -> isIncluded ((areaNameLst, stnName))
|C (m1, m2) -> if (checkPartial ((areaNameLst, m1)) = false) then false
 else checkPartial ((areaNameLst, m2))
|P (subName, subMtr) -> checkPartial (((subName :: areaNameLst), subMtr))),

isIncluded -> (53674 : 
Input : ((lst : #1065860 list), elem) 
Output : bool
Body : 
 (match lst with 
|head::tail -> if (head = elem) then true
 else isIncluded ((tail, elem))
|_ -> false)}
Edge : 
{(53674, 53674) -> ,
(53675, 53674) -> ,
(53675, 53675) -> ,
(53676, 53675) -> }
Starting : 53676
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
confi -> checkPartial,
last -> isIncluded}
------Remainings in submission ------
{helpcheck2,varcheck}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60649 : ?)

Decls : 
,Exp : Modify (60663 : ?)

Decls : 
,Exp : Modify (60678 : if (? = ?) then true
 else ? ((?, ?)))

Decls : 
,Exp : Modify (60691 : 
 (match ? with 
|V _ -> false
|C (m1, m2) -> if (? (([], ?)) = false) then false
 else ? (([], ?))
|P (n, m) -> ? (([], P ((?, ?))))))

Decls : 
,Exp : Insert (C (m1, m2) -> if (? ((?, ?)) = false) then false
 else ? ((?, ?)) At label 60661

Decls : 
,Exp : Insert (P (subName, subMtr) -> ? (((? :: ?), ?)) At label 60661

Decls : 
,Exp : Insert (V stnName -> ? ((?, ?)) At label 60661

Decls : 
,Exp : Insert (_ -> false At label 60680

Decls : 
,Exp : Delete (_ -> false At label 60661

Decls : 
,Exp : Delete (hd::tl -> if (hd = b) then true
 else confi ((tl, b)) At label 60661

Decls : 
,Exp : Delete ([] -> true At label 60680

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60649 : ?)

Decls : 
,Exp : Modify (60663 : ?)

Decls : 
,Exp : Modify (60678 : if (? = ?) then true
 else ? ((?, ?)))

Decls : 
,Exp : Modify (60691 : 
 (match ? with 
|V _ -> false
|C (m1, m2) -> if (? (([], ?)) = false) then false
 else ? (([], ?))
|P (n, m) -> ? (([], P ((?, ?))))))

Decls : 
,Exp : Insert (C (m1, m2) -> if (? ((?, ?)) = false) then false
 else ? ((?, ?)) At label 60661

Decls : 
,Exp : Insert (P (subName, subMtr) -> ? (((? :: ?), ?)) At label 60661

Decls : 
,Exp : Insert (V stnName -> ? ((?, ?)) At label 60661

Decls : 
,Exp : Insert (_ -> false At label 60680

Decls : 
,Exp : Delete (_ -> false At label 60661

Decls : 
,Exp : Delete (hd::tl -> if (hd = b) then true
 else confi ((tl, b)) At label 60661

Decls : 
,Exp : Delete ([] -> true At label 60680

Decls : 
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub7.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec allvar  : (lambda -> string list) = 
fun lambda -> 
 (match lambda with 
|V v -> [v]
|P (v, ex) -> []
|C (ex1, ex2) -> (allvar (ex1) @ allvar (ex2)))

let rec searchlist  : ((var list * var) -> bool) = 
fun (lst, var) -> 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = var) then true
 else searchlist ((tl, var)))

let rec complist  : ((var list * var list) -> bool) = 
fun (l1, l2) -> 
 (match l2 with 
|[] -> true
|hd::tl -> if searchlist ((l1, hd)) then complist ((l1, tl))
 else false)

let rec checktest  : ((lambda * var list) -> bool) = 
fun (lambda, l) -> 
 (match lambda with 
|V v -> true
|P (v, ex) -> if complist ((([v] @ l), allvar (ex))) then checktest ((ex, ([v] @ l)))
 else false
|C (ex1, ex2) -> (checktest ((ex1, l)) && checktest ((ex2, l))))

let check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V v -> false
|_ -> checktest ((lambda, [])))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec allvar  : (lambda -> string list) = (60558, 
fun lambda -> (60557, 
 (match (60546, lambda with 
|V v -> (60548, [(60547, v]
|P (v, ex) -> (60549, []
|C (ex1, ex2) -> (60556, ((60552, (60550, allvar ((60551, ex1) @ (60555, (60553, allvar ((60554, ex2)))

let rec searchlist  : ((var list * var) -> bool) = (60572, 
fun (lst, var) -> (60571, 
 (match (60559, lst with 
|[] -> (60560, false
|hd::tl -> (60570, if (60563, ((60561, hd = (60562, var) then (60564, true
 else (60569, (60565, searchlist ((60568, ((60566, tl, (60567, var)))

let rec complist  : ((var list * var list) -> bool) = (60588, 
fun (l1, l2) -> (60587, 
 (match (60573, l2 with 
|[] -> (60574, true
|hd::tl -> (60586, if (60579, (60575, searchlist ((60578, ((60576, l1, (60577, hd)) then (60584, (60580, complist ((60583, ((60581, l1, (60582, tl))
 else (60585, false)

let rec checktest  : ((lambda * var list) -> bool) = (60623, 
fun (lambda, l) -> (60622, 
 (match (60589, lambda with 
|V v -> (60590, true
|P (v, ex) -> (60610, if (60600, (60591, complist ((60599, ((60595, ((60593, [(60592, v] @ (60594, l), (60598, (60596, allvar ((60597, ex))) then (60608, (60601, checktest ((60607, ((60602, ex, (60606, ((60604, [(60603, v] @ (60605, l)))
 else (60609, false
|C (ex1, ex2) -> (60621, ((60615, (60611, checktest ((60614, ((60612, ex1, (60613, l)) && (60620, (60616, checktest ((60619, ((60617, ex2, (60618, l))))

let check  : (lambda -> bool) = (60632, 
fun lambda -> (60631, 
 (match (60624, lambda with 
|V v -> (60625, false
|_ -> (60630, (60626, checktest ((60629, ((60627, lambda, (60628, [])))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_16/sub97.ml Score : 1
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec mem  : ((var * var list) -> bool) = 
fun (key, lst) -> 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = key) then true
 else (false || mem ((key, tl))))

let check  : (lambda -> bool) = 
fun lambda -> 
let rec ch  : ((lambda * var list) -> bool) = 
fun (lambda, lst) -> 
 (match lambda with 
|V x -> mem ((x, lst))
|P (x, p) -> ch ((p, (x :: lst)))
|C (p, q) -> (ch ((p, lst)) && ch ((q, lst))))
 in 
ch ((lambda, []))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{allvar -> (51067 : 
Input : (lambda : lambda) 
Output : string list
Body : 
 (match lambda with 
|V v -> [v]
|P (v, ex) -> []
|C (ex1, ex2) -> (allvar (ex1) @ allvar (ex2))),

check -> (51071 : 
Input : (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|V v -> false
|_ -> checktest ((lambda, []))),

checktest -> (51070 : 
Input : ((lambda : lambda), (l : string list)) 
Output : bool
Body : 
 (match lambda with 
|V v -> true
|P (v, ex) -> if complist ((([v] @ l), allvar (ex))) then checktest ((ex, ([v] @ l)))
 else false
|C (ex1, ex2) -> (checktest ((ex1, l)) && checktest ((ex2, l)))),

complist -> (51069 : 
Input : ((l1 : #1013729 list), (l2 : #1013729 list)) 
Output : bool
Body : 
 (match l2 with 
|[] -> true
|hd::tl -> if searchlist ((l1, hd)) then complist ((l1, tl))
 else false),

searchlist -> (51068 : 
Input : ((lst : #1013725 list), var) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = var) then true
 else searchlist ((tl, var)))}
Edge : 
{(51067, 51067) -> ,
(51068, 51068) -> ,
(51069, 51068) -> ,
(51069, 51069) -> ,
(51070, 51067) -> ,
(51070, 51069) -> ,
(51070, 51070) -> ,
(51071, 51070) -> }
Starting : 51071
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{ch -> (51032 : 
Input : ((lambda : lambda), (lst : string list)) 
Output : bool
Body : 
 (match lambda with 
|V x -> mem ((x, lst))
|P (x, p) -> ch ((p, (x :: lst)))
|C (p, q) -> (ch ((p, lst)) && ch ((q, lst)))),

check -> (51031 : 
Input : (lambda : lambda) 
Output : bool
Body : ch ((lambda, [])),

mem -> (51030 : 
Input : (key, (lst : #1012978 list)) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = key) then true
 else (false || mem ((key, tl))))}
Edge : 
{(51030, 51030) -> ,
(51031, 51032) -> ,
(51032, 51030) -> ,
(51032, 51032) -> }
Starting : 51031
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
checktest -> ch,
complist -> mem}
------Remainings in submission ------
{allvar,searchlist}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60573 : ?)

Decls : 
,Exp : Modify (60574 : false)

Decls : 
,Exp : Modify (60579 : (? = ?))

Decls : 
,Exp : Modify (60584 : true)

Decls : 
,Exp : Modify (60585 : (false || ? ((?, ?))))

Decls : 
,Exp : Modify (60589 : ?)

Decls : 
,Exp : Modify (60590 : ? ((?, ?)))

Decls : 
,Exp : Modify (60610 : ? ((?, (? :: ?))))

Decls : 
,Exp : Modify (60615 : ? ((?, ?)))

Decls : 
,Exp : Modify (60620 : ? ((?, ?)))

Decls : 
,Exp : Modify (60631 : ? ((?, [])))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60589 : ?)

Decls : 
,Exp : Modify (60590 : ? ((?, ?)))

Decls : 
,Exp : Modify (60615 : ? ((?, ?)))

Decls : 
,Exp : Modify (60620 : ? ((?, ?)))

Decls : 
,Exp : Modify (60631 : ? ((?, [])))

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec allvar  : (lambda -> string list) = 
fun lambda -> 
 (match lambda with 
|V v -> [v]
|P (v, ex) -> []
|C (ex1, ex2) -> (allvar (ex1) @ allvar (ex2)))

let rec searchlist  : ((var list * var) -> bool) = 
fun (lst, var) -> 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = var) then true
 else searchlist ((tl, var)))

let rec complist  : ((var list * var list) -> bool) = 
fun (l1, l2) -> 
 (match l2 with 
|[] -> true
|hd::tl -> if searchlist ((l1, hd)) then complist ((l1, tl))
 else false)

let rec checktest  : ((lambda * var list) -> bool) = 
fun (lambda, l) -> 
 (match lambda with 
|V v -> searchlist ((l, v))
|P (v, ex) -> if complist ((([v] @ l), allvar (ex))) then checktest ((ex, ([v] @ l)))
 else false
|C (ex1, ex2) -> (checktest ((ex1, l)) && checktest ((ex2, l))))

let check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V v -> false
|_ -> checktest ((lambda, [])))

Time : 0.00300097465515
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub70.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec comparelist  : (a list -> (a list -> a list)) = 
fun procdata vardata -> 
 (match (procdata, vardata) with 
|(_, []) -> []
|(hd1::tl1, hd2::tl2) -> if (hd1 = hd2) then comparelist (procdata) (tl2)
 else (comparelist ([hd1]) (tl2) @ comparelist (tl1) (vardata))
|([], hd2::tl2) -> (hd2 :: tl2))

let rec varlist  : (lambda -> var list) = 
fun lambda -> 
 (match lambda with 
|V v -> [v]
|P (_, a) -> varlist (a)
|C (a, b) -> (varlist (a) @ varlist (b)))

let rec proclist  : (lambda -> var list) = 
fun lambda -> 
 (match lambda with 
|P (v, a) -> (v :: proclist (a))
|C (a, b) -> (proclist (a) @ proclist (b))
|_ -> [])

let check  : (lambda -> bool) = 
fun lambda -> 
let list1  = proclist (lambda)
 in 

let list2  = varlist (lambda)
 in 

let list3  = comparelist (list1) (list2)
 in 
if (list3 = []) then true
 else false

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec comparelist  : (a list -> (a list -> a list)) = (60576, 
fun procdata vardata -> (60574, 
 (match (60548, ((60546, procdata, (60547, vardata) with 
|(_, []) -> (60549, []
|(hd1::tl1, hd2::tl2) -> (60570, if (60552, ((60550, hd1 = (60551, hd2) then (60557, (60556, (60553, comparelist ((60554, procdata) ((60555, tl2)
 else (60569, ((60563, (60562, (60558, comparelist ((60560, [(60559, hd1]) ((60561, tl2) @ (60568, (60567, (60564, comparelist ((60565, tl1) ((60566, vardata))
|([], hd2::tl2) -> (60573, ((60571, hd2 :: (60572, tl2))

let rec varlist  : (lambda -> var list) = (60591, 
fun lambda -> (60590, 
 (match (60577, lambda with 
|V v -> (60579, [(60578, v]
|P (_, a) -> (60582, (60580, varlist ((60581, a)
|C (a, b) -> (60589, ((60585, (60583, varlist ((60584, a) @ (60588, (60586, varlist ((60587, b)))

let rec proclist  : (lambda -> var list) = (60607, 
fun lambda -> (60606, 
 (match (60592, lambda with 
|P (v, a) -> (60597, ((60593, v :: (60596, (60594, proclist ((60595, a))
|C (a, b) -> (60604, ((60600, (60598, proclist ((60599, a) @ (60603, (60601, proclist ((60602, b))
|_ -> (60605, [])

let check  : (lambda -> bool) = (60628, 
fun lambda -> (60627, 
let list1  = (60610, (60608, proclist ((60609, lambda)
 in 
(60626, 
let list2  = (60613, (60611, varlist ((60612, lambda)
 in 
(60625, 
let list3  = (60618, (60617, (60614, comparelist ((60615, list1) ((60616, list2)
 in 
(60624, if (60621, ((60619, list3 = (60620, []) then (60622, true
 else (60623, false

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub21.ml Score : -1
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec find_var  : (var -> (var list -> var list)) = 
fun x lst -> 
 (match lst with 
|[] -> []
|h::t -> if (h = x) then find_var (x) (t)
 else (h :: find_var (x) (t)))

let rec eval  : (lambda -> var list) = 
fun lam -> 
 (match lam with 
|V x -> [x]
|P (x, l) -> find_var (x) (eval (l))
|C (l1, l2) -> (eval (l1) @ eval (l2)))

let check  : (lambda -> bool) = 
fun lam -> if (eval (lam) = []) then true
 else false

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (49748 : 
Input : (lambda : lambda) 
Output : bool
Body : 
let list1  : string list = proclist (lambda)
 in 

let list2  : string list = varlist (lambda)
 in 

let list3  : string list = comparelist (list1) (list2)
 in 
if (list3 = []) then true
 else false,

comparelist -> (49745 : 
Input : (procdata : #1013723 list) (vardata : #1013723 list) 
Output : #1013270 list
Body : 
 (match (procdata, vardata) with 
|(_, []) -> []
|(hd1::tl1, hd2::tl2) -> if (hd1 = hd2) then comparelist (procdata) (tl2)
 else (comparelist ([hd1]) (tl2) @ comparelist (tl1) (vardata))
|([], hd2::tl2) -> (hd2 :: tl2)),

proclist -> (49747 : 
Input : (lambda : lambda) 
Output : var list
Body : 
 (match lambda with 
|P (v, a) -> (v :: proclist (a))
|C (a, b) -> (proclist (a) @ proclist (b))
|_ -> []),

varlist -> (49746 : 
Input : (lambda : lambda) 
Output : var list
Body : 
 (match lambda with 
|V v -> [v]
|P (_, a) -> varlist (a)
|C (a, b) -> (varlist (a) @ varlist (b)))}
Edge : 
{(49745, 49745) -> ,
(49746, 49746) -> ,
(49747, 49747) -> ,
(49748, 49745) -> ,
(49748, 49746) -> ,
(49748, 49747) -> }
Starting : 49748
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (49710 : 
Input : (lam : lambda) 
Output : bool
Body : if (eval (lam) = []) then true
 else false,

eval -> (49709 : 
Input : (lam : lambda) 
Output : var list
Body : 
 (match lam with 
|V x -> [x]
|P (x, l) -> find_var (x) (eval (l))
|C (l1, l2) -> (eval (l1) @ eval (l2))),

find_var -> (49708 : 
Input : (x : string) (lst : string list) 
Output : var list
Body : 
 (match lst with 
|[] -> []
|h::t -> if (h = x) then find_var (x) (t)
 else (h :: find_var (x) (t)))}
Edge : 
{(49708, 49708) -> ,
(49709, 49708) -> ,
(49709, 49709) -> ,
(49710, 49709) -> }
Starting : 49710
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
proclist -> eval}
------Remainings in submission ------
{comparelist,varlist}
------Remainings in solution ------
{find_var}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60592 : ?)

Decls : 
,Exp : Modify (60597 : ? (?) (? (?)))

Decls : 

let rec find_var (x : string) (lst : string list)  : var list = 
 (match lst with 
|[] -> []
|h::t -> if (h = x) then find_var (x) (t)
 else (h :: find_var (x) (t)))

Callers : {proclist}
,Exp : Modify (60600 : ? (?))

Decls : 
,Exp : Modify (60603 : ? (?))

Decls : 
,Exp : Modify (60627 : if (? (?) = []) then true
 else false)

Decls : 

let rec find_var (x : string) (lst : string list)  : var list = 
 (match lst with 
|[] -> []
|h::t -> if (h = x) then find_var (x) (t)
 else (h :: find_var (x) (t)))

Callers : {proclist}
,Exp : Insert (V x -> [?] At label 60606

Decls : 
,Exp : Delete (_ -> [] At label 60606

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60592 : ?)

Decls : 
,Exp : Modify (60597 : ? (?) (? (?)))

Decls : 

let rec find_var (x : string) (lst : string list)  : var list = 
 (match lst with 
|[] -> []
|h::t -> if (h = x) then find_var (x) (t)
 else (h :: find_var (x) (t)))

Callers : {proclist}
,Exp : Modify (60600 : ? (?))

Decls : 
,Exp : Modify (60603 : ? (?))

Decls : 
,Exp : Modify (60627 : if (? (?) = []) then true
 else false)

Decls : 

let rec find_var (x : string) (lst : string list)  : var list = 
 (match lst with 
|[] -> []
|h::t -> if (h = x) then find_var (x) (t)
 else (h :: find_var (x) (t)))

Callers : {proclist}
,Exp : Insert (V x -> [?] At label 60606

Decls : 
,Exp : Delete (_ -> [] At label 60606

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec comparelist  : (a list -> (a list -> a list)) = 
fun procdata vardata -> 
 (match (procdata, vardata) with 
|(_, []) -> []
|(hd1::tl1, hd2::tl2) -> if (hd1 = hd2) then comparelist (procdata) (tl2)
 else (comparelist ([hd1]) (tl2) @ comparelist (tl1) (vardata))
|([], hd2::tl2) -> (hd2 :: tl2))

let rec varlist  : (lambda -> var list) = 
fun lambda -> 
 (match lambda with 
|V v -> [v]
|P (_, a) -> varlist (a)
|C (a, b) -> (varlist (a) @ varlist (b)))

let rec find_var (x : string) (lst : string list)  : var list = 
 (match lst with 
|[] -> []
|h::t -> if (h = x) then find_var (x) (t)
 else (h :: find_var (x) (t)))

let rec proclist  : (lambda -> var list) = 
fun lambda -> 
 (match lambda with 
|P (v, a) -> find_var (v) (proclist (a))
|C (a, b) -> (proclist (a) @ proclist (b))
|V x -> [x]
|_ -> [])

let check  : (lambda -> bool) = 
fun lambda -> if (proclist (lambda) = []) then true
 else false

Time : 0.638231039047
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub77.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|P (a, b) -> true
|V a -> true
|C (a, b) -> true)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = (60551, 
fun lambda -> (60550, 
 (match (60546, lambda with 
|P (a, b) -> (60547, true
|V a -> (60548, true
|C (a, b) -> (60549, true)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|P (a, b) -> true
|V a -> true
|C (a, b) -> true)}
Edge : 
empty
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60550 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60550 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lambda -> checking (lambda) ([])

Time : 0.00142288208008
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub80.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec exist v lst  = 
 (match lst with 
|[] -> false
|hd::tl -> if (v = hd) then true
 else exist (v) (tl))

let rec checker e lst  = 
 (match e with 
|V v -> exist (v) (lst)
|P (v, e) -> checker (e) ((lst @ [v]))
|C (e1, e2) -> if (checker (e1) (lst) = checker (e2) (lst)) then true
 else false)

let rec check  : (lambda -> bool) = 
fun lambda -> checker (lambda) ([])

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec exist v lst  = (60558, 
 (match (60546, lst with 
|[] -> (60547, false
|hd::tl -> (60557, if (60550, ((60548, v = (60549, hd) then (60551, true
 else (60556, (60555, (60552, exist ((60553, v) ((60554, tl))

let rec checker e lst  = (60587, 
 (match (60559, e with 
|V v -> (60564, (60563, (60560, exist ((60561, v) ((60562, lst)
|P (v, e) -> (60572, (60571, (60565, checker ((60566, e) ((60570, ((60567, lst @ (60569, [(60568, v]))
|C (e1, e2) -> (60586, if (60583, ((60577, (60576, (60573, checker ((60574, e1) ((60575, lst) = (60582, (60581, (60578, checker ((60579, e2) ((60580, lst)) then (60584, true
 else (60585, false)

let rec check  : (lambda -> bool) = (60593, 
fun lambda -> (60592, (60591, (60588, checker ((60589, lambda) ((60590, [])

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub6.ml Score : 3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec find_stack  = 
fun v stack -> 
 (match stack with 
|hd::tl -> if (hd = v) then true
 else find_stack (v) (tl)
|[] -> false)

let rec check_inner  = 
fun lam stack -> 
 (match lam with 
|V v -> if find_stack (v) (stack) then true
 else false
|P (v, l) -> check_inner (l) ((v :: stack))
|C (l1, l2) -> (check_inner (l1) (stack) && check_inner (l2) (stack)))

let check  : (lambda -> bool) = 
fun lam -> check_inner (lam) ([])

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (48425 : 
Input : (lambda : lambda) 
Output : bool
Body : checker (lambda) ([]),

checker -> (48424 : 
Input : (e : lambda) (lst : string list) 
Output : bool
Body : 
 (match e with 
|V v -> exist (v) (lst)
|P (v, e) -> checker (e) ((lst @ [v]))
|C (e1, e2) -> if (checker (e1) (lst) = checker (e2) (lst)) then true
 else false),

exist -> (48423 : 
Input : v (lst : #964778 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> if (v = hd) then true
 else exist (v) (tl))}
Edge : 
{(48423, 48423) -> ,
(48424, 48423) -> ,
(48424, 48424) -> ,
(48425, 48424) -> }
Starting : 48425
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (48388 : 
Input : (lam : lambda) 
Output : bool
Body : check_inner (lam) ([]),

check_inner -> (48387 : 
Input : (lam : lambda) (stack : string list) 
Output : bool
Body : 
 (match lam with 
|V v -> if find_stack (v) (stack) then true
 else false
|P (v, l) -> check_inner (l) ((v :: stack))
|C (l1, l2) -> (check_inner (l1) (stack) && check_inner (l2) (stack))),

find_stack -> (48386 : 
Input : v (stack : #964063 list) 
Output : bool
Body : 
 (match stack with 
|hd::tl -> if (hd = v) then true
 else find_stack (v) (tl)
|[] -> false)}
Edge : 
{(48386, 48386) -> ,
(48387, 48386) -> ,
(48387, 48387) -> ,
(48388, 48387) -> }
Starting : 48388
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
checker -> check_inner,
exist -> find_stack}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60548 : ?)

Decls : 
,Exp : Modify (60549 : ?)

Decls : 
,Exp : Modify (60556 : ? (?) (?))

Decls : 
,Exp : Modify (60559 : ?)

Decls : 
,Exp : Modify (60564 : if ? (?) (?) then true
 else false)

Decls : 
,Exp : Modify (60572 : ? (?) ((? :: ?)))

Decls : 
,Exp : Modify (60586 : (? (?) (?) && ? (?) (?)))

Decls : 
,Exp : Modify (60592 : ? (?) ([]))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60559 : ?)

Decls : 
,Exp : Modify (60564 : if ? (?) (?) then true
 else false)

Decls : 
,Exp : Modify (60586 : (? (?) (?) && ? (?) (?)))

Decls : 
,Exp : Modify (60592 : ? (?) ([]))

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec exist v lst  = 
 (match lst with 
|[] -> false
|hd::tl -> if (v = hd) then true
 else exist (v) (tl))

let rec checker e lst  = 
 (match e with 
|V v -> exist (v) (lst)
|P (v, e) -> checker (e) ((lst @ [v]))
|C (e1, e2) -> (checker (e1) (lst) && checker (e2) (lst)))

let rec check  : (lambda -> bool) = 
fun lambda -> checker (lambda) ([])

Time : 0.00657200813293
Error occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub81.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub87.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec str lambda  = 
 (match lambda with 
|V a -> []
|P (a, e1) -> (a :: str (e1))
|C (e1, e2) -> (str (e1) @ str (e2)))

let rec v_str lambda  = 
 (match lambda with 
|V a -> [a]
|P (a, e1) -> v_str (e1)
|C (e1, e2) -> (v_str (e1) @ v_str (e2)))

let rec search var lambda  = 
 (match lambda with 
|[] -> false
|hd::tl -> if (hd = var) then true
 else search (var) (tl))

let rec compare e1 e2  = 
 (match e2 with 
|[] -> true
|hd::tl -> if (search (hd) (e1) && compare (e1) (tl)) then true
 else false)

let check  : (lambda -> bool) = 
fun lambda -> compare (str (lambda)) (v_str (lambda))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec str lambda  = (60560, 
 (match (60546, lambda with 
|V a -> (60547, []
|P (a, e1) -> (60552, ((60548, a :: (60551, (60549, str ((60550, e1))
|C (e1, e2) -> (60559, ((60555, (60553, str ((60554, e1) @ (60558, (60556, str ((60557, e2)))

let rec v_str lambda  = (60574, 
 (match (60561, lambda with 
|V a -> (60563, [(60562, a]
|P (a, e1) -> (60566, (60564, v_str ((60565, e1)
|C (e1, e2) -> (60573, ((60569, (60567, v_str ((60568, e1) @ (60572, (60570, v_str ((60571, e2)))

let rec search var lambda  = (60587, 
 (match (60575, lambda with 
|[] -> (60576, false
|hd::tl -> (60586, if (60579, ((60577, hd = (60578, var) then (60580, true
 else (60585, (60584, (60581, search ((60582, var) ((60583, tl))

let rec compare e1 e2  = (60604, 
 (match (60588, e2 with 
|[] -> (60589, true
|hd::tl -> (60603, if (60600, ((60594, (60593, (60590, search ((60591, hd) ((60592, e1) && (60599, (60598, (60595, compare ((60596, e1) ((60597, tl)) then (60601, true
 else (60602, false)

let check  : (lambda -> bool) = (60614, 
fun lambda -> (60613, (60612, (60605, compare ((60608, (60606, str ((60607, lambda)) ((60611, (60609, v_str ((60610, lambda))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub6.ml Score : 1
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec find_stack  = 
fun v stack -> 
 (match stack with 
|hd::tl -> if (hd = v) then true
 else find_stack (v) (tl)
|[] -> false)

let rec check_inner  = 
fun lam stack -> 
 (match lam with 
|V v -> if find_stack (v) (stack) then true
 else false
|P (v, l) -> check_inner (l) ((v :: stack))
|C (l1, l2) -> (check_inner (l1) (stack) && check_inner (l2) (stack)))

let check  : (lambda -> bool) = 
fun lam -> check_inner (lam) ([])

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (51071 : 
Input : (lambda : lambda) 
Output : bool
Body : compare (str (lambda)) (v_str (lambda)),

compare -> (51070 : 
Input : (e1 : #991261 list) (e2 : #991261 list) 
Output : bool
Body : 
 (match e2 with 
|[] -> true
|hd::tl -> if (search (hd) (e1) && compare (e1) (tl)) then true
 else false),

search -> (51069 : 
Input : var (lambda : #7535 list) 
Output : bool
Body : 
 (match lambda with 
|[] -> false
|hd::tl -> if (hd = var) then true
 else search (var) (tl)),

str -> (51067 : 
Input : (lambda : lambda) 
Output : string list
Body : 
 (match lambda with 
|V a -> []
|P (a, e1) -> (a :: str (e1))
|C (e1, e2) -> (str (e1) @ str (e2))),

v_str -> (51068 : 
Input : (lambda : lambda) 
Output : string list
Body : 
 (match lambda with 
|V a -> [a]
|P (a, e1) -> v_str (e1)
|C (e1, e2) -> (v_str (e1) @ v_str (e2)))}
Edge : 
{(51067, 51067) -> ,
(51068, 51068) -> ,
(51069, 51069) -> ,
(51070, 51069) -> ,
(51070, 51070) -> ,
(51071, 51067) -> ,
(51071, 51068) -> ,
(51071, 51070) -> }
Starting : 51071
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (51032 : 
Input : (lam : lambda) 
Output : bool
Body : check_inner (lam) ([]),

check_inner -> (51031 : 
Input : (lam : lambda) (stack : string list) 
Output : bool
Body : 
 (match lam with 
|V v -> if find_stack (v) (stack) then true
 else false
|P (v, l) -> check_inner (l) ((v :: stack))
|C (l1, l2) -> (check_inner (l1) (stack) && check_inner (l2) (stack))),

find_stack -> (51030 : 
Input : v (stack : #990507 list) 
Output : bool
Body : 
 (match stack with 
|hd::tl -> if (hd = v) then true
 else find_stack (v) (tl)
|[] -> false)}
Edge : 
{(51030, 51030) -> ,
(51031, 51030) -> ,
(51031, 51031) -> ,
(51032, 51031) -> }
Starting : 51032
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
compare -> find_stack,
search -> check_inner}
------Remainings in submission ------
{str,v_str}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60575 : ?)

Decls : 
,Exp : Modify (60588 : ?)

Decls : 
,Exp : Modify (60589 : false)

Decls : 
,Exp : Modify (60600 : (? = ?))

Decls : 
,Exp : Modify (60602 : ? (?) (?))

Decls : 
,Exp : Modify (60613 : ? (?) ([]))

Decls : 
,Exp : Insert (C (l1, l2) -> (? (?) (?) && ? (?) (?)) At label 60587

Decls : 
,Exp : Insert (P (v, l) -> ? (?) ((? :: ?)) At label 60587

Decls : 
,Exp : Insert (V v -> if ? (?) (?) then true
 else false At label 60587

Decls : 
,Exp : Delete ([] -> false At label 60587

Decls : 
,Exp : Delete (hd::tl -> if (hd = var) then true
 else search (var) (tl) At label 60587

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60575 : ?)

Decls : 
,Exp : Modify (60588 : ?)

Decls : 
,Exp : Modify (60589 : false)

Decls : 
,Exp : Modify (60600 : (? = ?))

Decls : 
,Exp : Modify (60613 : ? (?) ([]))

Decls : 
,Exp : Insert (C (l1, l2) -> (? (?) (?) && ? (?) (?)) At label 60587

Decls : 
,Exp : Insert (P (v, l) -> ? (?) ((? :: ?)) At label 60587

Decls : 
,Exp : Insert (V v -> if ? (?) (?) then true
 else false At label 60587

Decls : 
,Exp : Delete ([] -> false At label 60587

Decls : 
,Exp : Delete (hd::tl -> if (hd = var) then true
 else search (var) (tl) At label 60587

Decls : 
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub90.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V vari -> true
|P (vari, lambda) -> 
 (match lambda with 
|V v -> if (vari = v) then true
 else false
|C (e1, e2) -> (((check (P ((vari, e1))) || check (P ((vari, e2)))) && check (e1)) && check (e2))
|P (v, e) -> (check (P ((v, e))) && check (P ((vari, e)))))
|C (lambda1, lambda2) -> (check (lambda1) && check (lambda2)))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = (60598, 
fun lambda -> (60597, 
 (match (60546, lambda with 
|V vari -> (60547, true
|P (vari, lambda) -> (60589, 
 (match (60548, lambda with 
|V v -> (60554, if (60551, ((60549, vari = (60550, v) then (60552, true
 else (60553, false
|C (e1, e2) -> (60575, ((60571, ((60567, ((60560, (60555, check ((60559, P ((60558, ((60556, vari, (60557, e1))) || (60566, (60561, check ((60565, P ((60564, ((60562, vari, (60563, e2)))) && (60570, (60568, check ((60569, e1)) && (60574, (60572, check ((60573, e2))
|P (v, e) -> (60588, ((60581, (60576, check ((60580, P ((60579, ((60577, v, (60578, e))) && (60587, (60582, check ((60586, P ((60585, ((60583, vari, (60584, e)))))
|C (lambda1, lambda2) -> (60596, ((60592, (60590, check ((60591, lambda1) && (60595, (60593, check ((60594, lambda2)))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|V vari -> true
|P (vari, lambda) -> 
 (match lambda with 
|V v -> if (vari = v) then true
 else false
|C (e1, e2) -> (((check (P ((vari, e1))) || check (P ((vari, e2)))) && check (e1)) && check (e2))
|P (v, e) -> (check (P ((v, e))) && check (P ((vari, e)))))
|C (lambda1, lambda2) -> (check (lambda1) && check (lambda2)))}
Edge : 
{(45777, 45777) -> }
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60597 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60597 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lambda -> checking (lambda) ([])

Time : 0.00145101547241
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_16/sub96.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V a -> false
|P (a, b) -> 
 (match lambda with 
|V c -> if (a = c) then true
 else false
|P (c, d) -> (check (P ((c, d))) || check (P ((a, d))))
|C (c, d) -> (check (P ((a, c))) && check (P ((a, d)))))
|C (a, b) -> 
 (match (a, b) with 
|(P (c, d), P (e, f)) -> (check (P ((c, d))) && check (P ((e, f))))
|_ -> false))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = (60601, 
fun lambda -> (60600, 
 (match (60546, lambda with 
|V a -> (60547, false
|P (a, b) -> (60581, 
 (match (60548, lambda with 
|V c -> (60554, if (60551, ((60549, a = (60550, c) then (60552, true
 else (60553, false
|P (c, d) -> (60567, ((60560, (60555, check ((60559, P ((60558, ((60556, c, (60557, d))) || (60566, (60561, check ((60565, P ((60564, ((60562, a, (60563, d))))
|C (c, d) -> (60580, ((60573, (60568, check ((60572, P ((60571, ((60569, a, (60570, c))) && (60579, (60574, check ((60578, P ((60577, ((60575, a, (60576, d)))))
|C (a, b) -> (60599, 
 (match (60584, ((60582, a, (60583, b) with 
|(P (c, d), P (e, f)) -> (60597, ((60590, (60585, check ((60589, P ((60588, ((60586, c, (60587, d))) && (60596, (60591, check ((60595, P ((60594, ((60592, e, (60593, f))))
|_ -> (60598, false))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : (lambda : lambda) 
Output : bool
Body : 
 (match lambda with 
|V a -> false
|P (a, b) -> 
 (match lambda with 
|V c -> if (a = c) then true
 else false
|P (c, d) -> (check (P ((c, d))) || check (P ((a, d))))
|C (c, d) -> (check (P ((a, c))) && check (P ((a, d)))))
|C (a, b) -> 
 (match (a, b) with 
|(P (c, d), P (e, f)) -> (check (P ((c, d))) && check (P ((e, f))))
|_ -> false))}
Edge : 
{(45777, 45777) -> }
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60600 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60600 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lambda -> checking (lambda) ([])

Time : 0.00146198272705
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_17/sub15.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec recheck  = 
fun v lamm -> 
 (match lamm with 
|P (x, l) -> recheck ((v @ [x])) (l)
|C (l1, l2) -> (recheck (v) (l1) && recheck (v) (l2))
|V x -> 
 (match v with 
|[] -> false
|hd::tl -> if (hd = x) then true
 else recheck (tl) (lamm)))

let rec check  : (lambda -> bool) = 
fun lam -> 
 (match lam with 
|P (v, l) -> recheck ([v]) (l)
|_ -> false)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec recheck  = (60581, 
fun v lamm -> (60579, 
 (match (60546, lamm with 
|P (x, l) -> (60554, (60553, (60547, recheck ((60551, ((60548, v @ (60550, [(60549, x])) ((60552, l)
|C (l1, l2) -> (60565, ((60559, (60558, (60555, recheck ((60556, v) ((60557, l1) && (60564, (60563, (60560, recheck ((60561, v) ((60562, l2))
|V x -> (60578, 
 (match (60566, v with 
|[] -> (60567, false
|hd::tl -> (60577, if (60570, ((60568, hd = (60569, x) then (60571, true
 else (60576, (60575, (60572, recheck ((60573, tl) ((60574, lamm)))

let rec check  : (lambda -> bool) = (60591, 
fun lam -> (60590, 
 (match (60582, lam with 
|P (v, l) -> (60588, (60587, (60583, recheck ((60585, [(60584, v]) ((60586, l)
|_ -> (60589, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_17/sub5.ml Score : 2
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string
type variables = var list

let rec findVar  : (var list -> (lambda -> bool)) = 
fun vlist lam -> 
 (match lam with 
|V x -> 
 (match vlist with 
|[] -> false
|hd::tl -> if (hd = x) then true
 else findVar (tl) (lam))
|P (v, l) -> findVar ((v :: vlist)) (l)
|C (l1, l2) -> (findVar (vlist) (l1) && findVar (vlist) (l2)))

let rec check  : (lambda -> bool) = 
fun lam -> findVar ([]) (lam)

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (47100 : 
Input : (lam : lambda) 
Output : bool
Body : 
 (match lam with 
|P (v, l) -> recheck ([v]) (l)
|_ -> false),

recheck -> (47099 : 
Input : (v : string list) (lamm : lambda) 
Output : bool
Body : 
 (match lamm with 
|P (x, l) -> recheck ((v @ [x])) (l)
|C (l1, l2) -> (recheck (v) (l1) && recheck (v) (l2))
|V x -> 
 (match v with 
|[] -> false
|hd::tl -> if (hd = x) then true
 else recheck (tl) (lamm)))}
Edge : 
{(47099, 47099) -> ,
(47100, 47099) -> }
Starting : 47100
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (47065 : 
Input : (lam : lambda) 
Output : bool
Body : findVar ([]) (lam),

findVar -> (47064 : 
Input : (vlist : string list) (lam : lambda) 
Output : bool
Body : 
 (match lam with 
|V x -> 
 (match vlist with 
|[] -> false
|hd::tl -> if (hd = x) then true
 else findVar (tl) (lam))
|P (v, l) -> findVar ((v :: vlist)) (l)
|C (l1, l2) -> (findVar (vlist) (l1) && findVar (vlist) (l2)))}
Edge : 
{(47064, 47064) -> ,
(47065, 47064) -> }
Starting : 47065
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
recheck -> findVar}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60554 : ? ((? :: ?)) (?))

Decls : 
,Exp : Modify (60559 : ? (?) (?))

Decls : 
,Exp : Modify (60564 : ? (?) (?))

Decls : 
,Exp : Modify (60566 : ?)

Decls : 
,Exp : Modify (60568 : ?)

Decls : 
,Exp : Modify (60569 : ?)

Decls : 
,Exp : Modify (60576 : ? (?) (?))

Decls : 
,Exp : Modify (60590 : ? ([]) (?))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60590 : ? ([]) (?))

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec recheck  = 
fun v lamm -> 
 (match lamm with 
|P (x, l) -> recheck ((v @ [x])) (l)
|C (l1, l2) -> (recheck (v) (l1) && recheck (v) (l2))
|V x -> 
 (match v with 
|[] -> false
|hd::tl -> if (hd = x) then true
 else recheck (tl) (lamm)))

let rec check  : (lambda -> bool) = 
fun lam -> recheck ([]) (lam)

Time : 0.00138401985168
Error occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_17/sub18.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_17/sub23.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec mklist  = 
fun l lam -> 
 (match lam with 
|P (var, lda) -> mklist ((var :: l)) (lda)
|V var -> l
|C (lda1, lda2) -> 
let l1  = mklist (l) (lda1)
 in 

let l2  = mklist (l) (lda2)
 in 
(l1 @ l2))

let rec checker  = 
fun l var -> 
 (match l with 
|[] -> false
|hd::tl -> if (var = hd) then true
 else checker (tl) (var))

let rec free_check  = 
fun l lam -> 
 (match lam with 
|V var -> checker (l) (var)
|P (var, lda) -> free_check (l) (lda)
|C (lda1, lda2) -> if (free_check (l) (lda1) = true) then free_check (l) (lda2)
 else false)

let rec check  : (lambda -> bool) = 
fun lam -> 
 (match lam with 
|V var -> false
|P (v, lam) -> 
let bound_list  = mklist ([]) (P ((v, lam)))
 in 
free_check (bound_list) (lam)
|C (lda1, lda2) -> 
let b_list1  = mklist ([]) (lda1)
 in 

let b_list2  = mklist ([]) (lda2)
 in 
(free_check (b_list1) (lda1) && free_check (b_list2) (lda2)))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec mklist  = (60572, 
fun l lam -> (60570, 
 (match (60546, lam with 
|P (var, lda) -> (60553, (60552, (60547, mklist ((60550, ((60548, var :: (60549, l)) ((60551, lda)
|V var -> (60554, l
|C (lda1, lda2) -> (60569, 
let l1  = (60559, (60558, (60555, mklist ((60556, l) ((60557, lda1)
 in 
(60568, 
let l2  = (60564, (60563, (60560, mklist ((60561, l) ((60562, lda2)
 in 
(60567, ((60565, l1 @ (60566, l2))

let rec checker  = (60587, 
fun l var -> (60585, 
 (match (60573, l with 
|[] -> (60574, false
|hd::tl -> (60584, if (60577, ((60575, var = (60576, hd) then (60578, true
 else (60583, (60582, (60579, checker ((60580, tl) ((60581, var))

let rec free_check  = (60615, 
fun l lam -> (60613, 
 (match (60588, lam with 
|V var -> (60593, (60592, (60589, checker ((60590, l) ((60591, var)
|P (var, lda) -> (60598, (60597, (60594, free_check ((60595, l) ((60596, lda)
|C (lda1, lda2) -> (60612, if (60605, ((60603, (60602, (60599, free_check ((60600, l) ((60601, lda1) = (60604, true) then (60610, (60609, (60606, free_check ((60607, l) ((60608, lda2)
 else (60611, false)

let rec check  : (lambda -> bool) = (60656, 
fun lam -> (60655, 
 (match (60616, lam with 
|V var -> (60617, false
|P (v, lam) -> (60631, 
let bound_list  = (60625, (60624, (60618, mklist ((60619, []) ((60623, P ((60622, ((60620, v, (60621, lam)))
 in 
(60630, (60629, (60626, free_check ((60627, bound_list) ((60628, lam)
|C (lda1, lda2) -> (60654, 
let b_list1  = (60636, (60635, (60632, mklist ((60633, []) ((60634, lda1)
 in 
(60653, 
let b_list2  = (60641, (60640, (60637, mklist ((60638, []) ((60639, lda2)
 in 
(60652, ((60646, (60645, (60642, free_check ((60643, b_list1) ((60644, lda1) && (60651, (60650, (60647, free_check ((60648, b_list2) ((60649, lda2)))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub8.ml Score : 2
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string
type t = var list

let empty  = []

let rec find bvar x  = 
 (match bvar with 
|[] -> false
|hd::tl -> if (hd = x) then true
 else find (tl) (x))

let check  : (lambda -> bool) = 
fun lam -> 
let rec my_check bvar lamb  = 
 (match lamb with 
|V var -> find (bvar) (var)
|P (var, lambda1) -> my_check ((var :: bvar)) (lambda1)
|C (lambda1, lambda2) -> (my_check (bvar) (lambda1) && my_check (bvar) (lambda2)))
 in 
my_check ([]) (lam)

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (49748 : 
Input : (lam : lambda) 
Output : bool
Body : 
 (match lam with 
|V var -> false
|P (v, lam) -> 
let bound_list  : string list = mklist ([]) (P ((v, lam)))
 in 
free_check (bound_list) (lam)
|C (lda1, lda2) -> 
let b_list1  : string list = mklist ([]) (lda1)
 in 

let b_list2  : string list = mklist ([]) (lda2)
 in 
(free_check (b_list1) (lda1) && free_check (b_list2) (lda2))),

checker -> (49746 : 
Input : (l : #1017700 list) var 
Output : bool
Body : 
 (match l with 
|[] -> false
|hd::tl -> if (var = hd) then true
 else checker (tl) (var)),

free_check -> (49747 : 
Input : (l : string list) (lam : lambda) 
Output : bool
Body : 
 (match lam with 
|V var -> checker (l) (var)
|P (var, lda) -> free_check (l) (lda)
|C (lda1, lda2) -> if (free_check (l) (lda1) = true) then free_check (l) (lda2)
 else false),

mklist -> (49745 : 
Input : (l : string list) (lam : lambda) 
Output : string list
Body : 
 (match lam with 
|P (var, lda) -> mklist ((var :: l)) (lda)
|V var -> l
|C (lda1, lda2) -> 
let l1  : string list = mklist (l) (lda1)
 in 

let l2  : string list = mklist (l) (lda2)
 in 
(l1 @ l2))}
Edge : 
{(49745, 49745) -> ,
(49746, 49746) -> ,
(49747, 49746) -> ,
(49747, 49747) -> ,
(49748, 49745) -> ,
(49748, 49747) -> }
Starting : 49748
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (49709 : 
Input : (lam : lambda) 
Output : bool
Body : my_check ([]) (lam),

find -> (49708 : 
Input : (bvar : #7513 list) (x : string) 
Output : bool
Body : 
 (match bvar with 
|[] -> false
|hd::tl -> if (hd = x) then true
 else find (tl) (x)),

my_check -> (49710 : 
Input : (bvar : string list) (lamb : lambda) 
Output : bool
Body : 
 (match lamb with 
|V var -> find (bvar) (var)
|P (var, lambda1) -> my_check ((var :: bvar)) (lambda1)
|C (lambda1, lambda2) -> (my_check (bvar) (lambda1) && my_check (bvar) (lambda2)))}
Edge : 
{(49708, 49708) -> ,
(49709, 49710) -> ,
(49710, 49708) -> ,
(49710, 49710) -> }
Starting : 49709
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
checker -> find,
free_check -> my_check}
------Remainings in submission ------
{mklist}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60573 : ?)

Decls : 
,Exp : Modify (60575 : ?)

Decls : 
,Exp : Modify (60576 : ?)

Decls : 
,Exp : Modify (60583 : ? (?) (?))

Decls : 
,Exp : Modify (60588 : ?)

Decls : 
,Exp : Modify (60593 : ? (?) (?))

Decls : 
,Exp : Modify (60598 : ? ((? :: ?)) (?))

Decls : 
,Exp : Modify (60612 : (? (?) (?) && ? (?) (?)))

Decls : 
,Exp : Modify (60655 : ? ([]) (?))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60573 : ?)

Decls : 
,Exp : Modify (60575 : ?)

Decls : 
,Exp : Modify (60576 : ?)

Decls : 
,Exp : Modify (60583 : ? (?) (?))

Decls : 
,Exp : Modify (60588 : ?)

Decls : 
,Exp : Modify (60593 : ? (?) (?))

Decls : 
,Exp : Modify (60598 : ? ((? :: ?)) (?))

Decls : 
,Exp : Modify (60612 : (? (?) (?) && ? (?) (?)))

Decls : 
,Exp : Modify (60655 : ? ([]) (?))

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec mklist  = 
fun l lam -> 
 (match lam with 
|P (var, lda) -> mklist ((var :: l)) (lda)
|V var -> l
|C (lda1, lda2) -> 
let l1  = mklist (l) (lda1)
 in 

let l2  = mklist (l) (lda2)
 in 
(l1 @ l2))

let rec checker  = 
fun l var -> 
 (match l with 
|[] -> false
|hd::tl -> if (var = hd) then true
 else checker (tl) (var))

let rec free_check  = 
fun l lam -> 
 (match lam with 
|V var -> checker (l) (var)
|P (var, lda) -> free_check ((var :: l)) (lda)
|C (lda1, lda2) -> if (free_check (l) (lda1) = true) then free_check (l) (lda2)
 else false)

let rec check  : (lambda -> bool) = 
fun lam -> free_check ([]) (lam)

Time : 0.585536956787
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_17/sub25.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string
type bounded = var list

let update_bounded a stk  = (a :: stk)

let rec find_bounded a stk  = 
 (match stk with 
|[] -> false
|hd::tl -> if (hd = a) then true
 else find_bounded (a) (tl))

let rec boundCheck  : (lambda -> (bounded -> bool)) = 
fun lam bd -> 
 (match lam with 
|V v -> find_bounded (v) (bd)
|P (v, l) -> 
let s  = update_bounded (v) (bd)
 in 
boundCheck (l) (s)
|C (l1, l2) -> if boundCheck (l2) (bd) then boundCheck (l2) (bd)
 else false)

let rec check  : (lambda -> bool) = 
fun lam -> boundCheck (lam) ([])

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string
type bounded = var list

let update_bounded a stk  = (60548, ((60546, a :: (60547, stk)

let rec find_bounded a stk  = (60561, 
 (match (60549, stk with 
|[] -> (60550, false
|hd::tl -> (60560, if (60553, ((60551, hd = (60552, a) then (60554, true
 else (60559, (60558, (60555, find_bounded ((60556, a) ((60557, tl))

let rec boundCheck  : (lambda -> (bounded -> bool)) = (60593, 
fun lam bd -> (60591, 
 (match (60562, lam with 
|V v -> (60567, (60566, (60563, find_bounded ((60564, v) ((60565, bd)
|P (v, l) -> (60578, 
let s  = (60572, (60571, (60568, update_bounded ((60569, v) ((60570, bd)
 in 
(60577, (60576, (60573, boundCheck ((60574, l) ((60575, s)
|C (l1, l2) -> (60590, if (60583, (60582, (60579, boundCheck ((60580, l2) ((60581, bd) then (60588, (60587, (60584, boundCheck ((60585, l2) ((60586, bd)
 else (60589, false)

let rec check  : (lambda -> bool) = (60599, 
fun lam -> (60598, (60597, (60594, boundCheck ((60595, lam) ((60596, [])

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub36.ml Score : 4
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let extend x l  = ([x] @ l)

let rec lookup x l  = 
 (match l with 
|[] -> false
|hd::tl -> if (x = hd) then true
 else lookup (x) (tl))

let rec check_help  = 
fun lam lst -> 
 (match lam with 
|V x -> lookup (x) (lst)
|P (x, la) -> check_help (la) (extend (x) (lst))
|C (la1, la2) -> (check_help (la1) (lst) && check_help (la2) (lst)))

let check  : (lambda -> bool) = 
fun lam -> check_help (lam) ([])

let p1  = P (("a", V ("a")))

let p2  = P (("a", P (("a", V ("a")))))

let p3  = P (("a", P (("b", C ((V ("a"), V ("b")))))))

let p4  = P (("a", C ((V ("a"), P (("b", V ("a")))))))

let p5  = P (("a", V ("b")))

let p6  = P (("a", C ((V ("a"), P (("b", V ("c")))))))

let p7  = P (("a", P (("b", C ((V ("a"), V ("c")))))))

let _  = check (p1)

let _  = check (p2)

let _  = check (p3)

let _  = check (p4)

let _  = check (p5)

let _  = check (p6)

let _  = check (p7)

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{boundCheck -> (49749 : 
Input : (lam : lambda) (bd : string list) 
Output : bool
Body : 
 (match lam with 
|V v -> find_bounded (v) (bd)
|P (v, l) -> 
let s  : string list = update_bounded (v) (bd)
 in 
boundCheck (l) (s)
|C (l1, l2) -> if boundCheck (l2) (bd) then boundCheck (l2) (bd)
 else false),

check -> (49750 : 
Input : (lam : lambda) 
Output : bool
Body : boundCheck (lam) ([]),

find_bounded -> (49748 : 
Input : (a : string) (stk : #7534 list) 
Output : bool
Body : 
 (match stk with 
|[] -> false
|hd::tl -> if (hd = a) then true
 else find_bounded (a) (tl)),

update_bounded -> (49747 : 
Input : (a : string) (stk : #7531 list) 
Output : #7531 list
Body : (a :: stk)}
Edge : 
{(49748, 49748) -> ,
(49749, 49747) -> ,
(49749, 49748) -> ,
(49749, 49749) -> ,
(49750, 49749) -> }
Starting : 49750
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (49711 : 
Input : (lam : lambda) 
Output : bool
Body : check_help (lam) ([]),

check_help -> (49710 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lam with 
|V x -> lookup (x) (lst)
|P (x, la) -> check_help (la) (extend (x) (lst))
|C (la1, la2) -> (check_help (la1) (lst) && check_help (la2) (lst))),

extend -> (49708 : 
Input : (x : string) (l : #7352 list) 
Output : #7352 list
Body : ([x] @ l),

lookup -> (49709 : 
Input : x (l : #964064 list) 
Output : bool
Body : 
 (match l with 
|[] -> false
|hd::tl -> if (x = hd) then true
 else lookup (x) (tl))}
Edge : 
{(49709, 49709) -> ,
(49710, 49708) -> ,
(49710, 49709) -> ,
(49710, 49710) -> ,
(49711, 49710) -> }
Starting : 49711
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{boundCheck -> check_help,
check -> check,
find_bounded -> lookup,
update_bounded -> extend}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60548 : ([?] @ ?))

Decls : 
,Exp : Modify (60549 : ?)

Decls : 
,Exp : Modify (60551 : ?)

Decls : 
,Exp : Modify (60552 : ?)

Decls : 
,Exp : Modify (60559 : ? (?) (?))

Decls : 
,Exp : Modify (60562 : ?)

Decls : 
,Exp : Modify (60567 : ? (?) (?))

Decls : 
,Exp : Modify (60578 : ? (?) (? (?) (?)))

Decls : 
,Exp : Modify (60590 : (? (?) (?) && ? (?) (?)))

Decls : 
,Exp : Modify (60598 : ? (?) ([]))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60548 : ([?] @ ?))

Decls : 
,Exp : Modify (60549 : ?)

Decls : 
,Exp : Modify (60551 : ?)

Decls : 
,Exp : Modify (60552 : ?)

Decls : 
,Exp : Modify (60559 : ? (?) (?))

Decls : 
,Exp : Modify (60562 : ?)

Decls : 
,Exp : Modify (60567 : ? (?) (?))

Decls : 
,Exp : Modify (60578 : ? (?) (? (?) (?)))

Decls : 
,Exp : Modify (60590 : (? (?) (?) && ? (?) (?)))

Decls : 
,Exp : Modify (60598 : ? (?) ([]))

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string
type bounded = var list

let update_bounded a stk  = (a :: stk)

let rec find_bounded a stk  = 
 (match stk with 
|[] -> false
|hd::tl -> if (hd = a) then true
 else find_bounded (a) (tl))

let rec boundCheck  : (lambda -> (bounded -> bool)) = 
fun lam bd -> 
 (match lam with 
|V v -> find_bounded (v) (bd)
|P (v, l) -> 
let s  = update_bounded (v) (bd)
 in 
boundCheck (l) (s)
|C (l1, l2) -> (boundCheck (l2) (bd) && boundCheck (l1) (bd)))

let rec check  : (lambda -> bool) = 
fun lam -> boundCheck (lam) ([])

Time : 0.214501857758
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_17/sub27.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun lam -> true

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = (60547, 
fun lam -> (60546, true

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : lam 
Output : bool
Body : true}
Edge : 
empty
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

Time : 0.00146985054016
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_17/sub3.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

let empty_env'  = []

let extend_env' x e  = (x :: e)

let rec apply_env' e x  = 
 (match e with 
|[] -> false
|y::tl -> if (x = y) then true
 else apply_env' (tl) (x))

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun lam -> 
let rec check' lam env  = 
 (match lam with 
|V x -> apply_env' (env) (lam)
|P (x, f) -> 
let proc  = extend_env' (V (x)) (env)
 in 
check' (f) (proc)
|C (f1, f2) -> if (check' (f1) (env) = check' (f2) (env)) then true
 else false)
 in 
check' (lam) (empty_env')

-----------------------------
Submission
-----------------------------

let empty_env'  = (60546, []

let extend_env' x e  = (60549, ((60547, x :: (60548, e)

let rec apply_env' e x  = (60562, 
 (match (60550, e with 
|[] -> (60551, false
|y::tl -> (60561, if (60554, ((60552, x = (60553, y) then (60555, true
 else (60560, (60559, (60556, apply_env' ((60557, tl) ((60558, x))

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = (60602, 
fun lam -> (60601, 
let rec check' lam env  = (60595, 
 (match (60563, lam with 
|V x -> (60568, (60567, (60564, apply_env' ((60565, env) ((60566, lam)
|P (x, f) -> (60580, 
let proc  = (60574, (60573, (60569, extend_env' ((60571, V ((60570, x)) ((60572, env)
 in 
(60579, (60578, (60575, check' ((60576, f) ((60577, proc)
|C (f1, f2) -> (60594, if (60591, ((60585, (60584, (60581, check' ((60582, f1) ((60583, env) = (60590, (60589, (60586, check' ((60587, f2) ((60588, env)) then (60592, true
 else (60593, false)
 in 
(60600, (60599, (60596, check' ((60597, lam) ((60598, empty_env')

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_17/sub8.ml Score : 4
-----------------------------

let empty_lam  = []

let extend_lam x e  = (x :: e)

let rec apply_lam e x  = 
 (match e with 
|[] -> false
|y::tl -> if (x = y) then true
 else apply_lam (tl) (x))

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun lam -> 
let rec lamb lam env  = 
 (match lam with 
|V va -> apply_lam (env) (lam)
|P (va, la1) -> 
let env'  = extend_lam (V (va)) (env)
 in 
lamb (la1) (env')
|C (la1, la2) -> if (lamb (la1) (env) && lamb (la2) (env)) then true
 else false)
 in 
lamb (lam) (empty_lam)

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{apply_env' -> (49748 : 
Input : (e : #966111 list) x 
Output : bool
Body : 
 (match e with 
|[] -> false
|y::tl -> if (x = y) then true
 else apply_env' (tl) (x)),

check -> (49749 : 
Input : (lam : lambda) 
Output : bool
Body : check' (lam) (empty_env'),

check' -> (49750 : 
Input : (lam : lambda) (env : lambda list) 
Output : bool
Body : 
 (match lam with 
|V x -> apply_env' (env) (lam)
|P (x, f) -> 
let proc  : lambda list = extend_env' (V (x)) (env)
 in 
check' (f) (proc)
|C (f1, f2) -> if (check' (f1) (env) = check' (f2) (env)) then true
 else false),

extend_env' -> (49747 : 
Input : (x : lambda) (e : #7532 list) 
Output : #7532 list
Body : (x :: e)}
Edge : 
{(49748, 49748) -> ,
(49749, 49750) -> ,
(49750, 49747) -> ,
(49750, 49748) -> ,
(49750, 49750) -> }
Starting : 49749
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{apply_lam -> (49709 : 
Input : (e : #965388 list) x 
Output : bool
Body : 
 (match e with 
|[] -> false
|y::tl -> if (x = y) then true
 else apply_lam (tl) (x)),

check -> (49710 : 
Input : (lam : lambda) 
Output : bool
Body : lamb (lam) (empty_lam),

extend_lam -> (49708 : 
Input : (x : lambda) (e : #7002 list) 
Output : #7002 list
Body : (x :: e),

lamb -> (49711 : 
Input : (lam : lambda) (env : lambda list) 
Output : bool
Body : 
 (match lam with 
|V va -> apply_lam (env) (lam)
|P (va, la1) -> 
let env'  : lambda list = extend_lam (V (va)) (env)
 in 
lamb (la1) (env')
|C (la1, la2) -> if (lamb (la1) (env) && lamb (la2) (env)) then true
 else false)}
Edge : 
{(49709, 49709) -> ,
(49710, 49711) -> ,
(49711, 49708) -> ,
(49711, 49709) -> ,
(49711, 49711) -> }
Starting : 49710
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{apply_env' -> apply_lam,
check -> check,
check' -> lamb,
extend_env' -> extend_lam}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60547 : ?)

Decls : 
,Exp : Modify (60548 : ?)

Decls : 
,Exp : Modify (60550 : ?)

Decls : 
,Exp : Modify (60552 : ?)

Decls : 
,Exp : Modify (60553 : ?)

Decls : 
,Exp : Modify (60560 : ? (?) (?))

Decls : 
,Exp : Modify (60563 : ?)

Decls : 
,Exp : Modify (60568 : ? (?) (?))

Decls : 
,Exp : Modify (60580 : 
let env'  : lambda list = ? (V (?)) (?)
 in 
? (?) (?))

Decls : 
,Exp : Modify (60591 : (? (?) (?) && ? (?) (?)))

Decls : 
,Exp : Modify (60600 : ? (?) (?))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60550 : ?)

Decls : 
,Exp : Modify (60563 : ?)

Decls : 
,Exp : Modify (60568 : ? (?) (?))

Decls : 
,Exp : Modify (60591 : (? (?) (?) && ? (?) (?)))

Decls : 
,Exp : Modify (60600 : ? (?) (?))

Decls : 
}
-----------------------------
Patch
-----------------------------

let empty_env'  = []

let extend_env' x e  = (x :: e)

let rec apply_env' e x  = 
 (match e with 
|[] -> false
|y::tl -> if (x = y) then true
 else apply_env' (tl) (x))

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun lam -> 
let rec check' lam env  = 
 (match lam with 
|V x -> apply_env' (env) (lam)
|P (x, f) -> 
let proc  = extend_env' (V (x)) (env)
 in 
check' (f) (proc)
|C (f1, f2) -> if (check' (f1) (env) && check' (f2) (env)) then true
 else false)
 in 
check' (lam) (empty_env')

Time : 0.419507026672
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_17/sub4.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun lam -> true

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = (60547, 
fun lam -> (60546, true

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : lam 
Output : bool
Body : true}
Edge : 
empty
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

Time : 0.00142288208008
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_17/sub42.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun lam -> true

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = (60547, 
fun lam -> (60546, true

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : lam 
Output : bool
Body : true}
Edge : 
empty
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

Time : 0.00143885612488
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_17/sub45.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec test lam  = 
 (match lam with 
|V x -> [("v", x)]
|P (x, l) -> 
let lst  = test (l)
 in 
([("p", x)] @ lst)
|C (l1, l2) -> 
let lst1  = test (l1)
 in 

let lst2  = test (l2)
 in 
(lst1 @ lst2))

let rec find num lst  = 
 (match lst with 
|[] -> []
|hd::tl -> if (hd = num) then find (num) (tl)
 else ([hd] @ find (num) (tl)))

let rec remove lst  = 
 (match lst with 
|[] -> []
|hd::tl -> 
 (match hd with 
|(p, x) -> if (p = "p") then 
let lst1  = find (("v", x)) (tl)
 in 
remove (lst1)
 else if (p = "v") then (hd :: remove (tl))
 else raise Failure ("a")))

let rec order lst  = 
 (match lst with 
|[] -> []
|hd::tl -> 
 (match hd with 
|(p, x) -> if (p = "p") then order (tl)
 else (hd :: order (tl))))

let rec check  : (lambda -> bool) = 
fun lam -> 
let lst1  = test (lam)
 in 

let lst2  = remove (lst1)
 in 

let lst3  = order (lst2)
 in 

 (match lst3 with 
|[] -> true
|_ -> false)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec test lam  = (60572, 
 (match (60546, lam with 
|V x -> (60550, [(60549, ((60547, "v", (60548, x)]
|P (x, l) -> (60560, 
let lst  = (60553, (60551, test ((60552, l)
 in 
(60559, ((60557, [(60556, ((60554, "p", (60555, x)] @ (60558, lst)
|C (l1, l2) -> (60571, 
let lst1  = (60563, (60561, test ((60562, l1)
 in 
(60570, 
let lst2  = (60566, (60564, test ((60565, l2)
 in 
(60569, ((60567, lst1 @ (60568, lst2))

let rec find num lst  = (60592, 
 (match (60573, lst with 
|[] -> (60574, []
|hd::tl -> (60591, if (60577, ((60575, hd = (60576, num) then (60582, (60581, (60578, find ((60579, num) ((60580, tl)
 else (60590, ((60584, [(60583, hd] @ (60589, (60588, (60585, find ((60586, num) ((60587, tl)))

let rec remove lst  = (60624, 
 (match (60593, lst with 
|[] -> (60594, []
|hd::tl -> (60623, 
 (match (60595, hd with 
|(p, x) -> (60622, if (60598, ((60596, p = (60597, "p") then (60609, 
let lst1  = (60605, (60604, (60599, find ((60602, ((60600, "v", (60601, x)) ((60603, tl)
 in 
(60608, (60606, remove ((60607, lst1)
 else (60621, if (60612, ((60610, p = (60611, "v") then (60617, ((60613, hd :: (60616, (60614, remove ((60615, tl))
 else (60620, raise (60619, Failure ((60618, "a"))))

let rec order lst  = (60641, 
 (match (60625, lst with 
|[] -> (60626, []
|hd::tl -> (60640, 
 (match (60627, hd with 
|(p, x) -> (60639, if (60630, ((60628, p = (60629, "p") then (60633, (60631, order ((60632, tl)
 else (60638, ((60634, hd :: (60637, (60635, order ((60636, tl))))

let rec check  : (lambda -> bool) = (60658, 
fun lam -> (60657, 
let lst1  = (60644, (60642, test ((60643, lam)
 in 
(60656, 
let lst2  = (60647, (60645, remove ((60646, lst1)
 in 
(60655, 
let lst3  = (60650, (60648, order ((60649, lst2)
 in 
(60654, 
 (match (60651, lst3 with 
|[] -> (60652, true
|_ -> (60653, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/09/sub13.ml Score : 0
-----------------------------
type var = string
type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)

let check e  = 
let rec check_aux f  = 
 (match f with 
|(V a, l) -> if (l = []) then false
 else if (a = __list_hd__ (l)) then true
 else check_aux ((V (a), __list_tl__ (l)))
|(P (a, b), l) -> check_aux ((b, (a :: l)))
|(C (a, b), l) -> (check_aux ((a, l)) && check_aux ((b, l))))
 in 
check_aux ((e, []))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (51069 : 
Input : (lam : lambda) 
Output : bool
Body : 
let lst1  : (string * string) list = test (lam)
 in 

let lst2  : (string * string) list = remove (lst1)
 in 

let lst3  : (string * string) list = order (lst2)
 in 

 (match lst3 with 
|[] -> true
|_ -> false),

find -> (51066 : 
Input : (num : (string * #1021697)) (lst : #7536 list) 
Output : #7536 list
Body : 
 (match lst with 
|[] -> []
|hd::tl -> if (hd = num) then find (num) (tl)
 else ([hd] @ find (num) (tl))),

order -> (51068 : 
Input : (lst : (string * #1021717) list) 
Output : (string * #1021717) list
Body : 
 (match lst with 
|[] -> []
|hd::tl -> 
 (match hd with 
|(p, x) -> if (p = "p") then order (tl)
 else (hd :: order (tl)))),

remove -> (51067 : 
Input : (lst : (string * #1021697) list) 
Output : (string * #1021697) list
Body : 
 (match lst with 
|[] -> []
|hd::tl -> 
 (match hd with 
|(p, x) -> if (p = "p") then 
let lst1  : (string * #1021697) list = find (("v", x)) (tl)
 in 
remove (lst1)
 else if (p = "v") then (hd :: remove (tl))
 else raise Failure ("a"))),

test -> (51065 : 
Input : (lam : lambda) 
Output : (string * string) list
Body : 
 (match lam with 
|V x -> [("v", x)]
|P (x, l) -> 
let lst  : (string * string) list = test (l)
 in 
([("p", x)] @ lst)
|C (l1, l2) -> 
let lst1  : (string * string) list = test (l1)
 in 

let lst2  : (string * string) list = test (l2)
 in 
(lst1 @ lst2))}
Edge : 
{(51065, 51065) -> ,
(51066, 51066) -> ,
(51067, 51066) -> ,
(51067, 51067) -> ,
(51068, 51068) -> ,
(51069, 51065) -> ,
(51069, 51067) -> ,
(51069, 51068) -> }
Starting : 51069
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{__list_hd__ -> (51002 : 
Input : (lst : #1020495 list) 
Output : #1020488
Body : 
 (match lst with 
|[] -> raise ListError
|hd::tl -> hd),

__list_tl__ -> (51003 : 
Input : (lst : #1020501 list) 
Output : #1020488 list
Body : 
 (match lst with 
|[] -> raise ListError
|hd::tl -> tl),

check -> (51030 : 
Input : (e : lambda) 
Output : bool
Body : check_aux ((e, [])),

check_aux -> (51031 : 
Input : (f : (lambda * string list)) 
Output : bool
Body : 
 (match f with 
|(V a, l) -> if (l = []) then false
 else if (a = __list_hd__ (l)) then true
 else check_aux ((V (a), __list_tl__ (l)))
|(P (a, b), l) -> check_aux ((b, (a :: l)))
|(C (a, b), l) -> (check_aux ((a, l)) && check_aux ((b, l))))}
Edge : 
{(51030, 51031) -> ,
(51031, 51002) -> ,
(51031, 51003) -> ,
(51031, 51031) -> }
Starting : 51030
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
order -> __list_hd__,
remove -> __list_tl__}
------Remainings in submission ------
{find,test}
------Remainings in solution ------
{check_aux}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60593 : ?)

Decls : 
,Exp : Modify (60623 : ?)

Decls : 
,Exp : Modify (60625 : ?)

Decls : 
,Exp : Modify (60640 : ?)

Decls : 
,Exp : Modify (60657 : ? ((?, [])))

Decls : 

let rec check_aux (f : (lambda * string list))  : bool = 
 (match f with 
|(V a, l) -> if (l = []) then false
 else if (a = __list_hd__ (l)) then true
 else check_aux ((V (a), __list_tl__ (l)))
|(P (a, b), l) -> check_aux ((b, (a :: l)))
|(C (a, b), l) -> (check_aux ((a, l)) && check_aux ((b, l))))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60593 : ?)

Decls : 
,Exp : Modify (60623 : ?)

Decls : 
,Exp : Modify (60625 : ?)

Decls : 
,Exp : Modify (60657 : ? ((?, [])))

Decls : 

let rec check_aux (f : (lambda * string list))  : bool = 
 (match f with 
|(V a, l) -> if (l = []) then false
 else if (a = __list_hd__ (l)) then true
 else check_aux ((V (a), __list_tl__ (l)))
|(P (a, b), l) -> check_aux ((b, (a :: l)))
|(C (a, b), l) -> (check_aux ((a, l)) && check_aux ((b, l))))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec test lam  = 
 (match lam with 
|V x -> [("v", x)]
|P (x, l) -> 
let lst  = test (l)
 in 
([("p", x)] @ lst)
|C (l1, l2) -> 
let lst1  = test (l1)
 in 

let lst2  = test (l2)
 in 
(lst1 @ lst2))

let rec find num lst  = 
 (match lst with 
|[] -> []
|hd::tl -> if (hd = num) then find (num) (tl)
 else ([hd] @ find (num) (tl)))

let rec remove lst  = 
 (match lst with 
|[] -> []
|hd::tl -> 
 (match hd with 
|(p, x) -> if (p = "p") then 
let lst1  = find (("v", x)) (tl)
 in 
remove (lst1)
 else if (p = "v") then (hd :: remove (tl))
 else raise Failure ("a")))

let rec order lst  = 
 (match lst with 
|[] -> []
|hd::tl -> 
 (match hd with 
|(p, x) -> if (p = "p") then order (tl)
 else (hd :: order (tl))))

let rec check_aux (f : (lambda * string list))  : bool = 
 (match f with 
|(V a, l) -> if (l = []) then false
 else if (a = __list_hd__ (l)) then true
 else check_aux ((V (a), __list_tl__ (l)))
|(P (a, b), l) -> check_aux ((b, (a :: l)))
|(C (a, b), l) -> (check_aux ((a, l)) && check_aux ((b, l))))

let rec check  : (lambda -> bool) = 
fun lam -> check_aux ((lam, []))

Time : 0.00480699539185
Error occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_17/sub57.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_17/sub58.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec listcheck  : (var -> (var list -> bool)) = 
fun var varl -> 
 (match varl with 
|[] -> false
|hd::tl -> if (var = hd) then true
 else listcheck (var) (tl))

let rec lamfind  : (lambda -> (var list -> bool)) = 
fun lam varl -> 
 (match lam with 
|V v -> listcheck (v) (varl)
|P (v, lm) -> 
let vl  = (varl @ (v :: []))
 in 

let film  = lamfind (lm) (vl)
 in 
film
|C (lm1, lm2) -> 
let film1  = lamfind (lm1) (varl)
 in 

let film2  = lamfind (lm2) (varl)
 in 
(film1 && film2))

let check  : (lambda -> bool) = 
fun lam -> 
 (match lam with 
|V v -> false
|P (v, lm) -> 
let chlm  = lamfind (lm) ((v :: []))
 in 
chlm
|C (lm1, lm2) -> false)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec listcheck  : (var -> (var list -> bool)) = (60560, 
fun var varl -> (60558, 
 (match (60546, varl with 
|[] -> (60547, false
|hd::tl -> (60557, if (60550, ((60548, var = (60549, hd) then (60551, true
 else (60556, (60555, (60552, listcheck ((60553, var) ((60554, tl))

let rec lamfind  : (lambda -> (var list -> bool)) = (60597, 
fun lam varl -> (60595, 
 (match (60561, lam with 
|V v -> (60566, (60565, (60562, listcheck ((60563, v) ((60564, varl)
|P (v, lm) -> (60579, 
let vl  = (60571, ((60567, varl @ (60570, ((60568, v :: (60569, []))
 in 
(60578, 
let film  = (60576, (60575, (60572, lamfind ((60573, lm) ((60574, vl)
 in 
(60577, film
|C (lm1, lm2) -> (60594, 
let film1  = (60584, (60583, (60580, lamfind ((60581, lm1) ((60582, varl)
 in 
(60593, 
let film2  = (60589, (60588, (60585, lamfind ((60586, lm2) ((60587, varl)
 in 
(60592, ((60590, film1 && (60591, film2))

let check  : (lambda -> bool) = (60611, 
fun lam -> (60610, 
 (match (60598, lam with 
|V v -> (60599, false
|P (v, lm) -> (60608, 
let chlm  = (60606, (60605, (60600, lamfind ((60601, lm) ((60604, ((60602, v :: (60603, []))
 in 
(60607, chlm
|C (lm1, lm2) -> (60609, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub6.ml Score : 3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec find_stack  = 
fun v stack -> 
 (match stack with 
|hd::tl -> if (hd = v) then true
 else find_stack (v) (tl)
|[] -> false)

let rec check_inner  = 
fun lam stack -> 
 (match lam with 
|V v -> if find_stack (v) (stack) then true
 else false
|P (v, l) -> check_inner (l) ((v :: stack))
|C (l1, l2) -> (check_inner (l1) (stack) && check_inner (l2) (stack)))

let check  : (lambda -> bool) = 
fun lam -> check_inner (lam) ([])

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (48425 : 
Input : (lam : lambda) 
Output : bool
Body : 
 (match lam with 
|V v -> false
|P (v, lm) -> 
let chlm  : bool = lamfind (lm) ((v :: []))
 in 
chlm
|C (lm1, lm2) -> false),

lamfind -> (48424 : 
Input : (lam : lambda) (varl : string list) 
Output : bool
Body : 
 (match lam with 
|V v -> listcheck (v) (varl)
|P (v, lm) -> 
let vl  : string list = (varl @ (v :: []))
 in 

let film  : bool = lamfind (lm) (vl)
 in 
film
|C (lm1, lm2) -> 
let film1  : bool = lamfind (lm1) (varl)
 in 

let film2  : bool = lamfind (lm2) (varl)
 in 
(film1 && film2)),

listcheck -> (48423 : 
Input : var (varl : #979323 list) 
Output : bool
Body : 
 (match varl with 
|[] -> false
|hd::tl -> if (var = hd) then true
 else listcheck (var) (tl))}
Edge : 
{(48423, 48423) -> ,
(48424, 48423) -> ,
(48424, 48424) -> ,
(48425, 48424) -> }
Starting : 48425
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (48388 : 
Input : (lam : lambda) 
Output : bool
Body : check_inner (lam) ([]),

check_inner -> (48387 : 
Input : (lam : lambda) (stack : string list) 
Output : bool
Body : 
 (match lam with 
|V v -> if find_stack (v) (stack) then true
 else false
|P (v, l) -> check_inner (l) ((v :: stack))
|C (l1, l2) -> (check_inner (l1) (stack) && check_inner (l2) (stack))),

find_stack -> (48386 : 
Input : v (stack : #978608 list) 
Output : bool
Body : 
 (match stack with 
|hd::tl -> if (hd = v) then true
 else find_stack (v) (tl)
|[] -> false)}
Edge : 
{(48386, 48386) -> ,
(48387, 48386) -> ,
(48387, 48387) -> ,
(48388, 48387) -> }
Starting : 48388
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
lamfind -> check_inner,
listcheck -> find_stack}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60548 : ?)

Decls : 
,Exp : Modify (60549 : ?)

Decls : 
,Exp : Modify (60556 : ? (?) (?))

Decls : 
,Exp : Modify (60561 : ?)

Decls : 
,Exp : Modify (60566 : if ? (?) (?) then true
 else false)

Decls : 
,Exp : Modify (60579 : ? (?) ((? :: ?)))

Decls : 
,Exp : Modify (60594 : (? (?) (?) && ? (?) (?)))

Decls : 
,Exp : Modify (60610 : ? (?) ([]))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60610 : ? (?) ([]))

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec listcheck  : (var -> (var list -> bool)) = 
fun var varl -> 
 (match varl with 
|[] -> false
|hd::tl -> if (var = hd) then true
 else listcheck (var) (tl))

let rec lamfind  : (lambda -> (var list -> bool)) = 
fun lam varl -> 
 (match lam with 
|V v -> listcheck (v) (varl)
|P (v, lm) -> 
let vl  = (varl @ (v :: []))
 in 

let film  = lamfind (lm) (vl)
 in 
film
|C (lm1, lm2) -> 
let film1  = lamfind (lm1) (varl)
 in 

let film2  = lamfind (lm2) (varl)
 in 
(film1 && film2))

let check  : (lambda -> bool) = 
fun lam -> lamfind (lam) ([])

Time : 0.00152611732483
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_17/sub59.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec is_there  = 
fun x arr -> 
 (match arr with 
|[] -> false
|hd::tl -> if (x = hd) then true
 else is_there (x) (tl))

let rec find  = 
fun lam arr -> 
 (match lam with 
|V x -> (is_there (x) (arr), arr)
|P (x, l) -> 
let arr1  = (x :: arr)
 in 

 (match l with 
|V x1 -> find (V (x1)) (arr1)
|P (x1, l1) -> find (P ((x1, l1))) (arr1)
|C (l1, l2) -> 
 (match l1 with 
|V x2 -> 
let (t1, a1)  = find (V (x2)) (arr1)
 in 

let (t2, a2)  = find (l2) (a1)
 in 
((t1 && t2), a2)
|_ -> find (l) (arr1)))
|C (l1, l2) -> 
let (t1, a1)  = find (l1) (arr)
 in 

let (t2, a2)  = find (l2) (a1)
 in 
((t1 && t2), a2))

let rec check  : (lambda -> bool) = 
fun lam -> 
 (match find (lam) ([]) with 
|(true, _) -> true
|(false, _) -> false)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec is_there  = (60560, 
fun x arr -> (60558, 
 (match (60546, arr with 
|[] -> (60547, false
|hd::tl -> (60557, if (60550, ((60548, x = (60549, hd) then (60551, true
 else (60556, (60555, (60552, is_there ((60553, x) ((60554, tl))

let rec find  = (60633, 
fun lam arr -> (60631, 
 (match (60561, lam with 
|V x -> (60568, ((60566, (60565, (60562, is_there ((60563, x) ((60564, arr), (60567, arr)
|P (x, l) -> (60613, 
let arr1  = (60571, ((60569, x :: (60570, arr)
 in 
(60612, 
 (match (60572, l with 
|V x1 -> (60578, (60577, (60573, find ((60575, V ((60574, x1)) ((60576, arr1)
|P (x1, l1) -> (60586, (60585, (60579, find ((60583, P ((60582, ((60580, x1, (60581, l1))) ((60584, arr1)
|C (l1, l2) -> (60611, 
 (match (60587, l1 with 
|V x2 -> (60605, 
let (t1, a1)  = (60593, (60592, (60588, find ((60590, V ((60589, x2)) ((60591, arr1)
 in 
(60604, 
let (t2, a2)  = (60598, (60597, (60594, find ((60595, l2) ((60596, a1)
 in 
(60603, ((60601, ((60599, t1 && (60600, t2), (60602, a2)
|_ -> (60610, (60609, (60606, find ((60607, l) ((60608, arr1)))
|C (l1, l2) -> (60630, 
let (t1, a1)  = (60618, (60617, (60614, find ((60615, l1) ((60616, arr)
 in 
(60629, 
let (t2, a2)  = (60623, (60622, (60619, find ((60620, l2) ((60621, a1)
 in 
(60628, ((60626, ((60624, t1 && (60625, t2), (60627, a2))

let rec check  : (lambda -> bool) = (60642, 
fun lam -> (60641, 
 (match (60638, (60637, (60634, find ((60635, lam) ((60636, []) with 
|(true, _) -> (60639, true
|(false, _) -> (60640, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 1
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (48423 : 
Input : (lam : lambda) 
Output : bool
Body : 
 (match find (lam) ([]) with 
|(true, _) -> true
|(false, _) -> false),

find -> (48422 : 
Input : (lam : lambda) (arr : string list) 
Output : (bool * string list)
Body : 
 (match lam with 
|V x -> (is_there (x) (arr), arr)
|P (x, l) -> 
let arr1  : string list = (x :: arr)
 in 

 (match l with 
|V x1 -> find (V (x1)) (arr1)
|P (x1, l1) -> find (P ((x1, l1))) (arr1)
|C (l1, l2) -> 
 (match l1 with 
|V x2 -> 
let (t1, a1)  : (bool * string list) = find (V (x2)) (arr1)
 in 

let (t2, a2)  : (bool * string list) = find (l2) (a1)
 in 
((t1 && t2), a2)
|_ -> find (l) (arr1)))
|C (l1, l2) -> 
let (t1, a1)  : (bool * string list) = find (l1) (arr)
 in 

let (t2, a2)  : (bool * string list) = find (l2) (a1)
 in 
((t1 && t2), a2)),

is_there -> (48421 : 
Input : x (arr : #1020423 list) 
Output : bool
Body : 
 (match arr with 
|[] -> false
|hd::tl -> if (x = hd) then true
 else is_there (x) (tl))}
Edge : 
{(48421, 48421) -> ,
(48422, 48421) -> ,
(48422, 48422) -> ,
(48423, 48422) -> }
Starting : 48423
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (48387 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (48386 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(48386, 48386) -> ,
(48387, 48386) -> }
Starting : 48387
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
is_there -> checking}
------Remainings in submission ------
{find}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60547 : 
 (match ? with 
|V x -> false
|P (x, l) -> ? (?) ((? :: ?))
|C (l1, l2) -> if ((? (?) (?) = true) && (? (?) (?) = true)) then true
 else false))

Decls : 
,Exp : Modify (60557 : 
 (match ? with 
|V x -> if (? = ?) then true
 else ? (?) (?)
|P (x, l) -> ? (?) ((? :: ?))
|C (l1, l2) -> if ((? (?) (?) = true) && (? (?) (?) = true)) then true
 else false))

Decls : 
,Exp : Modify (60641 : ? (?) ([]))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60557 : 
 (match ? with 
|V x -> if (? = ?) then true
 else ? (?) (?)
|P (x, l) -> ? (?) ((? :: ?))
|C (l1, l2) -> if ((? (?) (?) = true) && (? (?) (?) = true)) then true
 else false))

Decls : 
,Exp : Modify (60641 : ? (?) ([]))

Decls : 
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_17/sub62.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec doesExist  : ((var * a list) -> bool) = 
fun (var, env) -> 
 (match env with 
|[] -> false
|hd::tl -> if (var = hd) then true
 else doesExist ((var, tl)))

let rec isBound  : ((lambda * a list) -> bool) = 
fun (lam, env) -> 
 (match lam with 
|V v -> if doesExist ((v, env)) then true
 else false
|P (v, l) -> isBound ((l, (env @ [v])))
|C (l1, l2) -> (isBound ((l1, env)) && isBound ((l2, env))))

let rec check  : (lambda -> bool) = 
fun lam -> 
 (match lam with 
|V v -> false
|P (v, l) -> isBound ((l, [v]))
|C (l1, l2) -> false)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec doesExist  : ((var * a list) -> bool) = (60559, 
fun (var, env) -> (60558, 
 (match (60546, env with 
|[] -> (60547, false
|hd::tl -> (60557, if (60550, ((60548, var = (60549, hd) then (60551, true
 else (60556, (60552, doesExist ((60555, ((60553, var, (60554, tl)))

let rec isBound  : ((lambda * a list) -> bool) = (60589, 
fun (lam, env) -> (60588, 
 (match (60560, lam with 
|V v -> (60568, if (60565, (60561, doesExist ((60564, ((60562, v, (60563, env)) then (60566, true
 else (60567, false
|P (v, l) -> (60576, (60569, isBound ((60575, ((60570, l, (60574, ((60571, env @ (60573, [(60572, v])))
|C (l1, l2) -> (60587, ((60581, (60577, isBound ((60580, ((60578, l1, (60579, env)) && (60586, (60582, isBound ((60585, ((60583, l2, (60584, env))))

let rec check  : (lambda -> bool) = (60600, 
fun lam -> (60599, 
 (match (60590, lam with 
|V v -> (60591, false
|P (v, l) -> (60597, (60592, isBound ((60596, ((60593, l, (60595, [(60594, v]))
|C (l1, l2) -> (60598, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_16/sub97.ml Score : 3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec mem  : ((var * var list) -> bool) = 
fun (key, lst) -> 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = key) then true
 else (false || mem ((key, tl))))

let check  : (lambda -> bool) = 
fun lambda -> 
let rec ch  : ((lambda * var list) -> bool) = 
fun (lambda, lst) -> 
 (match lambda with 
|V x -> mem ((x, lst))
|P (x, p) -> ch ((p, (x :: lst)))
|C (p, q) -> (ch ((p, lst)) && ch ((q, lst))))
 in 
ch ((lambda, []))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (48425 : 
Input : (lam : lambda) 
Output : bool
Body : 
 (match lam with 
|V v -> false
|P (v, l) -> isBound ((l, [v]))
|C (l1, l2) -> false),

doesExist -> (48423 : 
Input : (var, (env : #984622 list)) 
Output : bool
Body : 
 (match env with 
|[] -> false
|hd::tl -> if (var = hd) then true
 else doesExist ((var, tl))),

isBound -> (48424 : 
Input : ((lam : lambda), (env : string list)) 
Output : bool
Body : 
 (match lam with 
|V v -> if doesExist ((v, env)) then true
 else false
|P (v, l) -> isBound ((l, (env @ [v])))
|C (l1, l2) -> (isBound ((l1, env)) && isBound ((l2, env))))}
Edge : 
{(48423, 48423) -> ,
(48424, 48423) -> ,
(48424, 48424) -> ,
(48425, 48424) -> }
Starting : 48425
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{ch -> (48388 : 
Input : ((lambda : lambda), (lst : string list)) 
Output : bool
Body : 
 (match lambda with 
|V x -> mem ((x, lst))
|P (x, p) -> ch ((p, (x :: lst)))
|C (p, q) -> (ch ((p, lst)) && ch ((q, lst)))),

check -> (48387 : 
Input : (lambda : lambda) 
Output : bool
Body : ch ((lambda, [])),

mem -> (48386 : 
Input : (key, (lst : #983891 list)) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = key) then true
 else (false || mem ((key, tl))))}
Edge : 
{(48386, 48386) -> ,
(48387, 48388) -> ,
(48388, 48386) -> ,
(48388, 48388) -> }
Starting : 48387
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
doesExist -> ch,
isBound -> mem}
------Remainings in submission ------
{}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60560 : ?)

Decls : 
,Exp : Modify (60599 : ? ((?, [])))

Decls : 
,Exp : Insert (C (p, q) -> (? ((?, ?)) && ? ((?, ?))) At label 60558

Decls : 
,Exp : Insert (P (x, p) -> ? ((?, (? :: ?))) At label 60558

Decls : 
,Exp : Insert (V x -> ? ((?, ?)) At label 60558

Decls : 
,Exp : Insert ([] -> false At label 60588

Decls : 
,Exp : Insert (hd::tl -> if (? = ?) then true
 else (false || ? ((?, ?))) At label 60588

Decls : 
,Exp : Delete ([] -> false At label 60558

Decls : 
,Exp : Delete (hd::tl -> if (var = hd) then true
 else doesExist ((var, tl)) At label 60558

Decls : 
,Exp : Delete (C (l1, l2) -> (isBound ((l1, env)) && isBound ((l2, env))) At label 60588

Decls : 
,Exp : Delete (P (v, l) -> isBound ((l, (env @ [v]))) At label 60588

Decls : 
,Exp : Delete (V v -> if doesExist ((v, env)) then true
 else false At label 60588

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60599 : ? ((?, [])))

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec doesExist  : ((var * a list) -> bool) = 
fun (var, env) -> 
 (match env with 
|[] -> false
|hd::tl -> if (var = hd) then true
 else doesExist ((var, tl)))

let rec isBound  : ((lambda * a list) -> bool) = 
fun (lam, env) -> 
 (match lam with 
|V v -> if doesExist ((v, env)) then true
 else false
|P (v, l) -> isBound ((l, (env @ [v])))
|C (l1, l2) -> (isBound ((l1, env)) && isBound ((l2, env))))

let rec check  : (lambda -> bool) = 
fun lam -> isBound ((lam, []))

Time : 0.00144600868225
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_17/sub63.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun lam -> 
let rec find x env  = 
 (match env with 
|[] -> false
|hd::tl -> if (hd = x) then true
 else find (x) (tl))
 in 

let rec del x env  = 
 (match env with 
|[] -> []
|v::tl -> if (v = x) then tl
 else (v :: del (x) (tl)))
 in 

let rec free l env  = 
 (match l with 
|V v -> if find (v) (env) then env
 else (v :: env)
|P (v, l1) -> del (v) (free (l1) (env))
|C (l1, l2) -> 
let env1  = free (l1) (env)
 in 
free (l2) (env1))
 in 

let env0  = []
 in 
if (free (lam) (env0) = []) then true
 else false

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = (60621, 
fun lam -> (60620, 
let rec find x env  = (60558, 
 (match (60546, env with 
|[] -> (60547, false
|hd::tl -> (60557, if (60550, ((60548, hd = (60549, x) then (60551, true
 else (60556, (60555, (60552, find ((60553, x) ((60554, tl))
 in 
(60619, 
let rec del x env  = (60573, 
 (match (60559, env with 
|[] -> (60560, []
|v::tl -> (60572, if (60563, ((60561, v = (60562, x) then (60564, tl
 else (60571, ((60565, v :: (60570, (60569, (60566, del ((60567, x) ((60568, tl)))
 in 
(60618, 
let rec free l env  = (60605, 
 (match (60574, l with 
|V v -> (60584, if (60579, (60578, (60575, find ((60576, v) ((60577, env) then (60580, env
 else (60583, ((60581, v :: (60582, env)
|P (v, l1) -> (60593, (60592, (60585, del ((60586, v) ((60591, (60590, (60587, free ((60588, l1) ((60589, env))
|C (l1, l2) -> (60604, 
let env1  = (60598, (60597, (60594, free ((60595, l1) ((60596, env)
 in 
(60603, (60602, (60599, free ((60600, l2) ((60601, env1))
 in 
(60617, 
let env0  = (60606, []
 in 
(60616, if (60613, ((60611, (60610, (60607, free ((60608, lam) ((60609, env0) = (60612, []) then (60614, true
 else (60615, false

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_17/sub20.ml Score : 2
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun lam -> 
let rec rm v lst  = 
 (match lst with 
|hd::tl -> if (hd = v) then rm (v) (tl)
 else (hd :: rm (v) (tl))
|[] -> [])
 in 

let rec mklst lam lst  = 
 (match lam with 
|V v -> (v :: lst)
|P (v, l) -> rm (v) (mklst (l) (lst))
|C (l1, l2) -> (mklst (l1) (lst) @ mklst (l2) (lst)))
 in 
if (mklst (lam) ([]) = []) then true
 else false

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (49745 : 
Input : (lam : lambda) 
Output : bool
Body : 
let env0  : string list = []
 in 
if (free (lam) (env0) = []) then true
 else false,

del -> (49747 : 
Input : (x : string) (env : string list) 
Output : string list
Body : 
 (match env with 
|[] -> []
|v::tl -> if (v = x) then tl
 else (v :: del (x) (tl))),

find -> (49746 : 
Input : (x : string) (env : string list) 
Output : bool
Body : 
 (match env with 
|[] -> false
|hd::tl -> if (hd = x) then true
 else find (x) (tl)),

free -> (49748 : 
Input : (l : lambda) (env : string list) 
Output : string list
Body : 
 (match l with 
|V v -> if find (v) (env) then env
 else (v :: env)
|P (v, l1) -> del (v) (free (l1) (env))
|C (l1, l2) -> 
let env1  : string list = free (l1) (env)
 in 
free (l2) (env1))}
Edge : 
{(49745, 49748) -> ,
(49746, 49746) -> ,
(49747, 49747) -> ,
(49748, 49746) -> ,
(49748, 49747) -> ,
(49748, 49748) -> }
Starting : 49745
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (49708 : 
Input : (lam : lambda) 
Output : bool
Body : if (mklst (lam) ([]) = []) then true
 else false,

mklst -> (49710 : 
Input : (lam : lambda) (lst : string list) 
Output : string list
Body : 
 (match lam with 
|V v -> (v :: lst)
|P (v, l) -> rm (v) (mklst (l) (lst))
|C (l1, l2) -> (mklst (l1) (lst) @ mklst (l2) (lst))),

rm -> (49709 : 
Input : (v : string) (lst : string list) 
Output : string list
Body : 
 (match lst with 
|hd::tl -> if (hd = v) then rm (v) (tl)
 else (hd :: rm (v) (tl))
|[] -> [])}
Edge : 
{(49708, 49710) -> ,
(49709, 49709) -> ,
(49710, 49709) -> ,
(49710, 49710) -> }
Starting : 49708
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
del -> rm,
free -> mklst}
------Remainings in submission ------
{find}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60559 : ?)

Decls : 
,Exp : Modify (60561 : ?)

Decls : 
,Exp : Modify (60562 : ?)

Decls : 
,Exp : Modify (60564 : ? (?) (?))

Decls : 
,Exp : Modify (60565 : ?)

Decls : 
,Exp : Modify (60570 : ? (?) (?))

Decls : 
,Exp : Modify (60574 : ?)

Decls : 
,Exp : Modify (60584 : (? :: ?))

Decls : 
,Exp : Modify (60593 : ? (?) (? (?) (?)))

Decls : 
,Exp : Modify (60604 : (? (?) (?) @ ? (?) (?)))

Decls : 
,Exp : Modify (60617 : if (? (?) ([]) = []) then true
 else false)

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60559 : ?)

Decls : 
,Exp : Modify (60561 : ?)

Decls : 
,Exp : Modify (60562 : ?)

Decls : 
,Exp : Modify (60564 : ? (?) (?))

Decls : 
,Exp : Modify (60574 : ?)

Decls : 
,Exp : Modify (60584 : (? :: ?))

Decls : 
,Exp : Modify (60593 : ? (?) (? (?) (?)))

Decls : 
,Exp : Modify (60604 : (? (?) (?) @ ? (?) (?)))

Decls : 
,Exp : Modify (60617 : if (? (?) ([]) = []) then true
 else false)

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun lam -> 
let rec find x env  = 
 (match env with 
|[] -> false
|hd::tl -> if (hd = x) then true
 else find (x) (tl))
 in 

let rec del x env  = 
 (match env with 
|[] -> []
|v::tl -> if (v = x) then del (x) (tl)
 else (v :: del (x) (tl)))
 in 

let rec free l env  = 
 (match l with 
|V v -> if find (v) (env) then env
 else (v :: env)
|P (v, l1) -> del (v) (free (l1) (env))
|C (l1, l2) -> (free (l1) (env) @ free (l2) (env)))
 in 

let env0  = []
 in 
if (free (lam) (env0) = []) then true
 else false

Time : 218.903346062
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_17/sub68.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec erase  : (var -> (var list -> var list)) = 
fun v lst -> 
 (match lst with 
|[] -> []
|hd::tl -> if (v = hd) then erase (v) (tl)
 else (hd :: erase (v) (tl)))

let rec check_help  : (lambda -> var list) = 
fun lam -> 
let lst  = []
 in 

 (match lam with 
|V v -> (v :: lst)
|P (v, l) -> erase (v) (check_help (l))
|C (l1, l2) -> (check_help (l1) @ check_help (l2)))

let rec check  : (lambda -> bool) = 
fun lam -> 
 (match lam with 
|V v -> false
|P (v, l) -> if (__list_length__ (erase (v) (check_help (l))) = 0) then true
 else false
|C (l1, l2) -> false)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec erase  : (var -> (var list -> var list)) = (60566, 
fun v lst -> (60564, 
 (match (60546, lst with 
|[] -> (60547, []
|hd::tl -> (60563, if (60550, ((60548, v = (60549, hd) then (60555, (60554, (60551, erase ((60552, v) ((60553, tl)
 else (60562, ((60556, hd :: (60561, (60560, (60557, erase ((60558, v) ((60559, tl)))

let rec check_help  : (lambda -> var list) = (60588, 
fun lam -> (60587, 
let lst  = (60567, []
 in 
(60586, 
 (match (60568, lam with 
|V v -> (60571, ((60569, v :: (60570, lst)
|P (v, l) -> (60578, (60577, (60572, erase ((60573, v) ((60576, (60574, check_help ((60575, l))
|C (l1, l2) -> (60585, ((60581, (60579, check_help ((60580, l1) @ (60584, (60582, check_help ((60583, l2)))

let rec check  : (lambda -> bool) = (60607, 
fun lam -> (60606, 
 (match (60589, lam with 
|V v -> (60590, false
|P (v, l) -> (60604, if (60601, ((60599, (60591, __list_length__ ((60598, (60597, (60592, erase ((60593, v) ((60596, (60594, check_help ((60595, l))) = (60600, 0) then (60602, true
 else (60603, false
|C (l1, l2) -> (60605, false)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub21.ml Score : 2
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec find_var  : (var -> (var list -> var list)) = 
fun x lst -> 
 (match lst with 
|[] -> []
|h::t -> if (h = x) then find_var (x) (t)
 else (h :: find_var (x) (t)))

let rec eval  : (lambda -> var list) = 
fun lam -> 
 (match lam with 
|V x -> [x]
|P (x, l) -> find_var (x) (eval (l))
|C (l1, l2) -> (eval (l1) @ eval (l2)))

let check  : (lambda -> bool) = 
fun lam -> if (eval (lam) = []) then true
 else false

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{__list_length__ -> (48402 : 
Input : (lst : #981607 list) 
Output : int
Body : 
 (match lst with 
|[] -> 0
|_::tl -> (1 + __list_length__ (tl))),

check -> (48425 : 
Input : (lam : lambda) 
Output : bool
Body : 
 (match lam with 
|V v -> false
|P (v, l) -> if (__list_length__ (erase (v) (check_help (l))) = 0) then true
 else false
|C (l1, l2) -> false),

check_help -> (48424 : 
Input : (lam : lambda) 
Output : var list
Body : 
let lst  : string list = []
 in 

 (match lam with 
|V v -> (v :: lst)
|P (v, l) -> erase (v) (check_help (l))
|C (l1, l2) -> (check_help (l1) @ check_help (l2))),

erase -> (48423 : 
Input : (v : string) (lst : string list) 
Output : var list
Body : 
 (match lst with 
|[] -> []
|hd::tl -> if (v = hd) then erase (v) (tl)
 else (hd :: erase (v) (tl)))}
Edge : 
{(48402, 48402) -> ,
(48423, 48423) -> ,
(48424, 48423) -> ,
(48424, 48424) -> ,
(48425, 48402) -> ,
(48425, 48423) -> ,
(48425, 48424) -> }
Starting : 48425
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (48388 : 
Input : (lam : lambda) 
Output : bool
Body : if (eval (lam) = []) then true
 else false,

eval -> (48387 : 
Input : (lam : lambda) 
Output : var list
Body : 
 (match lam with 
|V x -> [x]
|P (x, l) -> find_var (x) (eval (l))
|C (l1, l2) -> (eval (l1) @ eval (l2))),

find_var -> (48386 : 
Input : (x : string) (lst : string list) 
Output : var list
Body : 
 (match lst with 
|[] -> []
|h::t -> if (h = x) then find_var (x) (t)
 else (h :: find_var (x) (t)))}
Edge : 
{(48386, 48386) -> ,
(48387, 48386) -> ,
(48387, 48387) -> ,
(48388, 48387) -> }
Starting : 48388
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
check_help -> eval,
erase -> find_var}
------Remainings in submission ------
{__list_length__}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60546 : ?)

Decls : 
,Exp : Modify (60548 : ?)

Decls : 
,Exp : Modify (60549 : ?)

Decls : 
,Exp : Modify (60555 : ? (?) (?))

Decls : 
,Exp : Modify (60556 : ?)

Decls : 
,Exp : Modify (60561 : ? (?) (?))

Decls : 
,Exp : Modify (60587 : 
 (match ? with 
|V x -> [?]
|P (x, l) -> ? (?) (? (?))
|C (l1, l2) -> (? (?) @ ? (?))))

Decls : 
,Exp : Modify (60606 : if (? (?) = []) then true
 else false)

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60606 : if (? (?) = []) then true
 else false)

Decls : 
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec erase  : (var -> (var list -> var list)) = 
fun v lst -> 
 (match lst with 
|[] -> []
|hd::tl -> if (v = hd) then erase (v) (tl)
 else (hd :: erase (v) (tl)))

let rec check_help  : (lambda -> var list) = 
fun lam -> 
let lst  = []
 in 

 (match lam with 
|V v -> (v :: lst)
|P (v, l) -> erase (v) (check_help (l))
|C (l1, l2) -> (check_help (l1) @ check_help (l2)))

let rec check  : (lambda -> bool) = 
fun lam -> if (check_help (lam) = []) then true
 else false

Time : 0.00149607658386
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_17/sub74.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun lam -> 
let rec get  = 
fun lam lst1 lst2 -> 
 (match lam with 
|V x -> (lst1, (x :: lst2))
|P (x, e) -> 
let lst'  = (x :: lst1)
 in 
get (e) (lst') (lst2)
|C (e1, e2) -> 
let t  = get (e1) (lst1) (lst2)
 in 
get (e2) (fst (t)) (snd (t)))
 in 

let rec search  = 
fun lst1 lst2 -> 
 (match lst2 with 
|[] -> true
|hd::tl -> 
let rec find p lst  = 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = p) then true
 else find (p) (tl))
 in 
if find (hd) (lst1) then search (lst1) (tl)
 else false)
 in 

 (match lam with 
|V x -> true
|_ -> 
let t  = get (lam) ([]) ([])
 in 
search (fst (t)) (snd (t)))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = (60639, 
fun lam -> (60638, 
let rec get  = (60585, 
fun lam lst1 lst2 -> (60582, 
 (match (60546, lam with 
|V x -> (60551, ((60547, lst1, (60550, ((60548, x :: (60549, lst2))
|P (x, e) -> (60562, 
let lst'  = (60554, ((60552, x :: (60553, lst1)
 in 
(60561, (60560, (60559, (60555, get ((60556, e) ((60557, lst') ((60558, lst2)
|C (e1, e2) -> (60581, 
let t  = (60569, (60568, (60567, (60563, get ((60564, e1) ((60565, lst1) ((60566, lst2)
 in 
(60580, (60579, (60578, (60570, get ((60571, e2) ((60574, (60572, fst ((60573, t)) ((60577, (60575, snd ((60576, t)))
 in 
(60637, 
let rec search  = (60616, 
fun lst1 lst2 -> (60614, 
 (match (60586, lst2 with 
|[] -> (60587, true
|hd::tl -> (60613, 
let rec find p lst  = (60600, 
 (match (60588, lst with 
|[] -> (60589, false
|hd::tl -> (60599, if (60592, ((60590, hd = (60591, p) then (60593, true
 else (60598, (60597, (60594, find ((60595, p) ((60596, tl))
 in 
(60612, if (60605, (60604, (60601, find ((60602, hd) ((60603, lst1) then (60610, (60609, (60606, search ((60607, lst1) ((60608, tl)
 else (60611, false)
 in 
(60636, 
 (match (60617, lam with 
|V x -> (60618, true
|_ -> (60635, 
let t  = (60625, (60624, (60623, (60619, get ((60620, lam) ((60621, []) ((60622, [])
 in 
(60634, (60633, (60626, search ((60629, (60627, fst ((60628, t)) ((60632, (60630, snd ((60631, t)))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_15/sub24.ml Score : -2
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let check  : (lambda -> bool) = 
fun e -> 
let rec check x y  = 
 (match x with 
|V x1 -> __list_mem__ (x1) (y)
|C (x1, y1) -> (check (x1) (y) && check (y1) (y))
|P (x1, y1) -> check (y1) ((x1 :: y)))
 in 
check (e) ([])

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (49743 : 
Input : (lam : lambda) 
Output : bool
Body : 
 (match lam with 
|V x -> true
|_ -> 
let t  : (string list * string list) = get (lam) ([]) ([])
 in 
search (fst (t)) (snd (t))),

find -> (49746 : 
Input : (p : string) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = p) then true
 else find (p) (tl)),

fst -> (49739 : 
Input : ((t : string list), (_ : string list)) 
Output : #7599
Body : t,

get -> (49744 : 
Input : (lam : lambda) (lst1 : string list) (lst2 : string list) 
Output : (string list * string list)
Body : 
 (match lam with 
|V x -> (lst1, (x :: lst2))
|P (x, e) -> 
let lst'  : string list = (x :: lst1)
 in 
get (e) (lst') (lst2)
|C (e1, e2) -> 
let t  : (string list * string list) = get (e1) (lst1) (lst2)
 in 
get (e2) (fst (t)) (snd (t))),

search -> (49745 : 
Input : (lst1 : string list) (lst2 : string list) 
Output : bool
Body : 
 (match lst2 with 
|[] -> true
|hd::tl -> if find (hd) (lst1) then search (lst1) (tl)
 else false),

snd -> (49740 : 
Input : ((_ : string list), (t : string list)) 
Output : #7603
Body : t}
Edge : 
{(49743, 49739) -> ,
(49743, 49740) -> ,
(49743, 49744) -> ,
(49743, 49745) -> ,
(49744, 49739) -> ,
(49744, 49740) -> ,
(49744, 49744) -> ,
(49745, 49745) -> ,
(49745, 49746) -> ,
(49746, 49746) -> }
Starting : 49743
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{__list_mem__ -> (49683 : 
Input : elem (lst : #992755 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (49708 : 
Input : (e : lambda) 
Output : bool
Body : check (e) ([])}
Edge : 
{(49683, 49683) -> ,
(49708, 49709) -> ,
(49709, 49683) -> ,
(49709, 49709) -> }
Starting : 49708
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
find -> __list_mem__}
------Remainings in submission ------
{fst,get,search,snd}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60588 : ?)

Decls : 
,Exp : Modify (60599 : ((? = ?) || ? (?) (?)))

Decls : 
,Exp : Modify (60636 : ? (?) ([]))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60588 : ?)

Decls : 
,Exp : Modify (60599 : ((? = ?) || ? (?) (?)))

Decls : 
,Exp : Modify (60636 : ? (?) ([]))

Decls : 
}
Fail to Repair
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_18/sub14.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let pgm1  = P (("a", V ("a")))

let pgm2  = P (("a", V ("b")))

let check  : (lambda -> bool) = 
fun lam -> 
 (match lam with 
|P (v1, e1) -> 
 (match e1 with 
|P (v2, e2) -> if (v1 = v2) then true
 else false
|V v2 -> if (v1 = v2) then true
 else false
|C (V v2, V v3) -> if ((v1 = v2) || (v1 = v3)) then true
 else false))

let _  = check (pgm1)

let _  = check (pgm2)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let pgm1  = (60550, P ((60549, ((60546, "a", (60548, V ((60547, "a")))

let pgm2  = (60555, P ((60554, ((60551, "a", (60553, V ((60552, "b")))

let check  : (lambda -> bool) = (60582, 
fun lam -> (60581, 
 (match (60556, lam with 
|P (v1, e1) -> (60580, 
 (match (60557, e1 with 
|P (v2, e2) -> (60563, if (60560, ((60558, v1 = (60559, v2) then (60561, true
 else (60562, false
|V v2 -> (60569, if (60566, ((60564, v1 = (60565, v2) then (60567, true
 else (60568, false
|C (V v2, V v3) -> (60579, if (60576, ((60572, ((60570, v1 = (60571, v2) || (60575, ((60573, v1 = (60574, v3)) then (60577, true
 else (60578, false))

let _  = (60585, (60583, check ((60584, pgm1)

let _  = (60588, (60586, check ((60587, pgm2)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : (lam : lambda) 
Output : bool
Body : 
 (match lam with 
|P (v1, e1) -> 
 (match e1 with 
|P (v2, e2) -> if (v1 = v2) then true
 else false
|V v2 -> if (v1 = v2) then true
 else false
|C (V v2, V v3) -> if ((v1 = v2) || (v1 = v3)) then true
 else false))}
Edge : 
empty
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60581 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60581 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let pgm1  = P (("a", V ("a")))

let pgm2  = P (("a", V ("b")))

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (pgm1)

let _  = check (pgm2)

Time : 0.00173902511597
../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_18/sub17.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec check  : (lambda -> bool) = 
fun lam -> 
 (match lam with 
|V v1 -> true
|P (v2, lam1) -> 
 (match lam1 with 
|V v2 -> true
|P (v3, lam2) -> check (lam2)
|C (lam3, lam4) -> 
let bool1  = check (lam3)
 in 

let bool2  = check (lam4)
 in 
if ((bool1 = bool2) = true) then true
 else false
|C (lam1, lam2) -> 
let bool3  = check (lam1)
 in 

let bool4  = check (lam2)
 in 
if ((bool3 = bool4) = true) then true
 else false
|_ -> false))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = (60588, 
fun lam -> (60587, 
 (match (60546, lam with 
|V v1 -> (60547, true
|P (v2, lam1) -> (60586, 
 (match (60548, lam1 with 
|V v2 -> (60549, true
|P (v3, lam2) -> (60552, (60550, check ((60551, lam2)
|C (lam3, lam4) -> (60568, 
let bool1  = (60555, (60553, check ((60554, lam3)
 in 
(60567, 
let bool2  = (60558, (60556, check ((60557, lam4)
 in 
(60566, if (60563, ((60561, ((60559, bool1 = (60560, bool2) = (60562, true) then (60564, true
 else (60565, false
|C (lam1, lam2) -> (60584, 
let bool3  = (60571, (60569, check ((60570, lam1)
 in 
(60583, 
let bool4  = (60574, (60572, check ((60573, lam2)
 in 
(60582, if (60579, ((60577, ((60575, bool3 = (60576, bool4) = (60578, true) then (60580, true
 else (60581, false
|_ -> (60585, false))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : 0
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (45777 : 
Input : (lam : lambda) 
Output : bool
Body : 
 (match lam with 
|V v1 -> true
|P (v2, lam1) -> 
 (match lam1 with 
|V v2 -> true
|P (v3, lam2) -> check (lam2)
|C (lam3, lam4) -> 
let bool1  : bool = check (lam3)
 in 

let bool2  : bool = check (lam4)
 in 
if ((bool1 = bool2) = true) then true
 else false
|C (lam1, lam2) -> 
let bool3  : bool = check (lam1)
 in 

let bool4  : bool = check (lam2)
 in 
if ((bool3 = bool4) = true) then true
 else false
|_ -> false))}
Edge : 
{(45777, 45777) -> }
Starting : 45777
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (45743 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (45742 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(45742, 45742) -> ,
(45743, 45742) -> }
Starting : 45743
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check}
------Remainings in submission ------
{}
------Remainings in solution ------
{checking}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60587 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60587 : ? (?) ([]))

Decls : 

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

Callers : {check}
}
-----------------------------
Patch
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking (lam : lambda) (lst : string list)  : bool = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

Time : 0.0014169216156
Error occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_18/sub20.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_18/sub25.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let t1  = P (("a", V ("a")))

let t2  = P (("a", P (("a", V ("a")))))

let t3  = P (("a", P (("b", C ((V ("a"), V ("b")))))))

let t4  = P (("a", C ((V ("a"), P (("b", V ("a")))))))

let t5  = P (("a", V ("b")))

let t6  = P (("a", C ((V ("a"), P (("b", V ("c")))))))

let t7  = P (("a", P (("b", C ((V ("a"), V ("c")))))))

let rec make_Plst lam  = 
 (match lam with 
|P (v, lam') -> (v :: make_Plst (lam'))
|C (lam1, lam2) -> (make_Plst (lam1) @ make_Plst (lam2))
|_ -> [])

let rec make_Vlst lam  = 
 (match lam with 
|V v -> (v :: [])
|P (v, lam') -> make_Vlst (lam')
|C (lam1, lam2) -> (make_Vlst (lam1) @ make_Vlst (lam2)))

let rec check_in_lst lst v  = 
 (match lst with 
|[] -> false
|head::tail -> if (head = v) then true
 else check_in_lst (tail) (v))

let rec check_VP lstP lstV  = 
 (match lstV with 
|[] -> true
|head::tail -> if (check_in_lst (lstP) (head) = true) then check_VP (lstP) (tail)
 else false)

let check  : (lambda -> bool) = 
fun lam -> 
let lstP  = make_Plst (lam)
 in 

let lstV  = make_Vlst (lam)
 in 
check_VP (lstP) (lstV)

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let t1  = (60550, P ((60549, ((60546, "a", (60548, V ((60547, "a")))

let t2  = (60558, P ((60557, ((60551, "a", (60556, P ((60555, ((60552, "a", (60554, V ((60553, "a")))))

let t3  = (60570, P ((60569, ((60559, "a", (60568, P ((60567, ((60560, "b", (60566, C ((60565, ((60562, V ((60561, "a"), (60564, V ((60563, "b")))))))

let t4  = (60582, P ((60581, ((60571, "a", (60580, C ((60579, ((60573, V ((60572, "a"), (60578, P ((60577, ((60574, "b", (60576, V ((60575, "a")))))))

let t5  = (60587, P ((60586, ((60583, "a", (60585, V ((60584, "b")))

let t6  = (60599, P ((60598, ((60588, "a", (60597, C ((60596, ((60590, V ((60589, "a"), (60595, P ((60594, ((60591, "b", (60593, V ((60592, "c")))))))

let t7  = (60611, P ((60610, ((60600, "a", (60609, P ((60608, ((60601, "b", (60607, C ((60606, ((60603, V ((60602, "a"), (60605, V ((60604, "c")))))))

let rec make_Plst lam  = (60626, 
 (match (60612, lam with 
|P (v, lam') -> (60617, ((60613, v :: (60616, (60614, make_Plst ((60615, lam'))
|C (lam1, lam2) -> (60624, ((60620, (60618, make_Plst ((60619, lam1) @ (60623, (60621, make_Plst ((60622, lam2))
|_ -> (60625, [])

let rec make_Vlst lam  = (60641, 
 (match (60627, lam with 
|V v -> (60630, ((60628, v :: (60629, [])
|P (v, lam') -> (60633, (60631, make_Vlst ((60632, lam')
|C (lam1, lam2) -> (60640, ((60636, (60634, make_Vlst ((60635, lam1) @ (60639, (60637, make_Vlst ((60638, lam2)))

let rec check_in_lst lst v  = (60654, 
 (match (60642, lst with 
|[] -> (60643, false
|head::tail -> (60653, if (60646, ((60644, head = (60645, v) then (60647, true
 else (60652, (60651, (60648, check_in_lst ((60649, tail) ((60650, v))

let rec check_VP lstP lstV  = (60671, 
 (match (60655, lstV with 
|[] -> (60656, true
|head::tail -> (60670, if (60663, ((60661, (60660, (60657, check_in_lst ((60658, lstP) ((60659, head) = (60662, true) then (60668, (60667, (60664, check_VP ((60665, lstP) ((60666, tail)
 else (60669, false)

let check  : (lambda -> bool) = (60685, 
fun lam -> (60684, 
let lstP  = (60674, (60672, make_Plst ((60673, lam)
 in 
(60683, 
let lstV  = (60677, (60675, make_Vlst ((60676, lam)
 in 
(60682, (60681, (60678, check_VP ((60679, lstP) ((60680, lstV)

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub55.ml Score : 1
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checklambda  : (var list -> (lambda -> bool)) = 
fun lst lam -> 
 (match lam with 
|V x -> __list_mem__ (x) (lst)
|P (x, l) -> checklambda ((x :: lst)) (l)
|C (l1, l2) -> (checklambda (lst) (l1) && checklambda (lst) (l2)))

let check  : (lambda -> bool) = 
fun lam -> checklambda ([]) (lam)

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{check -> (51069 : 
Input : (lam : lambda) 
Output : bool
Body : 
let lstP  : string list = make_Plst (lam)
 in 

let lstV  : string list = make_Vlst (lam)
 in 
check_VP (lstP) (lstV),

check_VP -> (51068 : 
Input : (lstP : #1036235 list) (lstV : #1036235 list) 
Output : bool
Body : 
 (match lstV with 
|[] -> true
|head::tail -> if (check_in_lst (lstP) (head) = true) then check_VP (lstP) (tail)
 else false),

check_in_lst -> (51067 : 
Input : (lst : #7543 list) v 
Output : bool
Body : 
 (match lst with 
|[] -> false
|head::tail -> if (head = v) then true
 else check_in_lst (tail) (v)),

make_Plst -> (51065 : 
Input : (lam : lambda) 
Output : string list
Body : 
 (match lam with 
|P (v, lam') -> (v :: make_Plst (lam'))
|C (lam1, lam2) -> (make_Plst (lam1) @ make_Plst (lam2))
|_ -> []),

make_Vlst -> (51066 : 
Input : (lam : lambda) 
Output : string list
Body : 
 (match lam with 
|V v -> (v :: [])
|P (v, lam') -> make_Vlst (lam')
|C (lam1, lam2) -> (make_Vlst (lam1) @ make_Vlst (lam2)))}
Edge : 
{(51065, 51065) -> ,
(51066, 51066) -> ,
(51067, 51067) -> ,
(51068, 51067) -> ,
(51068, 51068) -> ,
(51069, 51065) -> ,
(51069, 51066) -> ,
(51069, 51068) -> }
Starting : 51069
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{__list_mem__ -> (51005 : 
Input : elem (lst : #1035065 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (51031 : 
Input : (lam : lambda) 
Output : bool
Body : checklambda ([]) (lam),

checklambda -> (51030 : 
Input : (lst : string list) (lam : lambda) 
Output : bool
Body : 
 (match lam with 
|V x -> __list_mem__ (x) (lst)
|P (x, l) -> checklambda ((x :: lst)) (l)
|C (l1, l2) -> (checklambda (lst) (l1) && checklambda (lst) (l2)))}
Edge : 
{(51005, 51005) -> ,
(51030, 51005) -> ,
(51030, 51030) -> ,
(51031, 51030) -> }
Starting : 51031
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{check -> check,
check_VP -> __list_mem__,
check_in_lst -> checklambda}
------Remainings in submission ------
{make_Plst,make_Vlst}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60642 : ?)

Decls : 
,Exp : Modify (60655 : ?)

Decls : 
,Exp : Modify (60656 : false)

Decls : 
,Exp : Modify (60670 : ((? = ?) || ? (?) (?)))

Decls : 
,Exp : Modify (60684 : ? ([]) (?))

Decls : 
,Exp : Insert (C (l1, l2) -> (? (?) (?) && ? (?) (?)) At label 60654

Decls : 
,Exp : Insert (P (x, l) -> ? ((? :: ?)) (?) At label 60654

Decls : 
,Exp : Insert (V x -> ? (?) (?) At label 60654

Decls : 
,Exp : Delete ([] -> false At label 60654

Decls : 
,Exp : Delete (head::tail -> if (head = v) then true
 else check_in_lst (tail) (v) At label 60654

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60642 : ?)

Decls : 
,Exp : Modify (60655 : ?)

Decls : 
,Exp : Modify (60656 : false)

Decls : 
,Exp : Modify (60670 : ((? = ?) || ? (?) (?)))

Decls : 
,Exp : Modify (60684 : ? ([]) (?))

Decls : 
,Exp : Insert (C (l1, l2) -> (? (?) (?) && ? (?) (?)) At label 60654

Decls : 
,Exp : Insert (P (x, l) -> ? ((? :: ?)) (?) At label 60654

Decls : 
,Exp : Insert (V x -> ? (?) (?) At label 60654

Decls : 
,Exp : Delete ([] -> false At label 60654

Decls : 
,Exp : Delete (head::tail -> if (head = v) then true
 else check_in_lst (tail) (v) At label 60654

Decls : 
}
Fail to Repair
Error occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_18/sub38.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcasesError occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_18/sub4.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcasesError occurs : ../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_18/sub43.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases../engine/main.native -dd -submission ../benchmarks_incorrect/All_lambda/k_18/sub5.ml -solutions ../benchmarks_correct/All_lambda -entry check -testcases ../testcases/lambda_testcases
-----------------------------
Submission
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string
type v_set = var list

let rec union1  : ((v_set * v_set) -> v_set) = 
fun (s1, s2) -> 
 (match s1 with 
|[] -> s2
|hd::tl -> if __list_mem__ (hd) (s2) then union1 ((tl, s2))
 else union1 ((tl, (hd :: s2))))

let rec find_erase  : (var -> (v_set -> (v_set -> v_set))) = 
fun v s sc -> 
 (match s with 
|hd::tl -> if (hd = v) then (tl @ sc)
 else find_erase (v) (tl) ((hd :: sc))
|[] -> sc)

let rec union2  : ((v_set * v_set) -> v_set) = 
fun (s1, s2) -> 
 (match s1 with 
|[] -> s1
|hd::tl -> if __list_mem__ (hd) (s2) then (hd :: union2 ((tl, s2)))
 else union2 ((tl, s2)))

let rec save  : (lambda -> (v_set -> v_set)) = 
fun lam s -> 
 (match lam with 
|P (_, l) -> save (l) (s)
|C (l1, l2) -> union1 ((save (l1) (s), save (l2) (s)))
|V v -> if __list_mem__ (v) (s) then s
 else (v :: s))

let rec erase  : (lambda -> (v_set -> v_set)) = 
fun lam s -> 
 (match lam with 
|P (v, l) -> erase (l) (find_erase (v) (s) ([]))
|C (l1, l2) -> union2 ((erase (l1) (s), erase (l2) (s)))
|V v -> s)

let check  : (lambda -> bool) = 
fun lam -> 
 (match erase (lam) (save (lam) ([])) with 
|[] -> true
|hd::tl -> false)

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Submission
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string
type v_set = var list

let rec union1  : ((v_set * v_set) -> v_set) = (60567, 
fun (s1, s2) -> (60566, 
 (match (60546, s1 with 
|[] -> (60547, s2
|hd::tl -> (60565, if (60552, (60551, (60548, __list_mem__ ((60549, hd) ((60550, s2) then (60557, (60553, union1 ((60556, ((60554, tl, (60555, s2))
 else (60564, (60558, union1 ((60563, ((60559, tl, (60562, ((60560, hd :: (60561, s2))))

let rec find_erase  : (var -> (v_set -> (v_set -> v_set))) = (60589, 
fun v s sc -> (60586, 
 (match (60568, s with 
|hd::tl -> (60584, if (60571, ((60569, hd = (60570, v) then (60574, ((60572, tl @ (60573, sc)
 else (60583, (60582, (60581, (60575, find_erase ((60576, v) ((60577, tl) ((60580, ((60578, hd :: (60579, sc))
|[] -> (60585, sc)

let rec union2  : ((v_set * v_set) -> v_set) = (60611, 
fun (s1, s2) -> (60610, 
 (match (60590, s1 with 
|[] -> (60591, s1
|hd::tl -> (60609, if (60596, (60595, (60592, __list_mem__ ((60593, hd) ((60594, s2) then (60603, ((60597, hd :: (60602, (60598, union2 ((60601, ((60599, tl, (60600, s2)))
 else (60608, (60604, union2 ((60607, ((60605, tl, (60606, s2)))

let rec save  : (lambda -> (v_set -> v_set)) = (60643, 
fun lam s -> (60641, 
 (match (60612, lam with 
|P (_, l) -> (60617, (60616, (60613, save ((60614, l) ((60615, s)
|C (l1, l2) -> (60630, (60618, union1 ((60629, ((60623, (60622, (60619, save ((60620, l1) ((60621, s), (60628, (60627, (60624, save ((60625, l2) ((60626, s)))
|V v -> (60640, if (60635, (60634, (60631, __list_mem__ ((60632, v) ((60633, s) then (60636, s
 else (60639, ((60637, v :: (60638, s))

let rec erase  : (lambda -> (v_set -> v_set)) = (60672, 
fun lam s -> (60670, 
 (match (60644, lam with 
|P (v, l) -> (60655, (60654, (60645, erase ((60646, l) ((60653, (60652, (60651, (60647, find_erase ((60648, v) ((60649, s) ((60650, []))
|C (l1, l2) -> (60668, (60656, union2 ((60667, ((60661, (60660, (60657, erase ((60658, l1) ((60659, s), (60666, (60665, (60662, erase ((60663, l2) ((60664, s)))
|V v -> (60669, s)

let check  : (lambda -> bool) = (60685, 
fun lam -> (60684, 
 (match (60681, (60680, (60673, erase ((60674, lam) ((60679, (60678, (60675, save ((60676, lam) ((60677, [])) with 
|[] -> (60682, true
|hd::tl -> (60683, false)

let _  = (60692, (60686, check ((60691, P ((60690, ((60687, "a", (60689, V ((60688, "a"))))

let _  = (60702, (60693, check ((60701, P ((60700, ((60694, "a", (60699, P ((60698, ((60695, "a", (60697, V ((60696, "a"))))))

let _  = (60716, (60703, check ((60715, P ((60714, ((60704, "a", (60713, P ((60712, ((60705, "b", (60711, C ((60710, ((60707, V ((60706, "a"), (60709, V ((60708, "b"))))))))

let _  = (60730, (60717, check ((60729, P ((60728, ((60718, "a", (60727, C ((60726, ((60720, V ((60719, "a"), (60725, P ((60724, ((60721, "b", (60723, V ((60722, "a"))))))))

let _  = (60737, (60731, check ((60736, P ((60735, ((60732, "a", (60734, V ((60733, "b"))))

let _  = (60751, (60738, check ((60750, P ((60749, ((60739, "a", (60748, C ((60747, ((60741, V ((60740, "a"), (60746, P ((60745, ((60742, "b", (60744, V ((60743, "c"))))))))

let _  = (60765, (60752, check ((60764, P ((60763, ((60753, "a", (60762, P ((60761, ((60754, "b", (60760, C ((60759, ((60756, V ((60755, "a"), (60758, V ((60757, "c"))))))))

-----------------------------
Most Similar Sol ../benchmarks_correct/All_lambda/k_18/sub9.ml Score : -3
-----------------------------

type lambda =
|V of var
|P of (var * lambda)
|C of (lambda * lambda)
and var = string

let rec checking lam lst  = 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))

let rec check  : (lambda -> bool) = 
fun lam -> checking (lam) ([])

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

-----------------------------
Call graph (sub)
-----------------------------
Node : 
{__list_mem__ -> (52362 : 
Input : elem (lst : #1098033 list) 
Output : bool
Body : 
 (match lst with 
|[] -> false
|hd::tl -> ((hd = elem) || __list_mem__ (elem) (tl))),

check -> (52392 : 
Input : (lam : lambda) 
Output : bool
Body : 
 (match erase (lam) (save (lam) ([])) with 
|[] -> true
|hd::tl -> false),

erase -> (52391 : 
Input : (lam : lambda) (s : string list) 
Output : v_set
Body : 
 (match lam with 
|P (v, l) -> erase (l) (find_erase (v) (s) ([]))
|C (l1, l2) -> union2 ((erase (l1) (s), erase (l2) (s)))
|V v -> s),

find_erase -> (52388 : 
Input : (v : string) (s : string list) (sc : string list) 
Output : v_set
Body : 
 (match s with 
|hd::tl -> if (hd = v) then (tl @ sc)
 else find_erase (v) (tl) ((hd :: sc))
|[] -> sc),

save -> (52390 : 
Input : (lam : lambda) (s : string list) 
Output : v_set
Body : 
 (match lam with 
|P (_, l) -> save (l) (s)
|C (l1, l2) -> union1 ((save (l1) (s), save (l2) (s)))
|V v -> if __list_mem__ (v) (s) then s
 else (v :: s)),

union1 -> (52387 : 
Input : ((s1 : string list), (s2 : string list)) 
Output : v_set
Body : 
 (match s1 with 
|[] -> s2
|hd::tl -> if __list_mem__ (hd) (s2) then union1 ((tl, s2))
 else union1 ((tl, (hd :: s2)))),

union2 -> (52389 : 
Input : ((s1 : string list), (s2 : string list)) 
Output : v_set
Body : 
 (match s1 with 
|[] -> s1
|hd::tl -> if __list_mem__ (hd) (s2) then (hd :: union2 ((tl, s2)))
 else union2 ((tl, s2)))}
Edge : 
{(52362, 52362) -> ,
(52387, 52362) -> ,
(52387, 52387) -> ,
(52388, 52388) -> ,
(52389, 52362) -> ,
(52389, 52389) -> ,
(52390, 52362) -> ,
(52390, 52387) -> ,
(52390, 52390) -> ,
(52391, 52388) -> ,
(52391, 52389) -> ,
(52391, 52391) -> ,
(52392, 52390) -> ,
(52392, 52391) -> }
Starting : 52392
-----------------------------
Call graph (sol)
-----------------------------
Node : 
{check -> (52353 : 
Input : (lam : lambda) 
Output : bool
Body : checking (lam) ([]),

checking -> (52352 : 
Input : (lam : lambda) (lst : string list) 
Output : bool
Body : 
 (match lst with 
|[] -> 
 (match lam with 
|V x -> false
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false)
|hd::tl -> 
 (match lam with 
|V x -> if (x = hd) then true
 else checking (lam) (tl)
|P (x, l) -> checking (l) ((x :: lst))
|C (l1, l2) -> if ((checking (l1) (lst) = true) && (checking (l2) (lst) = true)) then true
 else false))}
Edge : 
{(52352, 52352) -> ,
(52353, 52352) -> }
Starting : 52353
-----------------------------
Matching Info
-----------------------------
------Match Informations (submissoin)------
{__list_mem__ -> checking,
check -> check}
------Remainings in submission ------
{erase,find_erase,save,union1,union2}
------Remainings in solution ------
{}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60684 : ? (?) ([]))

Decls : 
}
-----------------------------
Templates
-----------------------------
{Exp : Modify (60684 : ? (?) ([]))

Decls : 
}
Fail to Repair

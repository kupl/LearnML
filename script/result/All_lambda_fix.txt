../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/09/sub1.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check (m : lambda)  = 
 (match m with 
|P (a, V b) -> if (a = b) then true
 else false
|P (a, P (b, c)) -> if (a = b) then check (P ((b, c)))
 else if (check (P ((a, c))) = true) then true
 else if (check (P ((b, c))) = true) then true
 else false
|P (a, C (b, c)) -> if (check (P ((a, b))) = true) then if (check (P ((a, c))) = true) then true
 else false
 else false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/09/sub15.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check met  = 
let rec checkArea id m  = 
 (match m with 
|V n -> __list_exists__ (
fun x -> (x = n)) (id)
|C (s1, s2) -> (checkArea (id) (s1) && checkArea (id) (s2))
|P (id2, m) -> checkArea ((id2 :: id)) (m))
 in 

 (match met with 
|P (id, m) -> checkArea ([id]) (m)
|_ -> false)

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check met  = 
let rec checkArea id m  = 
 (match m with 
|V n -> __list_exists__ (
fun x -> (x = n)) (id)
|C (s1, s2) -> (checkArea (id) (s1) && checkArea (id) (s2))
|P (id2, m) -> checkArea ((id2 :: id)) (m))
 in 

 (match met with 
|P (id, m) -> checkArea ([id]) (m)
|_ -> checkArea ([]) (met))

Total time :0.041251
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/09/sub16.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check met  = 
let rec checkArea id m  = 
 (match m with 
|V n -> __list_exists__ (
fun x -> (x = n)) (id)
|C (s1, s2) -> (checkArea (id) (s1) && checkArea (id) (s2))
|P (id2, m) -> checkArea ((id2 :: id)) (m))
 in 

 (match met with 
|P (id, m) -> checkArea ([id]) (m)
|_ -> false)

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check met  = 
let rec checkArea id m  = 
 (match m with 
|V n -> __list_exists__ (
fun x -> (x = n)) (id)
|C (s1, s2) -> (checkArea (id) (s1) && checkArea (id) (s2))
|P (id2, m) -> checkArea ((id2 :: id)) (m))
 in 

 (match met with 
|P (id, m) -> checkArea ([id]) (m)
|_ -> checkArea ([]) (met))

Total time :0.040384
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/09/sub17.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check m  = 
let rec append m1 m2  = 
 (match m1 with 
|h::t -> if __list_mem__ (h) (m2) then append (t) (m2)
 else append (t) ((h :: m2))
|[] -> m2)
 in 

let rec check2 m l  = 
 (match m with 
|V n -> l
|P (n, m2) -> if __list_mem__ (n) (l) then check2 (m2) (l)
 else check2 (m2) ((n :: l))
|C (m1, m2) -> append (check2 (m1) (l)) (check2 (m2) (l)))
 in 

let rec check3 m l  = 
 (match m with 
|V n -> if __list_mem__ (n) (l) then true
 else false
|P (n, m2) -> check3 (m2) (l)
|C (m1, m2) -> (check3 (m1) (l) && check3 (m2) (l)))
 in 

let l  = check2 (m) ([])
 in 
check3 (m) (l)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/09/sub19.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check m  = 
let rec make_area_list m  = 
 (match m with 
|V n -> []
|P (n, m1) -> (n :: make_area_list (m1))
|C (m1, m2) -> (make_area_list (m1) @ make_area_list (m2)))
 in 

let rec match_list_with_station m l  = 
 (match m with 
|P (n, m1) -> match_list_with_station (m1) (l)
|C (m1, m2) -> (match_list_with_station (m1) (l) && match_list_with_station (m2) (l))
|V n -> if __list_exists__ (
fun x -> (x = n)) (l) then true
 else false)
 in 
match_list_with_station (m) (make_area_list (m))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/09/sub20.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

exception Error of string
type lambda =
|C of (lambda * lambda)
|P of (string * lambda)
|V of string

let rec check met  = 
let rec check a me  = 
 (match me with 
|V x -> if (x = a) then true
 else false
|P (q, V b) -> if (a = b) then true
 else false
|P (x, C (t, p)) -> 
 (match (t, p) with 
|(V e, V f) -> (check (x) (t) || check (x) (p))
|_ -> (check (x) (t) && check (x) (p)))
|P (x, P (e, f)) -> (check (x) (P ((e, f))) && check (e) (f))
|C (x, y) -> 
 (match (x, y) with 
|(V e, V f) -> (check (a) (x) || check (a) (y))
|_ -> (check (a) (x) && check (a) (x))))
 in 

 (match met with 
|P (b, c) -> check (b) (c)
|_ -> raise Error ("Illegal input"))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/10/sub21.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check met  = 
let rec check met lst  = 
 (match met with 
|V id -> __list_mem__ (id) (lst)
|P (id, m) -> check (m) ((lst @ [id]))
|C (m1, m2) -> (check (m1) (lst) && check (m2) (lst)))
 in 

 (match met with 
|V id -> false
|P (id, m) -> check (m) ([id])
|C (m1, m2) -> false)

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check met  = 
let rec check met lst  = 
 (match met with 
|V id -> __list_mem__ (id) (lst)
|P (id, m) -> check (m) ((lst @ [id]))
|C (m1, m2) -> (check (m1) (lst) && check (m2) (lst)))
 in 

 (match met with 
|V id -> false
|P (id, m) -> check (m) ([id])
|C (m1, m2) -> check (C ((m2, m1))) ([]))

Total time :1.251485
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/10/sub7.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check lambda  = 
 (match lambda with 
|V var -> false
|P (var1, V var2) -> (var1 = var2)
|P (var1, P (var2, C (lambda1, lambda2))) -> ((check (P ((var1, lambda1))) && check (P ((var2, lambda2)))) || (check (P ((var1, lambda2))) && check (P ((var2, lambda1)))))
|P (var1, P (var2, lambda)) -> (check (P ((var1, lambda))) || check (P ((var2, lambda))))
|P (var, C (lambda1, lambda2)) -> (check (P ((var, lambda1))) && check (P ((var, lambda2))))
|C (lambda1, lambda2) -> (check (lambda1) && check (lambda2)))

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check lambda  = 
 (match lambda with 
|V var -> false
|P (var1, V var2) -> (var1 = var2)
|P (var1, P (var2, C (lambda1, lambda2))) -> ((check (P ((var1, lambda1))) && check (P ((var2, lambda2)))) || (false = (lambda1 = V (var1))))
|P (var1, P (var2, lambda)) -> (check (P ((var1, lambda))) || check (P ((var2, lambda))))
|P (var, C (lambda1, lambda2)) -> (check (P ((var, lambda1))) && check (P ((var, lambda2))))
|C (lambda1, lambda2) -> (check (lambda1) && check (lambda2)))

Total time :1.184394
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/11/sub13.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check m  = 
let rec idCheck id_list m  = 
let rec exists f l  = 
 (match l with 
|[] -> false
|h::t -> if (f = h) then true
 else exists (f) (t))
 in 

 (match m with 
|V a -> exists (a) (id_list)
|P (id1, m1) -> idCheck ((id1 :: id_list)) (m1)
|C (m1, m2) -> (idCheck (id_list) (m1) && idCheck (id_list) (m2)))
 in 

 (match m with 
|P (var, lambda) -> idCheck ((var :: [])) (lambda)
|_ -> false)

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check m  = 
let rec idCheck id_list m  = 
let rec exists f l  = 
 (match l with 
|[] -> false
|h::t -> if (f = h) then true
 else exists (f) (t))
 in 

 (match m with 
|V a -> exists (a) (id_list)
|P (id1, m1) -> idCheck ((id1 :: id_list)) (m1)
|C (m1, m2) -> (idCheck (id_list) (m1) && idCheck (id_list) (m2)))
 in 

 (match m with 
|P (var, lambda) -> idCheck ((var :: [])) (lambda)
|_ -> idCheck ([]) (m))

Total time :0.04192
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/11/sub16.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check lambda  = 
 (match lambda with 
|P (a, V b) -> (a = b)
|P (a, C (b, c)) -> (check (P ((a, b))) && check (P ((a, c))))
|P (a, P (b, c)) -> check (P ((a, c)))
|C (_, _) -> false
|V _ -> false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/11/sub21.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec sub (l, a)  = 
 (match l with 
|[] -> []
|hd::tl -> if (hd = a) then sub ((tl, a))
 else (hd :: sub ((tl, a))))

let rec concat (a, b)  = 
 (match a with 
|[] -> b
|hd::tl -> (hd :: concat ((tl, b))))

let rec listsub (m : lambda)  = 
 (match m with 
|V a -> [a]
|P (a, b) -> sub ((listsub (b), a))
|C (a, b) -> concat ((listsub (a), listsub (b))))

let check (m : lambda)  = 
 (match m with 
|V a -> false
|P (a, b) -> if (sub ((listsub (b), a)) = []) then true
 else false
|C (a, b) -> false)

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec sub (l, a)  = 
 (match l with 
|[] -> []
|hd::tl -> if (hd = a) then sub ((tl, a))
 else (hd :: sub ((tl, a))))

let rec concat (a, b)  = 
 (match a with 
|[] -> b
|hd::tl -> (hd :: concat ((tl, b))))

let rec listsub (m : lambda)  = 
 (match m with 
|V a -> [a]
|P (a, b) -> sub ((listsub (b), a))
|C (a, b) -> concat ((listsub (a), listsub (b))))

let check (m : lambda)  = 
 (match m with 
|V a -> false
|P (a, b) -> if (sub ((listsub (b), a)) = []) then true
 else false
|C (a, b) -> (listsub (b) = listsub (a)))

Total time :0.141569
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/11/sub3.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

exception Invalid_input of string

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check m  = 
let rec check_sub (m, l)  = 
let rec checkArea (s, l)  = 
 (match l with 
|[] -> false
|h::t -> if (h = s) then true
 else checkArea ((s, t)))
 in 

 (match m with 
|V s -> checkArea ((s, l))
|P (a, m) -> check_sub ((m, (a :: l)))
|C (m0, m1) -> (check_sub ((m0, l)) && check_sub ((m1, l))))
 in 

 (match m with 
|V s -> raise Invalid_input ("V only")
|_ -> check_sub ((m, [])))

-----------------------------
result
-----------------------------

exception Invalid_input of string

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check m  = 
let rec check_sub (m, l)  = 
let rec checkArea (s, l)  = 
 (match l with 
|[] -> false
|h::t -> if (h = s) then true
 else checkArea ((s, t)))
 in 

 (match m with 
|V s -> checkArea ((s, l))
|P (a, m) -> check_sub ((m, (a :: l)))
|C (m0, m1) -> (check_sub ((m0, l)) && check_sub ((m1, l))))
 in 

 (match m with 
|V s -> false
|_ -> check_sub ((m, [])))

Total time :0.021115
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/11/sub5.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check a  = 
 (match a with 
|V _ -> raise Invalid_argument ("check")
|C (a, b) -> raise Invalid_argument ("check")
|P (a, V b) -> if (a = b) then true
 else false
|P (a, C (V b, V c)) -> if ((a = b) || (a = c)) then true
 else false
|P (a, C (P (b, V c), V d)) -> if ((a = c) || (a = d)) then true
 else false
|P (a, C (V b, P (c, V d))) -> if ((a = b) || (a = d)) then true
 else false
|P (a, b) -> check (b))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/11/sub6.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check a  = 
 (match a with 
|V _ -> raise Invalid_argument ("check")
|C (a, b) -> raise Invalid_argument ("check")
|P (a, V b) -> if (a = b) then true
 else false
|P (a, C (V b, V c)) -> if ((a = b) || (a = c)) then true
 else false
|P (a, C (P (b, V c), V d)) -> if ((a = c) && (a = d)) then true
 else false
|P (a, C (V b, P (c, V d))) -> if ((a = b) && (a = d)) then true
 else false
|P (a, b) -> check (b))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/11/sub7.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check m  = 
let rec areaList m1  = 
 (match m1 with 
|P (a, b) -> (a :: areaList (b))
|_ -> [])
 in 

let rec stationList m2  = 
 (match m2 with 
|V a -> [a]
|P (a, b) -> stationList (b)
|C (a, b) -> (stationList (a) @ stationList (b)))
 in 

let rec searchArea al st  = 
 (match al with 
|[] -> false
|hd::tl -> if (hd = st) then true
 else searchArea (tl) (st))
 in 

let rec matching al sl  = 
 (match sl with 
|[] -> true
|hd::tl -> if (searchArea (al) (hd) = false) then false
 else matching (al) (tl))
 in 

let _  = areaList (m)
 in 

let _  = stationList (m)
 in 
matching (areaList (m)) (stationList (m))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/11/sub8.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check met  = 
 (match met with 
|V n -> true
|C (met1, met2) -> (check (met1) && check (met2))
|P (stn0, met0) -> 
let check (a, b)  = if (a = b) then true
 else false
 in 

let rec chstn (stn, met)  = 
 (match met with 
|V stn' -> check ((stn, stn'))
|C (n1, n2) -> (chstn ((stn, n1)) || chstn ((stn, n2)))
|P (st, n3) -> (check ((stn, st)) || chstn ((stn, n3))))
 in 
chstn ((stn0, met0)))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/12/sub10.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------
type var = string
type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var

let rec checkName (n, mtr)  = 
 (match mtr with 
|V s -> if (n = s) then true
 else false
|P (n1, mtr1) -> checkName ((n1, mtr1))
|C (m1, m2) -> 
 (match (m1, m2) with 
|(_, P (nm1, mt1)) -> checkName ((n, mt1))
|(P (nm2, mt2), _) -> checkName ((n, mt2))
|(_, _) -> (checkName ((n, m1)) || checkName ((n, m2)))))

let rec check m  = 
 (match m with 
|P (n, mtr) -> checkName ((n, mtr))
|_ -> false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/12/sub17.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check lambda  = 
let rec varStation lambda  = 
 (match lambda with 
|V n -> (n :: [])
|P (n, m) -> varStation (m)
|C (m1, m2) -> __list_append__ (varStation (m1)) (varStation (m2)))
 in 

let rec varArea lambda  = 
 (match lambda with 
|V n -> []
|P (n, m) -> (n :: varArea (m))
|C (m1, m2) -> __list_append__ (varArea (m1)) (varArea (m2)))
 in 

let rec check l1 l2  = 
 (match l1 with 
|[] -> true
|hd::tl -> (__list_mem__ (hd) (l2) && check (tl) (l2)))
 in 
check (varStation (lambda)) (varArea (lambda))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/12/sub19.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------
type partial =
|SECONDHALF
|FIRSTHALF

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check lambda  = 
 (match lambda with 
|V _ -> false
|P (a, V s) -> if (a = s) then true
 else false
|P (a, P (a2, C (m1, m2))) -> (((check (P ((a2, C ((m1, m2))))) || (check (P ((a, m1))) && check (P ((a2, m2))))) || (check (P ((a, m2))) && check (P ((a2, m1))))) || (check (P ((a, m1))) && check (P ((a, m2)))))
|P (a, P (a2, m)) -> ((check (m) || check (P ((a2, m)))) || check (P ((a, m))))
|P (a, C (m1, m2)) -> (check (P ((a, m1))) && check (P ((a, m2))))
|C (V _, _) -> false
|C (_, V _) -> false
|C (P (a1, m1), P (a2, m2)) -> (check (P ((a1, m1))) && check (P ((a2, m2))))
|C (C (m1, m2), C (m3, m4)) -> (((check (m1) && check (m2)) && check (m3)) && check (m4))
|C (C (m1, m2), P (a, m)) -> ((check (m1) && check (m2)) && check (P ((a, m))))
|C (P (a, m), C (m1, m2)) -> ((check (P ((a, m))) && check (m1)) && check (m2)))

-----------------------------
result
-----------------------------
type partial =
|SECONDHALF
|FIRSTHALF

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check lambda  = 
 (match lambda with 
|V _ -> false
|P (a, V s) -> if (a = s) then true
 else false
|P (a, P (a2, C (m1, m2))) -> (((check (P ((a2, C ((m1, m2))))) || (check (P ((a, m1))) && check (P ((a2, m2))))) || (check (P ((a, m2))) && true)) || (check (P ((a, m1))) && check (P ((a, m2)))))
|P (a, P (a2, m)) -> ((check (m) || check (P ((a2, m)))) || check (P ((a, m))))
|P (a, C (m1, m2)) -> (check (P ((a, m1))) && check (P ((a, m2))))
|C (V _, _) -> false
|C (_, V _) -> false
|C (P (a1, m1), P (a2, m2)) -> (check (P ((a1, m1))) && check (P ((a2, m2))))
|C (C (m1, m2), C (m3, m4)) -> (((check (m1) && check (m2)) && check (m3)) && check (m4))
|C (C (m1, m2), P (a, m)) -> ((check (m1) && check (m2)) && check (P ((a, m))))
|C (P (a, m), C (m1, m2)) -> ((check (P ((a, m))) && check (m1)) && check (m2)))

Total time :0.155128
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/12/sub20.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------
type partial =
|SECONDHALF
|FIRSTHALF

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check lambda  = 
 (match lambda with 
|V _ -> false
|P (a, V s) -> if (a = s) then true
 else false
|P (a, P (a2, C (m1, m2))) -> (((check (P ((a2, C ((m1, m2))))) || (check (P ((a, m1))) && check (P ((a2, m2))))) || (check (P ((a, m2))) && check (P ((a2, m1))))) || (check (P ((a, m1))) && check (P ((a, m2)))))
|P (a, P (a2, m)) -> ((check (m) || check (P ((a2, m)))) || check (P ((a, m))))
|P (a, C (m1, m2)) -> (check (P ((a, m1))) && check (P ((a, m2))))
|C (V _, _) -> false
|C (_, V _) -> false
|C (P (a1, m1), P (a2, m2)) -> (check (P ((a1, m1))) && check (P ((a2, m2))))
|C (C (m1, m2), C (m3, m4)) -> (((check (m1) && check (m2)) && check (m3)) && check (m4))
|C (C (m1, m2), P (a, m)) -> ((check (m1) && check (m2)) && check (P ((a, m))))
|C (P (a, m), C (m1, m2)) -> ((check (P ((a, m))) && check (m1)) && check (m2)))

-----------------------------
result
-----------------------------
type partial =
|SECONDHALF
|FIRSTHALF

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check lambda  = 
 (match lambda with 
|V _ -> false
|P (a, V s) -> if (a = s) then true
 else false
|P (a, P (a2, C (m1, m2))) -> (((check (P ((a2, C ((m1, m2))))) || (check (P ((a, m1))) && check (P ((a2, m2))))) || (check (P ((a, m2))) && true)) || (check (P ((a, m1))) && check (P ((a, m2)))))
|P (a, P (a2, m)) -> ((check (m) || check (P ((a2, m)))) || check (P ((a, m))))
|P (a, C (m1, m2)) -> (check (P ((a, m1))) && check (P ((a, m2))))
|C (V _, _) -> false
|C (_, V _) -> false
|C (P (a1, m1), P (a2, m2)) -> (check (P ((a1, m1))) && check (P ((a2, m2))))
|C (C (m1, m2), C (m3, m4)) -> (((check (m1) && check (m2)) && check (m3)) && check (m4))
|C (C (m1, m2), P (a, m)) -> ((check (m1) && check (m2)) && check (P ((a, m))))
|C (P (a, m), C (m1, m2)) -> ((check (P ((a, m))) && check (m1)) && check (m2)))

Total time :0.153051
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/12/sub31.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check m  = 
let rec checkElementInList (elem, lst)  = 
 (match lst with 
|hd::tl -> if (elem = hd) then true
 else checkElementInList ((elem, tl))
|[] -> false)
 in 

let rec subset inner_list outer_list  = 
 (match inner_list with 
|hd::tl -> if checkElementInList ((hd, outer_list)) then subset (tl) (outer_list)
 else false
|[] -> true)
 in 

let rec makeAreaList m_eq a_lst  = 
 (match m_eq with 
|V x -> a_lst
|P (x, y) -> makeAreaList (y) ((x :: a_lst))
|C (x, y) -> (makeAreaList (x) (a_lst) @ makeAreaList (y) ([])))
 in 

let rec makeStationList m_eq s_lst  = 
 (match m_eq with 
|V x -> (x :: s_lst)
|P (x, y) -> makeStationList (y) (s_lst)
|C (x, y) -> (makeStationList (x) (s_lst) @ makeStationList (y) ([])))
 in 
subset (makeStationList (m) ([])) (makeAreaList (m) ([]))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/12/sub43.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check lst var lambda  = 
let mklst lst x  = (x :: lst)
 in 

 (match lambda with 
|V n -> if __list_mem__ (n) (lst) then true
 else false
|P (n, m) -> (check (mklst (lst) (n)) (var) (m) || check (mklst (lst) (n)) (n) (m))
|C (m1, m2) -> (check (lst) (var) (m1) && check (lst) (var) (m2)))

let check lambda  = 
 (match lambda with 
|V n -> false
|P (n, m) -> check ([n]) (n) (m)
|C (m1, m2) -> false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/12/sub48.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec checklist (arlist, stlist)  = 
let rec checkst (arlst, st)  = 
 (match (arlst, st) with 
|([], _) -> false
|(a::b, c) -> if (a = c) then true
 else checkst ((b, c)))
 in 

 (match (arlist, stlist) with 
|(_, []) -> true
|(a, b::c) -> if checkst ((a, b)) then checklist ((a, c))
 else false)

let rec check (met : lambda)  = 
let rec makestlist (me : lambda)  = 
 (match me with 
|V a -> (a :: [])
|P (a, b) -> makestlist (b)
|C (a, b) -> (makestlist (a) @ makestlist (b)))
 in 

let rec makearlist (me : lambda)  = 
 (match me with 
|P (a, b) -> (a :: makearlist (b))
|C (a, b) -> 
 (match (a, b) with 
|(V c, V d) -> []
|(V c, P (d, e)) -> (d :: makearlist (e))
|(V c, C _) -> makearlist (b)
|(P (c, d), V e) -> (c :: makearlist (d))
|(P (c, d), P (e, f)) -> ((c :: (e :: makearlist (d))) @ makearlist (f))
|(P (c, d), C _) -> ((c :: makearlist (d)) @ makearlist (b))
|(C _, V c) -> makearlist (a)
|(C _, P (c, d)) -> (makearlist (a) @ (c :: makearlist (d)))
|(C _, C _) -> (makearlist (a) @ makearlist (b)))
|_ -> [])
 in 

 (match met with 
|P (a, b) -> checklist (((a :: makearlist (b)), makestlist (b)))
|C (a, b) -> (check (a) && check (b))
|_ -> false)

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec checklist (arlist, stlist)  = 
let rec checkst (arlst, st)  = 
 (match (arlst, st) with 
|([], _) -> false
|(a::b, c) -> if (a = c) then true
 else checkst ((b, c)))
 in 

 (match (arlist, stlist) with 
|(_, []) -> true
|(a, b::c) -> if checkst ((a, b)) then checklist ((a, c))
 else false)

let rec check (met : lambda)  = 
let rec makestlist (me : lambda)  = 
 (match me with 
|V a -> (a :: [])
|P (a, b) -> makestlist (b)
|C (a, b) -> (makestlist (a) @ makestlist (b)))
 in 

let rec makearlist (me : lambda)  = 
 (match me with 
|P (a, b) -> (a :: makearlist (b))
|C (a, b) -> 
 (match (a, b) with 
|(V c, V d) -> []
|(V c, P (d, e)) -> if (d = c) then []
 else makestlist (met)
|(V c, C _) -> makearlist (b)
|(P (c, d), V e) -> (c :: makearlist (d))
|(P (c, d), P (e, f)) -> ((c :: (e :: makearlist (d))) @ makearlist (f))
|(P (c, d), C _) -> ((c :: makearlist (d)) @ makearlist (b))
|(C _, V c) -> makearlist (a)
|(C _, P (c, d)) -> (makearlist (a) @ (c :: makearlist (d)))
|(C _, C _) -> (makearlist (a) @ makearlist (b)))
|_ -> [])
 in 

 (match met with 
|P (a, b) -> checklist (((a :: makearlist (b)), makestlist (b)))
|C (a, b) -> (check (a) && check (b))
|_ -> false)

Total time :12.397035
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/12/sub8.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check mat  = 
let rec checkStringInList (li, st)  = 
 (match li with 
|[] -> false
|a::remain -> if (st = a) then true
 else checkStringInList ((remain, st)))
 in 

let rec checkStationInArea (listOfArea, subMat)  = 
 (match subMat with 
|V s -> checkStringInList ((listOfArea, s))
|C (m1, m2) -> (checkStationInArea ((listOfArea, m1)) && checkStationInArea ((listOfArea, m2)))
|P (a, m) -> 
let newlist  = (a :: listOfArea)
 in 
checkStationInArea ((newlist, m)))
 in 

 (match mat with 
|V s -> false
|C (m1, m2) -> false
|P (a, m) -> checkStationInArea (([a], m)))

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check mat  = 
let rec checkStringInList (li, st)  = 
 (match li with 
|[] -> false
|a::remain -> if (st = a) then true
 else checkStringInList ((remain, st)))
 in 

let rec checkStationInArea (listOfArea, subMat)  = 
 (match subMat with 
|V s -> checkStringInList ((listOfArea, s))
|C (m1, m2) -> (checkStationInArea ((listOfArea, m1)) && checkStationInArea ((listOfArea, m2)))
|P (a, m) -> 
let newlist  = (a :: listOfArea)
 in 
checkStationInArea ((newlist, m)))
 in 

 (match mat with 
|V s -> false
|C (m1, m2) -> checkStationInArea (([], C ((m2, m1))))
|P (a, m) -> checkStationInArea (([a], m)))

Total time :0.511474
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/13/sub10.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec list_station ipt  = 
 (match ipt with 
|V a -> (a :: [])
|P (a, m) -> list_station (m)
|C (m1, m2) -> (list_station (m1) @ list_station (m2)))

let rec list_area ipt  = 
 (match ipt with 
|V a -> []
|P (a, m) -> (a :: list_area (m))
|C (m1, m2) -> (list_area (m1) @ list_area (m2)))

let rec list_matching (ipt1, ipt2)  = 
 (match ipt1 with 
|[] -> true
|_ -> if __list_mem__ (__list_hd__ (ipt1)) (ipt2) then list_matching ((__list_tl__ (ipt1), ipt2))
 else false)

let check ipt  = if (list_matching ((list_station (ipt), list_area (ipt))) && list_matching ((list_area (ipt), list_station (ipt)))) then true
 else false

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/13/sub2.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check (m : lambda)  : bool = 
let rec checkRec (m : lambda) (s : var list)  : bool = 
 (match m with 
|V n -> __list_mem__ (n) (s)
|P (n, m) -> checkRec (m) (s)
|C (m1, m2) -> (checkRec (m1) (s) && checkRec (m2) (s)))
 in 
checkRec (m) ([])

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check (m : lambda)  : bool = 
let rec checkRec (m : lambda) (s : var list)  : bool = 
 (match m with 
|V n -> __list_mem__ (n) (s)
|P (n, m) -> checkRec (m) ((n :: s))
|C (m1, m2) -> (checkRec (m1) (s) && checkRec (m2) (s)))
 in 
checkRec (m) ([])

Total time :0.071728
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/13/sub29.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------
type var = string
type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var

let rec apl (b, m)  = 
 (match (b, m) with 
|(b, V a) -> if (b = a) then P ((b, V (a)))
 else V (a)
|(b, P (a, V c)) -> if ((a != c) && (b = c)) then P ((b, V (c)))
 else P ((a, V (c)))
|(b, P (a, P (c, d))) -> P ((a, P ((c, apl ((b, d))))))
|(b, P (a, C (c, d))) -> P ((a, apl ((b, C ((c, d))))))
|(b, C (a, c)) -> C ((apl ((b, a)), apl ((b, c)))))

let rec check m  = 
 (match m with 
|P (a, V b) -> if (a = b) then true
 else false
|P (a, C (b, c)) -> (check (P ((a, b))) && check (P ((a, c))))
|P (a, P (b, V c)) -> (check (P ((a, V (c)))) || check (P ((b, V (c)))))
|P (a, P (b, c)) -> (check (apl ((b, P ((a, c))))) || check (apl ((a, P ((b, c))))))
|_ -> false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/13/sub30.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------
type var = string
type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var

let rec apl (b, m)  = 
 (match (b, m) with 
|(b, V a) -> if (b = a) then P ((b, V (a)))
 else V (a)
|(b, P (a, V c)) -> if ((a != c) && (b = c)) then P ((b, V (c)))
 else P ((a, V (c)))
|(b, P (a, P (c, d))) -> P ((a, P ((c, apl ((b, d))))))
|(b, P (a, C (c, d))) -> P ((a, apl ((b, C ((c, d))))))
|(b, C (a, c)) -> C ((apl ((b, a)), apl ((b, c)))))

let rec check m  = 
 (match m with 
|P (a, V b) -> if (a = b) then true
 else false
|P (a, C (b, c)) -> (check (P ((a, b))) && check (P ((a, c))))
|P (a, P (b, V c)) -> (check (P ((a, V (c)))) || check (P ((b, V (c)))))
|P (a, P (b, c)) -> (check (apl ((b, P ((a, c))))) || check (apl ((a, P ((b, c))))))
|C (a, b) -> (check (a) && check (b))
|_ -> false)

-----------------------------
result
-----------------------------
type var = string
type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var

let rec apl (b, m)  = 
 (match (b, m) with 
|(b, V a) -> if (b = a) then P ((b, V (a)))
 else V (a)
|(b, P (a, V c)) -> if ((a != c) && (b = c)) then P ((b, V (c)))
 else P ((a, V (c)))
|(b, P (a, P (c, d))) -> P ((a, P ((b, d))))
|(b, P (a, C (c, d))) -> P ((a, apl ((b, C ((c, d))))))
|(b, C (a, c)) -> C ((apl ((b, a)), apl ((b, c)))))

let rec check m  = 
 (match m with 
|P (a, V b) -> if (a = b) then true
 else false
|P (a, C (b, c)) -> (check (P ((a, b))) && check (P ((a, c))))
|P (a, P (b, V c)) -> (check (P ((a, V (c)))) || check (P ((b, V (c)))))
|P (a, P (b, c)) -> (check (apl ((b, P ((a, c))))) || check (apl ((a, P ((b, c))))))
|C (a, b) -> (check (a) && check (b))
|_ -> false)

Total time :4.455035
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/13/sub47.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec checkArea n e  = 
 (match e with 
|P (a, b) -> checkArea ((n @ [a])) (b)
|C (a, b) -> (checkArea (n) (a) && checkArea (n) (b))
|V a -> __list_exists__ (
fun x -> (x = a)) (n))

let rec check e  = 
 (match e with 
|P (a, b) -> checkArea ([a]) (b)
|C (a, b) -> (check (a) && check (b))
|V n -> true)

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec checkArea n e  = 
 (match e with 
|P (a, b) -> checkArea ((n @ [a])) (b)
|C (a, b) -> (checkArea (n) (a) && checkArea (n) (b))
|V a -> __list_exists__ (
fun x -> (x = a)) (n))

let rec check e  = 
 (match e with 
|P (a, b) -> checkArea ([a]) (b)
|C (a, b) -> (check (a) && check (b))
|V n -> false)

Total time :0.022911
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/13/sub54.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check (m, l)  = 
 (match m with 
|P (nam, met) -> check ((met, (nam :: l)))
|V nam -> 
let x  = __list_find__ (
fun elem -> (elem = nam)) (l)
 in 
true
|C (met1, met2) -> (check ((met1, l)) && check ((met2, l))))

let check m  = check ((m, []))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/13/sub55.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec checking mtr arealst  = 
 (match mtr with 
|V n -> if (__list_mem__ (n) (arealst) = true) then true
 else false
|C (m, n) -> (checking (m) (arealst) && checking (n) (arealst))
|P (n, m) -> checking (m) ((n :: arealst)))

let check mtr  = 
 (match mtr with 
|V n -> false
|C (m, n) -> false
|P (n, m) -> checking (mtr) ([]))

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec checking mtr arealst  = 
 (match mtr with 
|V n -> if (__list_mem__ (n) (arealst) = true) then true
 else false
|C (m, n) -> (checking (m) (arealst) && checking (n) (arealst))
|P (n, m) -> checking (m) ((n :: arealst)))

let check mtr  = 
 (match mtr with 
|V n -> false
|C (m, n) -> checking (C ((n, m))) ([])
|P (n, m) -> checking (mtr) ([]))

Total time :1.271359
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/13/sub58.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let addToList lst newInlst  = (newInlst :: lst)

let rec check_sub prevAreaName lambda  = 
 (match lambda with 
|V stationName -> __list_mem__ (stationName) (prevAreaName)
|P (areaName, nextMetro) -> check_sub ((areaName :: prevAreaName)) (nextMetro)
|C (lambdaA, lambdaB) -> (check_sub (prevAreaName) (lambdaA) && check_sub (prevAreaName) (lambdaB)))

let rec check inpt  = 
 (match inpt with 
|V var -> true
|P (var, lambda) -> check_sub ((var :: [])) (lambda)
|C (lambdaA, lambdaB) -> (check (lambdaA) && check (lambdaB)))

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let addToList lst newInlst  = (newInlst :: lst)

let rec check_sub prevAreaName lambda  = 
 (match lambda with 
|V stationName -> __list_mem__ (stationName) (prevAreaName)
|P (areaName, nextMetro) -> check_sub ((areaName :: prevAreaName)) (nextMetro)
|C (lambdaA, lambdaB) -> (check_sub (prevAreaName) (lambdaA) && check_sub (prevAreaName) (lambdaB)))

let rec check inpt  = 
 (match inpt with 
|V var -> false
|P (var, lambda) -> check_sub ((var :: [])) (lambda)
|C (lambdaA, lambdaB) -> (check (lambdaA) && check (lambdaB)))

Total time :0.023465
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/13/sub64.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check met  = 
 (match met with 
|V n -> false
|P (n, metr) -> (idSearch ((n, idList (metr))) || check (metr))
|C (metr1, metr2) -> (check (metr1) && check (metr2)))
and idList met  = 
 (match met with 
|V n -> (n :: [])
|P (n, metr) -> idList (metr)
|C (metr1, metr2) -> (idList (metr1) @ idList (metr2)))
and idSearch (id, l)  = 
 (match l with 
|[] -> false
|head::tail -> if (head = id) then true
 else idSearch ((id, tail)))

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check met  = 
 (match met with 
|V n -> false
|P (n, metr) -> (idSearch ((n, idList (metr))) || check (metr))
|C (metr1, metr2) -> (check (metr1) && check (metr2)))
and idList met  = 
 (match met with 
|V n -> (n :: [])
|P (n, metr) -> idList (metr)
|C (metr1, metr2) -> (idList (if check (metr2) then metr1
 else metr2) @ idList (metr2)))
and idSearch (id, l)  = 
 (match l with 
|[] -> false
|head::tail -> if (head = id) then true
 else idSearch ((id, tail)))

Total time :9.420782
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/13/sub66.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec deletecity (var, lis)  = if (var = __list_hd__ (lis)) then if (__list_length__ (lis) = 1) then []
 else deletecity ((var, __list_tl__ (lis)))
 else if (__list_length__ (lis) = 1) then lis
 else (__list_hd__ (lis) :: deletecity ((var, __list_tl__ (lis))))

let rec findcity met  = 
 (match met with 
|V var -> (var :: [])
|P (var, lambda) -> deletecity ((var, findcity (lambda)))
|C (met1, met2) -> __list_rev_append__ (findcity (met1)) (findcity (met2)))

let deletestation (var, lambda)  = 
let citylist  = findcity (lambda)
 in 
if (deletecity ((var, citylist)) = []) then true
 else false

let rec check met  = 
 (match met with 
|V var -> false
|P (var, lambda) -> if check (lambda) then true
 else deletestation ((var, lambda))
|C (met1, met2) -> (check (met1) && check (met2)))

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec deletecity (var, lis)  = if (var = __list_hd__ (lis)) then if (__list_length__ (lis) = 1) then []
 else deletecity ((var, __list_tl__ (lis)))
 else if (__list_length__ (lis) = 1) then lis
 else (__list_hd__ (lis) :: deletecity ((var, __list_tl__ (lis))))

let rec findcity met  = 
 (match met with 
|V var -> (var :: [])
|P (var, lambda) -> deletecity ((var, (var :: findcity (lambda))))
|C (met1, met2) -> __list_rev_append__ (findcity (met1)) (findcity (met2)))

let deletestation (var, lambda)  = 
let citylist  = findcity (lambda)
 in 
if (deletecity ((var, citylist)) = []) then true
 else false

let rec check met  = 
 (match met with 
|V var -> false
|P (var, lambda) -> if check (lambda) then true
 else deletestation ((var, lambda))
|C (met1, met2) -> (check (met1) && check (met2)))

Total time :0.55313
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/13/sub67.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec dec met lst  = 
 (match met with 
|V a -> if (__list_mem__ (a) (lst) = true) then true
 else false
|C (m1, m2) -> (dec (m1) (lst) && dec (m1) (lst))
|P (n1, m1) -> dec (m1) ((n1 :: lst)))

let rec check m  = 
 (match m with 
|V a -> false
|P (n1, m1) -> dec (m) ((n1 :: []))
|C (m1, m2) -> (dec (m1) ([]) && dec (m2) ([])))

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec dec met lst  = 
 (match met with 
|V a -> if (__list_mem__ (a) (lst) = true) then true
 else false
|C (m1, m2) -> (dec (m2) (lst) && dec (m1) (lst))
|P (n1, m1) -> dec (m1) ((n1 :: lst)))

let rec check m  = 
 (match m with 
|V a -> false
|P (n1, m1) -> dec (m) ((n1 :: []))
|C (m1, m2) -> (dec (m1) ([]) && dec (m2) ([])))

Total time :0.047958
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/14/sub34.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

exception TODO

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check (m : lambda)  : bool = 
 (match m with 
|P (id, y) -> if check (y) then true
 else 
 (match y with 
|V s -> (s = id)
|P (a, metr) -> 
 (match metr with 
|C (m1, m2) -> ((check (P ((a, m1))) || check (P ((id, m1)))) && (check (P ((a, m2))) || check (P ((id, m2)))))
|_ -> (check (P ((id, metr))) || check (P ((a, metr)))))
|C (m1, m2) -> (check (P ((id, m1))) && check (P ((id, m2)))))
|C (m1, m2) -> (check (m1) && check (m2))
|_ -> false)

-----------------------------
result
-----------------------------

exception TODO

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check (m : lambda)  : bool = 
 (match m with 
|P (id, y) -> if check (y) then true
 else 
 (match y with 
|V s -> (s = id)
|P (a, metr) -> 
 (match metr with 
|C (m1, m2) -> (true && (check (P ((a, m2))) || check (P ((id, m2)))))
|_ -> (check (P ((id, metr))) || check (P ((a, metr)))))
|C (m1, m2) -> (check (P ((id, m1))) && check (P ((id, m2)))))
|C (m1, m2) -> (check (m1) && check (m2))
|_ -> false)

Total time :0.073176
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/14/sub40.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun met -> 
let rec stationvar  : (lambda -> var list) = 
fun f -> 
 (match f with 
|P (a, b) -> stationvar (b)
|V a -> [a]
|C (a, b) -> __list_append__ (stationvar (a)) (stationvar (b)))
 in 

let rec areavar  : (lambda -> var list) = 
fun f -> 
 (match f with 
|P (a, b) -> __list_append__ ([a]) (areavar (b))
|C (a, b) -> __list_append__ (areavar (a)) (areavar (b))
|V a -> [])
 in 

let rec haveit  : (var list -> (var list -> bool)) = 
fun a b -> 
let predicate  : (var -> bool) = 
fun f -> __list_mem__ (f) (b)
 in 
__list_for_all__ (predicate) (a)
 in 

 (match met with 
|P (a, b) -> haveit (stationvar (b)) (areavar (met))
|C (a, b) -> (check (a) && check (b))
|V a -> false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/14/sub66.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec contains listOfArea s  = 
 (match listOfArea with 
|[] -> false
|h::t -> if (h = s) then true
 else contains (t) (s))

let rec check2 x listOfArea  = 
 (match x with 
|V s -> contains (listOfArea) (s)
|P (n, m) -> check2 (m) ((n :: listOfArea))
|C (m1, m2) -> (check2 (m1) (listOfArea) && check2 (m2) (listOfArea)))

let check x  = 
 (match x with 
|V s -> true
|_ -> check2 (x) ([]))

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec contains listOfArea s  = 
 (match listOfArea with 
|[] -> false
|h::t -> if (h = s) then true
 else contains (t) (s))

let rec check2 x listOfArea  = 
 (match x with 
|V s -> contains (listOfArea) (s)
|P (n, m) -> check2 (m) ((n :: listOfArea))
|C (m1, m2) -> (check2 (m1) (listOfArea) && check2 (m2) (listOfArea)))

let check x  = 
 (match x with 
|V s -> false
|_ -> check2 (x) ([]))

Total time :0.019431
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/15/sub29.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec checkSt_in_Metro (var, lambda)  = 
 (match lambda with 
|V nm -> if (nm = var) then true
 else false
|P (nm, met) -> checkSt_in_Metro ((var, met))
|C (met1, met2) -> (checkSt_in_Metro ((var, met1)) || checkSt_in_Metro ((var, met2))))

let rec makeMetro_wo_St (var, lambda)  = 
 (match lambda with 
|V nm -> if (nm = var) then V ("X")
 else V (nm)
|P (nm, met) -> P ((nm, makeMetro_wo_St ((var, met))))
|C (met1, met2) -> C ((makeMetro_wo_St ((var, met1)), makeMetro_wo_St ((var, met2)))))

let rec check m  = 
 (match m with 
|V var -> if (var = "X") then true
 else false
|P (var, lambda) -> if checkSt_in_Metro ((var, lambda)) then check (makeMetro_wo_St ((var, lambda)))
 else check (lambda)
|C (lambda1, lambda2) -> (check (lambda1) && check (lambda2)))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/15/sub31.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check  : (lambda -> bool) = 
fun met -> 
let rec checkIn  : ((lambda * var list) -> bool) = 
fun (lambda, stationlist) -> 
 (match lambda with 
|V stationstr -> if __list_mem__ (stationstr) (stationlist) then true
 else false
|P (areastr, metin) -> checkIn ((metin, (stationlist @ [areastr])))
|C (metin1, metin2) -> (checkIn ((metin1, stationlist)) && checkIn ((metin2, stationlist))))
 in 

 (match met with 
|V varstr -> true
|_ -> checkIn ((met, [])))

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check  : (lambda -> bool) = 
fun met -> 
let rec checkIn  : ((lambda * var list) -> bool) = 
fun (lambda, stationlist) -> 
 (match lambda with 
|V stationstr -> if __list_mem__ (stationstr) (stationlist) then true
 else false
|P (areastr, metin) -> checkIn ((metin, (stationlist @ [areastr])))
|C (metin1, metin2) -> (checkIn ((metin1, stationlist)) && checkIn ((metin2, stationlist))))
 in 

 (match met with 
|V varstr -> false
|_ -> checkIn ((met, [])))

Total time :0.021348
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/15/sub54.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec findStation  : (lambda -> string list) = 
fun x -> 
 (match x with 
|V station -> [station]
|C (a, b) -> (findStation (a) @ findStation (b))
|P (area, next) -> findStation (next))

let rec exclude  : (lambda -> (string list -> bool)) = 
fun m strl -> 
 (match strl with 
|[] -> true
|_ -> 
 (match m with 
|V sta -> false
|P (area, next) -> if __list_mem__ (area) (strl) then exclude (next) (__list_filter__ (
fun x -> (x != area)) (strl))
 else exclude (next) (strl)
|C (V sta, con2) -> exclude (con2) (strl)
|C (con1, V sta) -> exclude (con1) (strl)
|C (con1, con2) -> (exclude (con1) (findStation (con1)) && exclude (con2) (findStation (con2)))))

let rec check  : (lambda -> bool) = 
fun x -> exclude (x) (findStation (x))

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec findStation  : (lambda -> string list) = 
fun x -> 
 (match x with 
|V station -> [station]
|C (a, b) -> (findStation (a) @ findStation (b))
|P (area, next) -> findStation (next))

let rec exclude  : (lambda -> (string list -> bool)) = 
fun m strl -> 
 (match strl with 
|[] -> true
|_ -> 
 (match m with 
|V sta -> false
|P (area, next) -> if __list_mem__ (area) (strl) then exclude (next) (__list_filter__ (
fun x -> (x != area)) (strl))
 else exclude (next) (strl)
|C (V sta, con2) -> exclude (if (strl = findStation (con2)) then con2
 else V (sta)) (strl)
|C (con1, V sta) -> exclude (con1) (strl)
|C (con1, con2) -> (exclude (con1) (findStation (con1)) && exclude (con2) (findStation (con2)))))

let rec check  : (lambda -> bool) = 
fun x -> exclude (x) (findStation (x))

Total time :11.28018
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/15/sub7.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec station_list x  = 
 (match x with 
|V n -> [n]
|P (n, m) -> station_list (m)
|C (m1, m2) -> __list_append__ (station_list (m1)) (station_list (m2)))

let rec check (x : lambda)  : bool = 
 (match x with 
|V n -> false
|P (n, m) -> __list_mem__ (n) (station_list (m))
|C (m1, m2) -> false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/15/sub74.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let isStringExist e l  = 
let x  = __list_find__ (
fun x -> (x = e)) (l)
 in 
true

let check lambda  = 
let rec checkWithArea areaList lambda  = 
 (match lambda with 
|V var -> isStringExist (var) (areaList)
|P (var, lambda) -> checkWithArea ((areaList @ [var])) (lambda)
|C (m1, m2) -> (checkWithArea (areaList) (m1) && checkWithArea (areaList) (m2)))
 in 
checkWithArea ([]) (lambda)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/15/sub75.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let isStringExist e l  = 
let x  = __list_find__ (
fun x -> (x = e)) (l)
 in 
true

let check lambda  = 
let rec checkWithArea areaList lambda  = 
 (match lambda with 
|V var -> isStringExist (var) (areaList)
|P (var, lambda) -> checkWithArea ((areaList @ [var])) (lambda)
|C (m1, m2) -> (checkWithArea (areaList) (m1) && checkWithArea (areaList) (m2)))
 in 
checkWithArea ([]) (lambda)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/15/sub8.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec station_list x  = 
 (match x with 
|V n -> [n]
|P (n, m) -> station_list (m)
|C (m1, m2) -> __list_append__ (station_list (m1)) (station_list (m2)))

let rec check (x : lambda)  : bool = 
 (match x with 
|V n -> false
|P (n, m) -> __list_mem__ (n) (station_list (m))
|C (m1, m2) -> (check (m1) && check (m2)))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/15/sub86.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun a -> 
 (match a with 
|V q -> false
|P (q, p) -> 
 (match p with 
|V x -> if (q = x) then true
 else false
|P (x, y) -> 
 (match y with 
|P (a, b) -> ((check (P ((a, b))) || check (P ((x, b)))) || check (P ((q, b))))
|V a -> ((a = x) || (a = q))
|C (a, b) -> 
 (match (a, b) with 
|(V a, V b) -> (((a = q) || (a = x)) && ((b = q) || (b = x)))
|(V a, P (c, d)) -> (((a = q) || (a = x)) && ((check (P ((c, d))) || check (P ((x, d)))) || check (P ((q, d)))))
|(P (a, b), V c) -> (((check (P ((a, b))) || check (P ((x, b)))) || check (P ((q, b)))) && ((c = q) || (c = x)))
|(P (a, b), P (c, d)) -> (((check (P ((a, b))) || check (P ((x, b)))) || check (P ((q, b)))) && ((check (P ((c, d))) || check (P ((x, d)))) || check (P ((q, d)))))
|(_, _) -> (check (a) && check (b))))
|C (x, y) -> 
 (match (x, y) with 
|(V a, V b) -> ((a = q) && (b = q))
|(V a, P (c, d)) -> ((a = q) && (check (P ((c, d))) || check (P ((q, d)))))
|(P (a, b), V c) -> ((check (P ((a, b))) || check (P ((q, b)))) && (c = q))
|(P (a, b), P (c, d)) -> ((check (P ((a, b))) || check (P ((q, b)))) && (check (P ((c, d))) || check (P ((q, d)))))
|(_, _) -> (check (x) && check (y))))
|C (q, p) -> (check (q) && check (p)))

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun a -> 
 (match a with 
|V q -> false
|P (q, p) -> 
 (match p with 
|V x -> if (q = x) then true
 else false
|P (x, y) -> 
 (match y with 
|P (a, b) -> ((check (P ((a, b))) || check (P ((x, b)))) || check (P ((q, b))))
|V a -> ((a = x) || (a = q))
|C (a, b) -> 
 (match (a, b) with 
|(V a, V b) -> (((a = q) || (a = x)) && ((b = q) || (b = x)))
|(V a, P (c, d)) -> (((a = q) || (a = x)) && ((check (P ((c, d))) || check (P ((x, d)))) || check (P ((q, d)))))
|(P (a, b), V c) -> (((check (P ((a, b))) || check (P ((x, b)))) || check (P ((q, b)))) && ((c = q) || (c = x)))
|(P (a, b), P (c, d)) -> (((check (P ((a, b))) || check (P ((x, b)))) || check (P ((q, b)))) && ((check (P ((c, d))) || check (P ((x, d)))) || check (P ((q, d)))))
|(_, _) -> (check (a) && check (b))))
|C (x, y) -> 
 (match (x, y) with 
|(V a, V b) -> true
|(V a, P (c, d)) -> ((a = q) && (check (P ((c, d))) || check (P ((q, d)))))
|(P (a, b), V c) -> ((check (P ((a, b))) || check (P ((q, b)))) && (c = q))
|(P (a, b), P (c, d)) -> ((check (P ((a, b))) || check (P ((q, b)))) && (check (P ((c, d))) || check (P ((q, d)))))
|(_, _) -> (check (x) && check (y))))
|C (q, p) -> (check (q) && check (p)))

Total time :0.112727
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/17/sub140.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun m -> 
 (match m with 
|V _ -> false
|C _ -> false
|P (n', m') -> __list_mem__ (n') (listMetro (m')))
and listMetro  : (lambda -> a list) = 
fun m -> 
 (match m with 
|V m' -> [m']
|C (m1, m2) -> 
 (match (listMetro (m1), listMetro (m2)) with 
|(a::b, c::d) -> __list_append__ ((a :: b)) ((c :: d))
|(_, _) -> [])
|P (n', m') -> 
 (match check (m) with 
|true -> listMetro (m')
|false -> []))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/17/sub30.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V s -> false
|P (n, m) -> 
 (match m with 
|V s -> if (n = s) then true
 else false
|P (n, m) -> check (P ((n, m)))
|C (m1, m2) -> (check (P ((n, m1))) || check (P ((n, m2)))))
|C (m1, m2) -> false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/17/sub46.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V _ -> false
|P (a, b) -> true
|C (a, b) -> true)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/17/sub6.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec isInclude  : ((var * lambda) -> bool) = 
fun (n, m) -> 
 (match m with 
|V a -> (n = a)
|P (a, b) -> (isInclude ((a, b)) && isInclude ((n, b)))
|C (a, b) -> (isInclude ((n, a)) || isInclude ((n, b))))

let check  : (lambda -> bool) = 
fun x -> 
 (match x with 
|P (a, V b) -> (a = b)
|P (a, b) -> isInclude ((a, b))
|_ -> false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/17/sub85.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check (m : lambda)  : bool = 
 (match m with 
|V n -> true
|C (m1, m2) -> (check (m1) && check (m2))
|P (n, m) -> 
 (match m with 
|V n2 -> if (n = n2) then true
 else false
|_ -> check (m)))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/17/sub87.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun x -> 
 (match x with 
|P (n, V n1) -> if (n1 = n) then true
 else false
|P (n, P (n1, m)) -> (check (P ((n, m))) && check (P ((n1, m))))
|P (n, C (V m1, V m2)) -> if ((n = m1) || (n = m2)) then true
 else false
|P (n, C (P (n1, m1), V n2)) -> if (((n = n2) || (n1 = n2)) && (check (P ((n, m1))) || check (P ((n1, m1))))) then true
 else false
|P (n, C (V n2, P (n1, m1))) -> if (((n = n2) || (n1 = n2)) && (check (P ((n, m1))) || check (P ((n1, m1))))) then true
 else false
|C (P (n1, m1), P (n2, m2)) -> if ((check (P ((n1, m1))) || check (P ((n2, m1)))) && (check (P ((n1, m2))) || check (P ((n2, m2))))) then true
 else false
|V n -> false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/17/sub89.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec matchid ((x : string), (l : string list))  : bool = 
 (match l with 
|[] -> false
|hd::tl -> if (hd = x) then true
 else matchid ((x, tl)))

let rec ckMetro ((m : lambda), (idl : string list))  : bool = 
 (match m with 
|V x -> matchid ((x, idl))
|P (id, V x) -> ckMetro ((V (x), (id :: idl)))
|P (id, some) -> ckMetro ((some, (id :: idl)))
|C (V x, V y) -> (matchid ((x, idl)) && matchid ((y, idl)))
|C (V x, some) -> if matchid ((x, idl)) then ckMetro ((some, idl))
 else false
|C (x, y) -> (ckMetro ((x, idl)) && ckMetro ((y, []))))

let rec check (m : lambda)  : bool = ckMetro ((m, []))

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec matchid ((x : string), (l : string list))  : bool = 
 (match l with 
|[] -> false
|hd::tl -> if (hd = x) then true
 else matchid ((x, tl)))

let rec ckMetro ((m : lambda), (idl : string list))  : bool = 
 (match m with 
|V x -> matchid ((x, idl))
|P (id, V x) -> ckMetro ((V (x), (id :: idl)))
|P (id, some) -> ckMetro ((some, (id :: idl)))
|C (V x, V y) -> (matchid ((x, idl)) && matchid ((y, idl)))
|C (V x, some) -> if matchid ((x, idl)) then ckMetro ((some, idl))
 else false
|C (x, y) -> (ckMetro ((x, idl)) && ckMetro ((y, idl))))

let rec check (m : lambda)  : bool = ckMetro ((m, []))

Total time :0.088965
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub14.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec envmt  : (lambda -> string list) = 
fun e -> 
let lst  = []
 in 

 (match e with 
|V v -> lst
|P (v, lambdar) -> ((v :: envmt (lambdar)) @ lst)
|C (lambda1, lambda2) -> (envmt (lambda1) @ (envmt (lambda2) @ lst)))

let rec exist  : ((lambda * string list) -> int) = 
fun (e, lst) -> 
 (match e with 
|V v -> 
 (match lst with 
|[] -> 0
|hd::tl -> if (hd = v) then (1 + exist ((e, tl)))
 else exist ((e, tl)))
|P (v, lambda1) -> exist ((lambda1, lst))
|C (lambda1, lambda2) -> (exist ((lambda1, lst)) + exist ((lambda2, lst))))

let check  : (lambda -> bool) = 
fun e -> 
let env  = envmt (e)
 in 
if (exist ((e, env)) = 0) then false
 else if (__list_length__ (env) > exist ((e, env))) then false
 else true

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub15.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec pcheck  : ((var list * lambda) -> bool) = 
fun (var, lambda) -> 
 (match lambda with 
|V evar -> __list_exists__ (
fun v -> (v = evar)) (var)
|P (v, lambda) -> pcheck (((v :: var), lambda))
|C (e1, e2) -> (pcheck ((var, e1)) && pcheck ((var, e2))))

let check  : (lambda -> bool) = 
fun e -> 
 (match e with 
|V v -> false
|P (v, lambda) -> pcheck (((v :: []), lambda))
|C (e1, e2) -> false)

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec pcheck  : ((var list * lambda) -> bool) = 
fun (var, lambda) -> 
 (match lambda with 
|V evar -> __list_exists__ (
fun v -> (v = evar)) (var)
|P (v, lambda) -> pcheck (((v :: var), lambda))
|C (e1, e2) -> (pcheck ((var, e1)) && pcheck ((var, e2))))

let check  : (lambda -> bool) = 
fun e -> 
 (match e with 
|V v -> false
|P (v, lambda) -> pcheck (((v :: []), lambda))
|C (e1, e2) -> pcheck (([], C ((e2, e1)))))

Total time :0.458231
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub16.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec look  : ((var * string list) -> bool) = 
fun (v, li) -> 
 (match li with 
|[] -> false
|h::t -> if (h = v) then true
 else look ((v, t)))

let rec add  : ((var * string list) -> string list) = 
fun (v, li) -> 
 (match li with 
|[] -> (li @ [v])
|h::t -> if (h = v) then li
 else ([h] @ add ((v, t))))

let rec collect1  : ((lambda * string list) -> string list) = 
fun (e, li) -> 
 (match e with 
|P (v, e1) -> collect1 ((e1, add ((v, li))))
|C (e1, e2) -> collect1 ((e2, collect1 ((e1, li))))
|V v1 -> li)

let rec collect2  : ((lambda * string list) -> string list) = 
fun (e, li) -> 
 (match e with 
|P (v, e1) -> collect2 ((e1, li))
|C (e1, e2) -> collect2 ((e2, collect2 ((e1, li))))
|V v1 -> add ((v1, li)))

let rec compare  : ((string list * string list) -> bool) = 
fun (li1, li2) -> 
 (match li2 with 
|[] -> true
|h::t -> (look ((h, li1)) && compare ((li1, t))))

let check  : (lambda -> bool) = 
fun e -> 
let li1  = collect1 ((e, []))
 in 

let li2  = collect2 ((e, []))
 in 
compare ((li1, li2))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub2.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec comblist  = 
fun (l1, l2) -> 
 (match l1 with 
|[] -> l2
|hd::tl -> (hd :: comblist ((tl, l2))))

let rec searchlist  : ((string * string list) -> bool) = 
fun (a, l) -> 
 (match l with 
|[] -> false
|hd::tl -> if (hd = a) then true
 else searchlist ((a, tl)))

let rec complist  : (string list -> string list) = 
fun l -> 
 (match l with 
|[] -> []
|hd::tl -> if searchlist ((hd, tl)) then complist (tl)
 else (hd :: tl))

let rec vars  : (lambda -> string list) = 
fun e -> 
 (match e with 
|V x -> [x]
|P (x, e1) -> vars (e1)
|C (e1, e2) -> comblist ((vars (e1), vars (e2))))

let rec used  : (lambda -> string list) = 
fun e -> 
 (match e with 
|V x -> []
|P (x, e1) -> (x :: used (e1))
|C (e1, e2) -> comblist ((used (e1), used (e2))))

let rec matchvar  : ((string list * string list) -> bool) = 
fun (vr, us) -> 
 (match (vr, us) with 
|([], _) -> true
|(hd::tl, us) -> if searchlist ((hd, us)) then matchvar ((tl, us))
 else false)

let check  : (lambda -> bool) = 
fun e -> matchvar ((complist (vars (e)), used (e)))

FixML fails to generate a patch
Error occurs : ../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub20.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases

../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub21.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec extract  : (lambda -> var list) = 
fun e -> 
 (match e with 
|V v -> []
|P (v1, e1) -> ([v1] @ extract (e1))
|C (e1, e2) -> (extract (e1) @ extract (e2)))

let rec search  : ((var * var list) -> bool) = 
fun (v, lst) -> 
 (match lst with 
|[] -> false
|head::[] -> if (v = head) then true
 else false
|head::tail -> if ((v = head) || search ((v, tail))) then true
 else false)

let rec check2  : ((lambda * var list) -> bool) = 
fun (e, a) -> 
 (match e with 
|V v1 -> search ((v1, a))
|P (v1, e1) -> check2 ((e1, a))
|C (e1, e2) -> (check2 ((e1, a)) && check2 ((e2, a))))

let check  : (lambda -> bool) = 
fun e -> check2 ((e, extract (e)))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub35.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check  : (lambda -> bool) = 
fun e -> true

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub37.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec chars  : (lambda -> var) = 
fun e -> 
 (match e with 
|V a -> a
|P (v, e1) -> 
 (match e1 with 
|V b -> b
|P (b, e2) -> chars (e2)
|C (e1, e2) -> chars (e2))
|C (e1, e2) -> 
 (match (e1, e2) with 
|(V b, V c) -> c
|(V b, P (c, e3)) -> chars (e3)))

let check  : (lambda -> bool) = 
fun e -> 
 (match e with 
|V a -> true
|P (v, e1) -> 
 (match e1 with 
|V b -> if (v = b) then true
 else false
|P (b, e2) -> if ((chars (e2) = v) || (chars (e2) = b)) then true
 else false
|C (e1, e2) -> if ((chars (e1) = v) || (chars (e2) = v)) then true
 else false)
|C (e1, e2) -> 
 (match (e1, e2) with 
|(V b, V c) -> true
|(V b, P (c, e3)) -> if ((c = b) || (b = chars (e3))) then true
 else false))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub38.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun e -> 
 (match e with 
|P (v, e) -> 
 (match e with 
|V a -> (v = a)
|P (a, b) -> check (e)
|C (a, b) -> (check (a) && check (b)))
|C (a, b) -> (check (a) && check (b))
|V a -> true
|_ -> false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub39.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec ptree  : ((var * lambda) -> bool) = 
fun (e1, e2) -> 
 (match e2 with 
|P (x, y) -> 
 (match y with 
|P (a, b) -> ((ptree ((a, b)) || ptree ((x, b))) || ptree ((e1, b)))
|C (a, b) -> ((ptree ((x, a)) || ptree ((x, b))) && (ptree ((e1, a)) || ptree ((e1, b))))
|V a -> (ptree ((x, y)) || ptree ((e1, y))))
|C (x, y) -> (ptree ((e1, x)) && ptree ((e1, y)))
|V x -> (e1 = x))

let rec ctree  : ((lambda * lambda) -> bool) = 
fun (e1, e2) -> 
 (match (e1, e2) with 
|(P (x1, y1), P (x2, y2)) -> (ptree ((x1, y1)) && ptree ((x2, y2)))
|(C (x1, y1), P (x2, y2)) -> (ctree ((x1, y1)) && ptree ((x2, y2)))
|(P (x1, y1), C (x2, y2)) -> (ptree ((x1, y1)) && ctree ((x2, y2)))
|(C (x1, y1), C (x2, y2)) -> (ctree ((x1, y1)) && ctree ((x2, y2)))
|(V x, _) -> false
|(_, V y) -> false)

let check  : (lambda -> bool) = 
fun e -> 
 (match e with 
|P (x, y) -> ptree ((x, y))
|C (x, y) -> ctree ((x, y))
|V x -> true)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub47.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec change  : ((var * lambda) -> lambda) = 
fun (v, e) -> 
 (match e with 
|V v' -> V (v')
|P (v', e') -> change ((v', e'))
|C (e1, e2) -> if (V (v) = e1) then if (V (v) = e2) then change ((v, e1))
 else change ((v, e2))
 else if (V (v) = e2) then change ((v, e1))
 else change ((v, V (v))))

let check  : (lambda -> bool) = 
fun e -> 
 (match e with 
|V v -> false
|P (v, e') -> if (V (v) = change ((v, e'))) then true
 else false
|C (e1, e2) -> false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub52.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check  : (lambda -> bool) = 
fun e -> true

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub53.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check_list (lambda, lst)  = 
 (match lambda with 
|V var -> if __list_mem__ (var) (lst) then true
 else false
|P (var, lambda) -> check_list ((lambda, (lst @ [var])))
|C (lambda1, lambda2) -> (check_list ((lambda2, lst)) && check_list ((lambda2, lst))))

let check  : (lambda -> bool) = 
fun e -> check_list ((e, []))

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check_list (lambda, lst)  = 
 (match lambda with 
|V var -> if __list_mem__ (var) (lst) then true
 else false
|P (var, lambda) -> check_list ((lambda, (lst @ [var])))
|C (lambda1, lambda2) -> (check_list ((lambda1, lst)) && check_list ((lambda2, lst))))

let check  : (lambda -> bool) = 
fun e -> check_list ((e, []))

Total time :0.045168
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub56.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec equi x l  = 
 (match l with 
|[] -> true
|hd::tl -> ((x = hd) && equi (x) (tl)))

let rec check_r  : (lambda -> (string list -> bool)) = 
fun e env -> 
 (match e with 
|V var -> if (env = []) then false
 else equi (var) (env)
|P (v, e) -> check_r (e) ((v :: env))
|C (e1, e2) -> (check_r (e1) (env) && check_r (e2) (env)))

let check  : (lambda -> bool) = 
fun e -> check_r (e) ([])

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub57.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun e -> checking ((e, makelist ((e, []))))
and makelist  : ((lambda * var list) -> var list) = 
fun (e, l) -> 
 (match (e, l) with 
|(V v, l) -> l
|(P (v, e), l) -> (v :: makelist ((e, l)))
|(C (e1, e2), l1) -> 
let l2  = makelist ((e1, l1))
 in 
makelist ((e2, l2)))
and checking  : ((lambda * var list) -> bool) = 
fun (e, l) -> 
 (match (e, l) with 
|(V v, l) -> findv ((v, l))
|(P (v, e), l) -> checking ((e, l))
|(C (e1, e2), l) -> (checking ((e1, l)) && checking ((e2, l))))
and findv  : ((var * var list) -> bool) = 
fun (v, l) -> 
 (match (v, l) with 
|(_, []) -> false
|(v, hd::tl) -> if (hd = v) then true
 else findv ((v, tl)))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub58.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let insert a l  = 
 (match l with 
|[] -> [a]
|hd::tl -> (a :: (hd :: tl)))

let rec confirm a l  = 
 (match l with 
|[] -> false
|hd::tl -> if (hd = a) then true
 else confirm (a) (tl))

let rec cal  : ((string list * lambda) -> string list) = 
fun (a, b) -> 
 (match b with 
|V v -> if confirm (v) (a) then a
 else insert ("false") (a)
|P (x, y) -> if confirm (x) (a) then cal ((a, y))
 else cal ((insert (x) (a), y))
|C (x, y) -> cal ((cal ((a, x)), y)))

let check  : (lambda -> bool) = 
fun e -> 
 (match e with 
|V x -> false
|P (x, y) -> 
let l  = cal ((insert (x) ([]), y))
 in 
if confirm ("false") (l) then false
 else true
|C (x, y) -> false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub60.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec ch  : ((lambda * var) -> bool) = 
fun (e, a) -> 
 (match e with 
|V b -> if (a = b) then true
 else false
|P (b, e) -> 
 (match e with 
|V c -> if ((c = b) || (c = a)) then true
 else false
|P (c, e) -> ((ch ((e, c)) || ch ((e, b))) || ch ((e, a)))
|C (e1, e2) -> if (a = b) then (ch ((e1, a)) && ch ((e2, a)))
 else ((ch ((e1, a)) || ch ((e1, b))) && (ch ((e2, a)) || ch ((e2, b)))))
|C (e1, e2) -> (ch ((e1, a)) && ch ((e2, a))))

let check  : (lambda -> bool) = 
fun e -> 
 (match e with 
|V a -> false
|P (a, e) -> ch ((e, a))
|C (e1, e2) -> false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub61.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check  : (lambda -> bool) = 
fun e -> true

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub63.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check  : (lambda -> bool) = 
fun ex -> 
let rec var_list  : (lambda -> var list) = 
fun ex2 -> 
 (match ex2 with 
|V v -> [v]
|P (v2, ex3) -> var_list (ex3)
|C (ex3, ex4) -> (var_list (ex3) @ var_list (ex4)))
 in 

let rec proc_list  : (lambda -> var list) = 
fun ex2 -> 
 (match ex2 with 
|V v -> []
|P (v2, ex3) -> (v2 :: proc_list (ex3))
|C (ex3, ex4) -> (proc_list (ex3) @ proc_list (ex4)))
 in 

let rec _in_  : ((var list * var) -> bool) = 
fun (vlist, v) -> 
 (match vlist with 
|[] -> false
|hd::tl -> if (hd = v) then true
 else _in_ ((tl, v)))
 in 

let rec check2  : ((var list * var list) -> bool) = 
fun (vlist, plist) -> 
 (match vlist with 
|[] -> true
|hd::tl -> (_in_ ((plist, hd)) && check2 ((tl, plist))))
 in 
check2 ((var_list (ex), proc_list (ex)))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub67.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec comp va exorg  = 
 (match exorg with 
|V va1 -> false
|P (va1, ex1) -> if (va = va1) then true
 else comp (va) (ex1)
|C (ex1, ex2) -> (comp (va) (ex1) || comp (va) (ex2)))

let rec find ex exorg  = 
 (match ex with 
|V va1 -> comp (va1) (exorg)
|P (va1, ex1) -> find (ex1) (exorg)
|C (ex1, ex2) -> (find (ex1) (exorg) && find (ex2) (exorg)))

let rec check  : (lambda -> bool) = 
fun e -> 
 (match e with 
|V va -> false
|P (va, ex) -> find (ex) (e)
|C (ex1, ex2) -> (check (ex1) && check (ex2)))

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec comp va exorg  = 
 (match exorg with 
|V va1 -> false
|P (va1, ex1) -> if (va = va1) then true
 else comp (va) (ex1)
|C (ex1, ex2) -> (comp (va) (ex1) || comp (va) (ex2)))

let rec find ex exorg  = 
 (match ex with 
|V va1 -> comp (va1) (exorg)
|P (va1, ex1) -> find (ex1) (exorg)
|C (ex1, ex2) -> ((false = find (ex1) (ex2)) && find (ex2) (exorg)))

let rec check  : (lambda -> bool) = 
fun e -> 
 (match e with 
|V va -> false
|P (va, ex) -> find (ex) (e)
|C (ex1, ex2) -> (check (ex1) && check (ex2)))

Total time :19.424237
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub68.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun e -> 
let rec checkp  = 
fun (va, ex) -> 
 (match ex with 
|V va2 -> if (va = va2) then true
 else false
|P (va2, ex2) -> 
 (match ex2 with 
|C (ex3, ex4) -> if ((checkp ((va, ex3)) || checkp ((va2, ex3))) && (checkp ((va, ex4)) || checkp ((va2, ex4)))) then true
 else false
|_ -> if (checkp ((va, ex2)) || checkp ((va2, ex2))) then true
 else false)
|C (ex2, ex3) -> if (checkp ((va, ex2)) && checkp ((va, ex3))) then true
 else false)
 in 

 (match e with 
|V va -> false
|P (va, ex) -> checkp ((va, ex))
|C (ex, ex2) -> if (check (ex) && check (ex2)) then true
 else false)

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun e -> 
let rec checkp  = 
fun (va, ex) -> 
 (match ex with 
|V va2 -> if (va = va2) then true
 else false
|P (va2, ex2) -> 
 (match ex2 with 
|C (ex3, ex4) -> if ((true || checkp ((va2, ex3))) && (checkp ((va, ex4)) || checkp ((va2, ex4)))) then true
 else false
|_ -> if (checkp ((va, ex2)) || checkp ((va2, ex2))) then true
 else false)
|C (ex2, ex3) -> if (checkp ((va, ex2)) && checkp ((va, ex3))) then true
 else false)
 in 

 (match e with 
|V va -> false
|P (va, ex) -> checkp ((va, ex))
|C (ex, ex2) -> if (check (ex) && check (ex2)) then true
 else false)

Total time :0.914823
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub69.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun e -> 
 (match e with 
|V x -> false
|P (x, e1) -> 
 (match e1 with 
|V y -> (x = y)
|P (y, e2) -> 
 (match e2 with 
|C (e3, e4) -> ((check (P ((x, e3))) || check (P ((x, e4)))) && (check (P ((y, e3))) || check (P ((y, e4)))))
|_ -> (check (P ((x, e2))) || check (P ((y, e2)))))
|C (e2, e3) -> (check (P ((x, e2))) && check (P ((x, e3)))))
|C (e1, e2) -> (check (e1) && check (e2)))

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun e -> 
 (match e with 
|V x -> false
|P (x, e1) -> 
 (match e1 with 
|V y -> (x = y)
|P (y, e2) -> 
 (match e2 with 
|C (e3, e4) -> check (P ((y, P ((x, e4)))))
|_ -> (check (P ((x, e2))) || check (P ((y, e2)))))
|C (e2, e3) -> (check (P ((x, e2))) && check (P ((x, e3)))))
|C (e1, e2) -> (check (e1) && check (e2)))

Total time :23.267229
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub73.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check  : (lambda -> bool) = 
fun e -> true

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub75.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun e -> 
 (match e with 
|V x -> true
|P (x, y) -> (check (y) && checkx ((x, y)))
|C (x, y) -> (check (y) && check (x)))
and checkx (a, b)  = 
 (match b with 
|V x -> if (x = a) then true
 else false
|P (x, y) -> checkx ((a, y))
|C (x, y) -> (checkx ((a, x)) || checkx ((a, y))))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub76.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun e -> 
let rec remove_var lambda var  = 
 (match lambda with 
|P (v, ex) -> P ((v, remove_var (ex) (var)))
|C (ex, ex') -> C ((remove_var (ex) (var), remove_var (ex') (var)))
|V v -> if (v = var) then V ("c")
 else V (v))
 in 

 (match e with 
|P (v, ex) -> check (remove_var (ex) (v))
|C (ex, ex') -> (check (ex) && check (ex'))
|V v -> if (v != "c") then false
 else true)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub77.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec elist  : (lambda -> var list) = 
fun lambda -> 
 (match lambda with 
|V var -> []
|P (var, lambda1) -> 
 (match lambda1 with 
|V var2 -> [var]
|P (var2, lambda2) -> ([var; var2] @ elist (lambda2))
|C (lambda3, lambda4) -> ([var] @ (elist (lambda3) @ elist (lambda4))))
|C (lambda2, lambda3) -> 
 (match lambda2 with 
|V var -> elist (lambda3)
|P (var2, lambda4) -> ([var2] @ elist (lambda4))
|C (lambda5, lambda6) -> (elist (lambda5) @ (elist (lambda6) @ elist (lambda3)))))

let rec vlist lambda  = 
 (match lambda with 
|V var -> [var]
|P (var, lambda1) -> 
 (match lambda1 with 
|V var2 -> [var2]
|P (var2, lambda2) -> vlist (lambda2)
|C (lambda3, lambda4) -> (vlist (lambda3) @ vlist (lambda4)))
|C (lambda2, lambda3) -> 
 (match lambda2 with 
|V var -> ([var] @ vlist (lambda3))
|P (var2, lambda4) -> vlist (lambda4)
|C (lambda5, lambda6) -> (vlist (lambda5) @ (vlist (lambda6) @ vlist (lambda3)))))

let rec exist lambdalist varlist  = 
 (match varlist with 
|[] -> true
|vhd::vtl -> 
 (match lambdalist with 
|[] -> false
|ehd::etl -> if (vhd = ehd) then exist (lambdalist) (vtl)
 else (exist (etl) ([vhd]) || exist (etl) (varlist))))

let rec check  : (lambda -> bool) = 
fun lambda -> exist (elist (lambda)) (vlist (lambda))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub79.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec checklist  : ((string list * string) -> bool) = 
fun (l, s) -> 
 (match l with 
|[] -> false
|h::t -> if (h = s) then true
 else checklist ((t, s)))

let rec extend  : ((lambda * string list) -> string list) = 
fun (x, env) -> 
 (match x with 
|V var -> if checklist ((env, var)) then env
 else (var :: env)
|P (v, e) -> extend ((e, env))
|C (e1, e2) -> extend ((e1, extend ((e2, env)))))

let rec check  : (lambda -> bool) = 
fun e -> 
 (match e with 
|V var -> true
|P (v, e1) -> (check (e1) && checklist ((extend ((e1, [])), v)))
|C (e1, e2) -> (check (e1) && check (e2)))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub81.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check input  = 
let rec helpCheck a lst  = 
 (match a with 
|V a -> __list_exists__ (
fun a -> (a = a)) (lst)
|P (a, b) -> helpCheck (b) ((a :: lst))
|C (a, b) -> (helpCheck (a) (lst) && helpCheck (b) (lst)))
 in 
helpCheck (input) ([])

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check input  = 
let rec helpCheck a lst  = 
 (match a with 
|V a -> __list_exists__ (
fun __x__ -> (a = __x__)) (lst)
|P (a, b) -> helpCheck (b) ((a :: lst))
|C (a, b) -> (helpCheck (a) (lst) && helpCheck (b) (lst)))
 in 
helpCheck (input) ([])

Total time :10.510277
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_15/sub83.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec exist v lst  = 
 (match lst with 
|[] -> false
|hd::tl -> if (v = hd) then true
 else exist (v) (tl))

let rec checker e lst  = 
 (match e with 
|V v -> exist (v) (lst)
|P (v, e) -> checker (e) ((lst @ [v]))
|C (e1, e2) -> if (checker (e1) (lst) = checker (e2) (lst)) then true
 else false)

let rec check  : (lambda -> bool) = 
fun e -> checker (e) ([])

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec exist v lst  = 
 (match lst with 
|[] -> false
|hd::tl -> if (v = hd) then true
 else exist (v) (tl))

let rec checker e lst  = 
 (match e with 
|V v -> exist (v) (lst)
|P (v, e) -> checker (e) ((lst @ [v]))
|C (e1, e2) -> if (checker (e1) (lst) = checker (e2) (lst)) then checker (e2) (lst)
 else false)

let rec check  : (lambda -> bool) = 
fun e -> checker (e) ([])

Total time :0.230322
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub1.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec input_var  : (lambda -> (string list -> string list)) = 
fun e lst -> 
 (match e with 
|V v -> lst
|P (v, e1) -> (input_var (e1) (lst) @ [v])
|C (e1, e2) -> input_var (e1) (input_var (e2) (lst)))

let rec input_lambda  : (lambda -> (string list -> string list)) = 
fun e lst -> 
 (match e with 
|V v -> (lst @ [v])
|P (v, e1) -> input_lambda (e1) (lst)
|C (e1, e2) -> input_lambda (e1) (input_lambda (e2) (lst)))

let rec isthere  : (string list -> (string list -> bool)) = 
fun lst l2 -> 
 (match lst with 
|[] -> true
|hd::tl -> 
 (match l2 with 
|[] -> false
|h::t -> if (hd = h) then true
 else isthere ([hd]) (t)))

let rec check  : (lambda -> bool) = 
fun lambda -> 
let l2  = input_var (lambda) ([])
 in 

let l1  = input_lambda (lambda) ([])
 in 

 (match lambda with 
|V v -> false
|C (e1, e2) -> (check (e1) && check (e2))
|P (v, e) -> 
 (match l1 with 
|[] -> true
|hd::tl -> if isthere ([hd]) (l2) then isthere (tl) (l2)
 else false))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub10.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V v -> true
|P (v, e) -> true
|C (e1, e2) -> true)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub101.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|P (s, V a) -> if (s = a) then true
 else false
|P (s, P (s1, e1)) -> 
 (match e1 with 
|C (e2, e3) -> ((check (P ((s, e2))) || check (P ((s1, e2)))) && (check (P ((s, e3))) || check (P ((s1, e3)))))
|_ -> if ((check (P ((s1, e1))) = true) || check (P ((s, e1)))) then true
 else false)
|P (s, C (e1, e2)) -> 
 (match (e1, e2) with 
|(P (s1, e3), e) -> if (check (P ((s, P ((s1, e3))))) && check (P ((s, P ((s1, e)))))) then true
 else false
|(e, P (s1, e3)) -> if (check (P ((s, P ((s1, e3))))) && check (P ((s, P ((s1, e)))))) then true
 else false
|_ -> if (check (P ((s, e1))) && check (P ((s, e2)))) then true
 else false)
|_ -> false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub102.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec find  : ((var list * var) -> bool) = 
fun (lst, v) -> 
 (match lst with 
|hd::tl -> if (hd = v) then true
 else find ((tl, v))
|_ -> false)

let rec f  : ((var list * lambda) -> bool) = 
fun (lst, e) -> 
 (match e with 
|V v -> if find ((lst, v)) then true
 else false
|P (v, e) -> if f (((lst @ [v]), e)) then true
 else false
|C (e1, e2) -> if (check (e1) && check (e2)) then true
 else false)
and check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V v -> false
|P (v, e) -> if f (([v], e)) then true
 else false
|C (e1, e2) -> if (check (e1) && check (e2)) then true
 else false)

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec find  : ((var list * var) -> bool) = 
fun (lst, v) -> 
 (match lst with 
|hd::tl -> if (hd = v) then true
 else find ((tl, v))
|_ -> false)

let rec f  : ((var list * lambda) -> bool) = 
fun (lst, e) -> 
 (match e with 
|V v -> if find ((lst, v)) then true
 else false
|P (v, e) -> if f (((lst @ [v]), e)) then true
 else false
|C (e1, e2) -> if (check (e1) && check (e2)) then true
 else (f ((lst, e1)) && f ((lst, e2))))
and check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V v -> false
|P (v, e) -> if f (([v], e)) then true
 else false
|C (e1, e2) -> if (check (e1) && check (e2)) then true
 else false)

Total time :12.63274
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub109.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec var_find lambda  = 
 (match lambda with 
|V a -> []
|P (a, lambda1) -> (a :: var_find (lambda1))
|C (lambda1, lambda2) -> (var_find (lambda1) @ var_find (lambda2)))

let rec lambda_find lambda  = 
 (match lambda with 
|V a -> [a]
|P (a, lambda1) -> lambda_find (lambda1)
|C (lambda1, lambda2) -> (lambda_find (lambda1) @ lambda_find (lambda2)))

let rec find s l  = 
 (match l with 
|[] -> false
|hd::tl -> if (s = hd) then true
 else find (s) (tl))

let rec find_match l1 l2  = 
 (match l2 with 
|[] -> true
|hd::tl -> (find (hd) (l1) && find_match (l1) (tl)))

let check  : (lambda -> bool) = 
fun lambda -> find_match (var_find (lambda)) (lambda_find (lambda))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub11.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec isexist  : (var list -> (var -> bool)) = 
fun vars v -> 
 (match vars with 
|[] -> false
|hd::tl -> if (hd = v) then true
 else isexist (tl) (v))

let rec chkvars  : (lambda -> (var list -> bool)) = 
fun lambda vars -> 
 (match lambda with 
|V v -> isexist (vars) (v)
|P (v, e) -> chkvars (e) ((v :: vars))
|C (V v, e) -> chkvars (e) ((v :: vars)))

let check  : (lambda -> bool) = 
fun lambda -> chkvars (lambda) ([])

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub112.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check  : (lambda -> bool) = 
fun lambda -> false

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub121.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec append_list list1 list2  = 
 (match list1 with 
|[] -> list2
|hd::tl -> (hd :: append_list (tl) (list2)))

let rec get_variables lambda result  = 
 (match lambda with 
|V v -> (v :: result)
|P (v, e) -> get_variables (e) ((v :: result))
|C (e1, e2) -> append_list (get_variables (e1) (result)) (get_variables (e2) (result)))

let rec var_in_lambda variable lambda  = 
 (match lambda with 
|V v -> false
|P (v, e) -> if (v = variable) then true
 else var_in_lambda (variable) (e)
|C (e1, e2) -> (var_in_lambda (variable) (e1) || var_in_lambda (variable) (e2)))

let rec check_helper variables lambda  = 
 (match variables with 
|[] -> true
|hd::tl -> if (var_in_lambda (hd) (lambda) = false) then false
 else check_helper (tl) (lambda))

let check  : (lambda -> bool) = 
fun lambda -> 
let variables  = get_variables (lambda) ([])
 in 
check_helper (variables) (lambda)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub123.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec makePList lambda pl  = 
 (match lambda with 
|V v -> pl
|P (v, e) -> (pl @ ([v] @ makePList (e) (pl)))
|C (e1, e2) -> (makePList (e1) (pl) @ makePList (e2) (pl)))

let rec makeVList lambda vl  = 
 (match lambda with 
|V v -> (vl @ [v])
|P (v, e) -> (vl @ makeVList (e) (vl))
|C (e1, e2) -> (makeVList (e1) (vl) @ makeVList (e2) (vl)))

let rec compareToPlist pl e  = 
 (match pl with 
|[] -> false
|hd::tl -> ((e = hd) || compareToPlist (tl) (e)))

let rec compareList pl vl  = 
 (match vl with 
|[] -> true
|hd::tl -> (compareList (pl) (tl) && compareToPlist (pl) (hd)))

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V v -> false
|P (v, e) -> 
let pl  = makePList (lambda) ([])
 in 

let vl  = makeVList (lambda) ([])
 in 
compareList (pl) (vl)
|C (e1, e2) -> (check (e1) && check (e2)))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub124.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec bound  : (lambda -> var list) = 
fun lambda -> 
 (match lambda with 
|V var -> []
|P (var, ex) -> (var :: bound (ex))
|C (ex1, ex2) -> (bound (ex1) @ bound (ex2)))

let rec variables  : (lambda -> var list) = 
fun lambda -> 
 (match lambda with 
|V var -> [var]
|P (var, ex) -> variables (ex)
|C (ex1, ex2) -> (variables (ex1) @ variables (ex2)))

let rec containHelper  : ((var list * var) -> bool) = 
fun (bound, a) -> 
 (match (bound, a) with 
|([], a) -> false
|(x::tl, a) -> if (x = a) then true
 else containHelper ((tl, a)))

let rec contain  : ((var list * var list) -> bool) = 
fun (bound, variables) -> 
 (match (bound, variables) with 
|([], variables) -> false
|(bound, []) -> true
|(bound, a::tl) -> if (containHelper ((bound, a)) = false) then false
 else contain ((bound, tl)))

let check  : (lambda -> bool) = 
fun lambda -> contain ((bound (lambda), variables (lambda)))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub125.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V var -> false
|P (var1, V var2) -> if (var1 = var2) then true
 else false
|P (var1, C (V var2, P (var3, V var4))) -> if (((var1 = var4) || (var2 = var4)) || (var3 = var4)) then true
 else false
|P (var1, P (var2, V var3)) -> if ((var1 = var3) || (var2 = var3)) then true
 else false
|P (var1, P (var2, C (V var3, V var4))) -> if (((var1 = var3) || (var2 = var3)) && ((var1 = var4) || (var2 = var4))) then true
 else false
|C (V var1, V var2) -> false
|P (var1, P (var2, P (var3, V var4))) -> if (((var1 = var4) || (var2 = var4)) || (var3 = var4)) then true
 else false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub128.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V _ -> false
|C (_, _) -> false
|P (x, V y) -> if (x = y) then true
 else false
|P (x, P (y, z)) -> if ((x = y) && check (P ((x, z)))) then true
 else false
|P (x, C (y, z)) -> (check (P ((x, y))) && check (P ((x, z)))))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub13.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let isinthelist l a  = 
let temp  = __list_filter__ (
fun x y -> if (x != y) then false
 else true (a)) (l)
 in 

 (match temp with 
|[] -> false
|hd::tl -> true)

let isnotinthelist l a  = 
let temp  = __list_filter__ (
fun x y -> if (x != y) then false
 else true (a)) (l)
 in 

 (match temp with 
|[] -> true
|hd::tl -> false)

let rec pvar e  = 
 (match e with 
|P (s0, e0) -> (s0 :: pvar (e0))
|C (e0, e1) -> (pvar (e0) @ pvar (e1))
|V s0 -> [])

let rec vvar e  = 
 (match e with 
|P (s0, e0) -> vvar (e0)
|C (e0, e1) -> (vvar (e0) @ vvar (e1))
|V s0 -> (s0 :: []))

let rec check e  = 
let l0  = pvar (e)
 in 

let l1  = vvar (e)
 in 

 (match __list_filter__ (isnotinthelist (l0)) (l1) with 
|[] -> true
|hd::tl -> false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub16.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check  : (lambda -> bool) = 
fun lambda -> 
let rec e lambda  = 
 (match lambda with 
|V v -> false
|P (p, l) -> 
let rec f p l  = 
 (match l with 
|V a -> if (a = p) then true
 else false
|P (b, c) -> if (f (p) (c) || f (b) (c)) then true
 else false
|C (d, e) -> if (f (p) (e) && f (p) (d)) then true
 else false)
 in 
f (p) (l)
|C (n, m) -> 
 (match (n, m) with 
|(V x, V y) -> false
|(P (x, y), P (z, t)) -> if ((e (P ((x, y))) || e (P ((z, y)))) && (e (P ((x, t))) || e (P ((z, t))))) then true
 else false
|(V x, P (y, z)) -> if ((e (P ((y, n))) || e (C ((n, z)))) && (e (P ((y, z))) || e (C ((n, z))))) then true
 else false
|(P (y, z), V x) -> if ((e (P ((y, m))) || e (C ((m, z)))) && (e (P ((y, z))) || e (C ((m, z))))) then true
 else false
|(V x, C (y, z)) -> if (((e (C ((n, y))) || e (C ((n, z)))) && (e (C ((y, z))) || e (C ((y, n))))) && (e (C ((z, n))) || e (C ((z, y))))) then true
 else false
|(C (y, z), V x) -> if (((e (C ((m, y))) || e (C ((m, z)))) && (e (C ((y, z))) || e (C ((y, m))))) && (e (C ((z, m))) || e (C ((z, y))))) then true
 else false
|(P (x, y), C (z, t)) -> if ((((e (P ((x, y))) || e (C ((y, z)))) || e (C ((y, t)))) && ((e (P ((x, z))) || e (C ((z, t)))) || e (C ((z, y))))) && ((e (P ((x, t))) || e (C ((t, y)))) || e (C ((t, z))))) then true
 else false
|(C (z, t), P (x, y)) -> if ((((e (P ((x, y))) || e (C ((y, z)))) || e (C ((y, t)))) && ((e (P ((x, z))) || e (C ((z, t)))) || e (C ((z, y))))) && ((e (P ((x, t))) || e (C ((t, y)))) || e (C ((t, z))))) then true
 else false
|(C (x, y), C (z, t)) -> if (((((e (C ((x, y))) || e (C ((x, z)))) || e (C ((x, t)))) && ((e (C ((y, z))) || e (C ((y, t)))) || e (C ((y, x))))) && ((e (C ((z, t))) || e (C ((z, x)))) || e (C ((z, y))))) && ((e (C ((t, x))) || e (C ((t, y)))) || e (C ((t, z))))) then true
 else false))
 in 
e (lambda)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub20.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec isin  : ((var * var list) -> bool) = 
fun (str, lst) -> 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = str) then true
 else isin ((str, tl)))

let rec filter lst lst2  = 
 (match lst with 
|[] -> true
|hd::tl -> if (isin ((hd, lst2)) = true) then filter (tl) (lst2)
 else false)

let rec bool_check  : ((lambda * var list) -> var list) = 
fun (lambda, lst) -> 
 (match lambda with 
|V str -> lst
|P (e1, e2) -> bool_check ((e2, ([e1] @ lst)))
|C (e1, e2) -> (bool_check ((e1, lst)) @ bool_check ((e2, lst))))

let rec cal_check  : ((lambda * var list) -> var list) = 
fun (lambda, lst) -> 
 (match lambda with 
|V str -> (str :: lst)
|P (e1, e2) -> cal_check ((e2, lst))
|C (e1, e2) -> (cal_check ((e1, lst)) @ cal_check ((e2, lst))))

let check  : (lambda -> bool) = 
fun lambda -> if (filter (cal_check ((lambda, []))) (bool_check ((lambda, []))) = true) then true
 else false

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub25.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

exception NotImplemented

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec result  : (lambda -> var) = 
fun lambda -> 
 (match lambda with 
|V var -> var
|P (v, e) -> result (e)
|C (e1, e2) -> result (e2))

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V var -> false
|P (v1, V v2) -> if (v1 = v2) then true
 else false
|P (v1, P (v2, e2)) -> if (check (P ((v2, e2))) || (v1 = result (e2))) then true
 else false
|P (v1, C (e1, e2)) -> if (v1 = result (e2)) then true
 else false
|_ -> raise NotImplemented)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub26.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec evalCheck1 ex bd  = 
 (match ex with 
|V x -> false
|P (arg, body) -> if (arg = bd) then true
 else evalCheck1 (body) (bd)
|C (a, b) -> (evalCheck1 (a) (bd) || evalCheck1 (b) (bd)))

let rec evalCheck2 ex bd  = 
 (match bd with 
|V x -> evalCheck1 (ex) (x)
|P (arg, body) -> evalCheck2 (ex) (body)
|C (a, b) -> (evalCheck2 (ex) (a) && evalCheck2 (ex) (b)))

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V x -> false
|P (arg, body) -> evalCheck2 (lambda) (body)
|C (a, b) -> (check (a) && check (b)))

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec evalCheck1 ex bd  = 
 (match ex with 
|V x -> false
|P (arg, body) -> if (arg = bd) then true
 else evalCheck1 (body) (bd)
|C (a, b) -> (evalCheck1 (a) (bd) || evalCheck1 (b) (bd)))

let rec evalCheck2 ex bd  = 
 (match bd with 
|V x -> evalCheck1 (ex) (x)
|P (arg, body) -> evalCheck2 (ex) (body)
|C (a, b) -> ((false = evalCheck2 (b) (a)) && evalCheck2 (ex) (b)))

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V x -> false
|P (arg, body) -> evalCheck2 (lambda) (body)
|C (a, b) -> (check (a) && check (b)))

Total time :16.567615
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub36.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check  : (lambda -> bool) = 
fun lambda -> 
let rec make_list  : (lambda -> ((var list * var list) -> (var list * var list))) = 
fun lambda' (lst1, lst2) -> 
 (match lambda' with 
|V v -> (lst1, (v :: lst2))
|P (v, e) -> make_list (e) (((v :: lst1), lst2))
|C (e1, e2) -> make_list (e1) (make_list (e2) ((lst1, lst2))))
 in 

let rec exist  : (var list -> (var -> bool)) = 
fun lst v -> 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = v) then true
 else exist (tl) (v))
 in 

let rec real_check  : ((var list * var list) -> bool) = 
fun (lst1, lst2) -> 
 (match lst2 with 
|[] -> true
|hd::tl -> if exist (lst1) (hd) then real_check ((lst1, tl))
 else false)
 in 
real_check (make_list (lambda) (([], [])))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub37.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

exception NotImplemented

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V v -> true
|P (v, p) -> true
|_ -> raise NotImplemented)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub39.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V _ -> false
|P (a, e) -> 
let l  = cklist (e)
 in 

 (match l with 
|[] -> true
|hd::tl -> if mtlist ((a, l)) then if (remlist ((a, l)) = []) then true
 else 
 (match e with 
|V _ -> true
|P (_, _) -> check (e)
|C (V a, V b) -> true
|C (V _, e1) -> check (e1)
|C (e1, V _) -> check (e1)
|C (e1, e2) -> check (e))
 else false)
|C (e1, e2) -> (check (e1) && check (e2)))
and cklist lambda  = 
 (match lambda with 
|V a -> [a]
|P (a, e) -> cklist (e)
|C (e1, e2) -> (cklist (e1) @ cklist (e2)))
and mtlist (a, l)  = 
 (match l with 
|[] -> false
|hd::tl -> if (hd = a) then true
 else mtlist ((a, tl)))
and remlist (a, l)  = 
 (match l with 
|[] -> []
|hd::tl -> if (hd = a) then remlist ((a, tl))
 else ([a] @ remlist ((a, tl))))

FixML fails to generate a patch

Error occurs : ../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub40.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases

../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub47.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V _ -> false
|C (_, _) -> false
|P (v1, V v2) -> if (v1 = v2) then true
 else false
|P (v1, P (v2, e1)) -> if ((v1 = v2) && check (P ((v1, e1)))) then true
 else false
|P (v1, C (e1, e2)) -> (check (P ((v1, e1))) && check (P ((v1, e2)))))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub54.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

exception NotImplemented

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec varOfExp  : (lambda -> var) = 
fun lambda -> 
 (match lambda with 
|V var -> var
|P (var, e) -> varOfExp (e)
|C (e1, e2) -> varOfExp (e2))

let check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|P (var1, P (var2, e)) -> if ((varOfExp (e) = var2) || (varOfExp (e) = var1)) then true
 else false
|P (var1, C (e1, e2)) -> if (varOfExp (e2) = var1) then true
 else false
|P (var1, V var2) -> if (var1 = var2) then true
 else false
|_ -> raise NotImplemented)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub57.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec has  : (string -> (lambda -> bool)) = 
fun str lambdaression -> 
 (match lambdaression with 
|V v -> false
|P (v, e) -> if (v = str) then true
 else false
|C (e1, e2) -> (has (str) (e1) || has (str) (e2)))

let rec checkOriginal  : (lambda -> (lambda -> bool)) = 
fun lambda original -> 
 (match lambda with 
|V v -> has (v) (original)
|P (v, e) -> checkOriginal (e) (original)
|C (e1, e2) -> (checkOriginal (e1) (original) && checkOriginal (e2) (original)))

let rec check  : (lambda -> bool) = 
fun lambda -> checkOriginal (lambda) (lambda)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub60.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec isthere  : (string -> (lambda -> lambda)) = 
fun key lambda -> 
 (match lambda with 
|V v1 -> if (key = v1) then V ("true")
 else V (v1)
|P (v1, e1) -> P ((v1, isthere (key) (isthere (v1) (e1))))
|C (e1, e2) -> C ((isthere (key) (e1), isthere (key) (e2))))

let rec nothere  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V v -> if (v = "true") then true
 else false
|P (v, e) -> if (nothere (e) = true) then true
 else false
|C (e1, e2) -> if ((nothere (e1) = true) && (nothere (e2) = true)) then true
 else false)

let check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V v -> false
|P (v, e) -> nothere (isthere (v) (e))
|C (e1, e2) -> false)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub62.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec getBoundValues  : (lambda -> var list) = 
fun lambda -> 
 (match lambda with 
|V v -> []
|P (v, e) -> (v :: getBoundValues (e))
|C (e1, e2) -> (getBoundValues (e1) @ getBoundValues (e2)))

let rec getValues  : (lambda -> var list) = 
fun lambda -> 
 (match lambda with 
|V v -> [v]
|P (v, e) -> getValues (e)
|C (e1, e2) -> (getValues (e1) @ getValues (e2)))

let rec compareHelper  : ((var * var list) -> bool) = 
fun (var, varL) -> 
 (match (var, varL) with 
|(v, hd::tl) -> if (v = hd) then true
 else if (tl = []) then false
 else compareHelper ((v, tl)))

let rec compare  : ((var list * var list) -> bool) = 
fun (values, bound) -> 
 (match (values, bound) with 
|(valueHd::valueTl, bound) -> if (valueTl = []) then compareHelper ((valueHd, bound))
 else if compareHelper ((valueHd, bound)) then compare ((valueTl, bound))
 else false)

let check  : (lambda -> bool) = 
fun lambda -> compare ((getValues (lambda), getBoundValues (lambda)))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub66.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec helpcheck  : (lambda -> lambda list) = 
fun lambda -> 
 (match lambda with 
|P (a, b) -> (V (a) :: helpcheck (b))
|C (a, b) -> (helpcheck (a) @ helpcheck (b))
|V a -> [])

let rec varcheck  : (lambda -> lambda list) = 
fun lambda -> 
 (match lambda with 
|V a -> (V (a) :: [])
|C (a, b) -> (varcheck (a) @ varcheck (b))
|P (a, b) -> varcheck (b))

let rec findvar  : (lambda -> lambda list) = 
fun lambda -> 
 (match lambda with 
|V a -> (V (a) :: [])
|P (a, b) -> (V (a) :: findvar (b))
|C (a, b) -> (findvar (a) @ findvar (b)))

let rec helpcheck2  : ((lambda * lambda) -> lambda list) = 
fun (ex, lambda) -> 
 (match ex with 
|P (a, b) -> if (b = lambda) then (V (a) :: helpcheck2 ((b, lambda)))
 else (V (a) :: helpcheck2 ((b, lambda)))
|C (a, b) -> if (a = lambda) then []
 else if (b = lambda) then helpcheck2 ((a, lambda))
 else (helpcheck2 ((a, lambda)) @ helpcheck2 ((b, lambda)))
|V a -> [])

let rec confi  : ((lambda list * lambda) -> bool) = 
fun (a, b) -> 
 (match a with 
|hd::tl -> if (hd = b) then true
 else confi ((tl, b))
|_ -> false)

let rec last  : ((lambda list * lambda) -> bool) = 
fun (a, b) -> 
 (match a with 
|hd::tl -> (confi ((helpcheck2 ((b, hd)), hd)) && last ((tl, b)))
|[] -> true)

let rec check  : (lambda -> bool) = 
fun lambda -> if last ((varcheck (lambda), lambda)) then true
 else false

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec helpcheck  : (lambda -> lambda list) = 
fun lambda -> 
 (match lambda with 
|P (a, b) -> (V (a) :: helpcheck (b))
|C (a, b) -> (helpcheck (a) @ helpcheck (b))
|V a -> [])

let rec varcheck  : (lambda -> lambda list) = 
fun lambda -> 
 (match lambda with 
|V a -> (V (a) :: [])
|C (a, b) -> (varcheck (a) @ varcheck (b))
|P (a, b) -> varcheck (b))

let rec findvar  : (lambda -> lambda list) = 
fun lambda -> 
 (match lambda with 
|V a -> (V (a) :: [])
|P (a, b) -> (V (a) :: findvar (b))
|C (a, b) -> (findvar (a) @ findvar (b)))

let rec helpcheck2  : ((lambda * lambda) -> lambda list) = 
fun (ex, lambda) -> 
 (match ex with 
|P (a, b) -> if (b = lambda) then (V (a) :: helpcheck2 ((b, lambda)))
 else (V (a) :: helpcheck2 ((b, lambda)))
|C (a, b) -> if (findvar (lambda) = varcheck (a)) then []
 else if (b = lambda) then helpcheck2 ((a, lambda))
 else (helpcheck2 ((a, lambda)) @ helpcheck2 ((b, lambda)))
|V a -> [])

let rec confi  : ((lambda list * lambda) -> bool) = 
fun (a, b) -> 
 (match a with 
|hd::tl -> if (hd = b) then true
 else confi ((tl, b))
|_ -> false)

let rec last  : ((lambda list * lambda) -> bool) = 
fun (a, b) -> 
 (match a with 
|hd::tl -> (confi ((helpcheck2 ((b, hd)), hd)) && last ((tl, b)))
|[] -> true)

let rec check  : (lambda -> bool) = 
fun lambda -> if last ((varcheck (lambda), lambda)) then true
 else false

Total time :31.216316
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub7.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec allvar  : (lambda -> string list) = 
fun lambda -> 
 (match lambda with 
|V v -> [v]
|P (v, ex) -> []
|C (ex1, ex2) -> (allvar (ex1) @ allvar (ex2)))

let rec searchlist  : ((var list * var) -> bool) = 
fun (lst, var) -> 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = var) then true
 else searchlist ((tl, var)))

let rec complist  : ((var list * var list) -> bool) = 
fun (l1, l2) -> 
 (match l2 with 
|[] -> true
|hd::tl -> if searchlist ((l1, hd)) then complist ((l1, tl))
 else false)

let rec checktest  : ((lambda * var list) -> bool) = 
fun (lambda, l) -> 
 (match lambda with 
|V v -> true
|P (v, ex) -> if complist ((([v] @ l), allvar (ex))) then checktest ((ex, ([v] @ l)))
 else false
|C (ex1, ex2) -> (checktest ((ex1, l)) && checktest ((ex2, l))))

let check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V v -> false
|_ -> checktest ((lambda, [])))

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec allvar  : (lambda -> string list) = 
fun lambda -> 
 (match lambda with 
|V v -> [v]
|P (v, ex) -> []
|C (ex1, ex2) -> (allvar (ex1) @ allvar (ex2)))

let rec searchlist  : ((var list * var) -> bool) = 
fun (lst, var) -> 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = var) then true
 else searchlist ((tl, var)))

let rec complist  : ((var list * var list) -> bool) = 
fun (l1, l2) -> 
 (match l2 with 
|[] -> true
|hd::tl -> if searchlist ((l1, hd)) then complist ((l1, tl))
 else false)

let rec checktest  : ((lambda * var list) -> bool) = 
fun (lambda, l) -> 
 (match lambda with 
|V v -> searchlist ((l, v))
|P (v, ex) -> if complist ((([v] @ l), allvar (ex))) then checktest ((ex, ([v] @ l)))
 else false
|C (ex1, ex2) -> (checktest ((ex1, l)) && checktest ((ex2, l))))

let check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V v -> false
|_ -> checktest ((lambda, [])))

Total time :0.27863
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub70.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec comparelist  : (a list -> (a list -> a list)) = 
fun procdata vardata -> 
 (match (procdata, vardata) with 
|(_, []) -> []
|(hd1::tl1, hd2::tl2) -> if (hd1 = hd2) then comparelist (procdata) (tl2)
 else (comparelist ([hd1]) (tl2) @ comparelist (tl1) (vardata))
|([], hd2::tl2) -> (hd2 :: tl2))

let rec varlist  : (lambda -> var list) = 
fun lambda -> 
 (match lambda with 
|V v -> [v]
|P (_, a) -> varlist (a)
|C (a, b) -> (varlist (a) @ varlist (b)))

let rec proclist  : (lambda -> var list) = 
fun lambda -> 
 (match lambda with 
|P (v, a) -> (v :: proclist (a))
|C (a, b) -> (proclist (a) @ proclist (b))
|_ -> [])

let check  : (lambda -> bool) = 
fun lambda -> 
let list1  = proclist (lambda)
 in 

let list2  = varlist (lambda)
 in 

let list3  = comparelist (list1) (list2)
 in 
if (list3 = []) then true
 else false

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub77.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|P (a, b) -> true
|V a -> true
|C (a, b) -> true)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub80.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec exist v lst  = 
 (match lst with 
|[] -> false
|hd::tl -> if (v = hd) then true
 else exist (v) (tl))

let rec checker e lst  = 
 (match e with 
|V v -> exist (v) (lst)
|P (v, e) -> checker (e) ((lst @ [v]))
|C (e1, e2) -> if (checker (e1) (lst) = checker (e2) (lst)) then true
 else false)

let rec check  : (lambda -> bool) = 
fun lambda -> checker (lambda) ([])

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec exist v lst  = 
 (match lst with 
|[] -> false
|hd::tl -> if (v = hd) then true
 else exist (v) (tl))

let rec checker e lst  = 
 (match e with 
|V v -> exist (v) (lst)
|P (v, e) -> checker (e) ((lst @ [v]))
|C (e1, e2) -> if (checker (e1) (lst) = checker (e2) (lst)) then checker (e2) (lst)
 else false)

let rec check  : (lambda -> bool) = 
fun lambda -> checker (lambda) ([])

Total time :0.231724
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub81.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec isin (str, lambdar)  = 
 (match (str, lambdar) with 
|(str, V a) -> false
|(str, P (a, b)) -> if (a = str) then true
 else isin ((str, b))
|(str, C (a, b)) -> false)

let rec findvar lambda lambdaression  = 
 (match lambda with 
|V var -> isin ((var, lambdaression))
|P (var, lambdar) -> (findvar (lambdar) (lambdaression) || findvar (lambdar) (lambda))
|C (lambdar1, lambdar2) -> ((findvar (lambdar1) (lambdaression) || findvar (lambdar1) (lambdar1)) && (findvar (lambdar2) (lambdaression) || findvar (lambdar2) (lambdar2))))

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V var -> false
|P (var, lambdar) -> findvar (lambdar) (lambda)
|C (lambdar1, lambdar2) -> (check (lambdar1) && check (lambdar2)))

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec isin (str, lambdar)  = 
 (match (str, lambdar) with 
|(str, V a) -> false
|(str, P (a, b)) -> if (a = str) then true
 else isin ((str, b))
|(str, C (a, b)) -> isin ((str, a)))

let rec findvar lambda lambdaression  = 
 (match lambda with 
|V var -> isin ((var, lambdaression))
|P (var, lambdar) -> (findvar (lambdar) (lambdaression) || findvar (lambdar) (lambda))
|C (lambdar1, lambdar2) -> ((findvar (lambdar1) (lambdaression) || findvar (lambdar1) (lambdar1)) && (findvar (lambdar2) (lambdaression) || findvar (lambdar2) (lambdar2))))

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V var -> false
|P (var, lambdar) -> findvar (lambdar) (lambda)
|C (lambdar1, lambdar2) -> (check (lambdar1) && check (lambdar2)))

Total time :1.854593
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub87.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec str lambda  = 
 (match lambda with 
|V a -> []
|P (a, e1) -> (a :: str (e1))
|C (e1, e2) -> (str (e1) @ str (e2)))

let rec v_str lambda  = 
 (match lambda with 
|V a -> [a]
|P (a, e1) -> v_str (e1)
|C (e1, e2) -> (v_str (e1) @ v_str (e2)))

let rec search var lambda  = 
 (match lambda with 
|[] -> false
|hd::tl -> if (hd = var) then true
 else search (var) (tl))

let rec compare e1 e2  = 
 (match e2 with 
|[] -> true
|hd::tl -> if (search (hd) (e1) && compare (e1) (tl)) then true
 else false)

let check  : (lambda -> bool) = 
fun lambda -> compare (str (lambda)) (v_str (lambda))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub90.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V vari -> true
|P (vari, lambda) -> 
 (match lambda with 
|V v -> if (vari = v) then true
 else false
|C (e1, e2) -> (((check (P ((vari, e1))) || check (P ((vari, e2)))) && check (e1)) && check (e2))
|P (v, e) -> (check (P ((v, e))) && check (P ((vari, e)))))
|C (lambda1, lambda2) -> (check (lambda1) && check (lambda2)))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_16/sub96.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun lambda -> 
 (match lambda with 
|V a -> false
|P (a, b) -> 
 (match lambda with 
|V c -> if (a = c) then true
 else false
|P (c, d) -> (check (P ((c, d))) || check (P ((a, d))))
|C (c, d) -> (check (P ((a, c))) && check (P ((a, d)))))
|C (a, b) -> 
 (match (a, b) with 
|(P (c, d), P (e, f)) -> (check (P ((c, d))) && check (P ((e, f))))
|_ -> false))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_17/sub15.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec recheck  = 
fun v lamm -> 
 (match lamm with 
|P (x, l) -> recheck ((v @ [x])) (l)
|C (l1, l2) -> (recheck (v) (l1) && recheck (v) (l2))
|V x -> 
 (match v with 
|[] -> false
|hd::tl -> if (hd = x) then true
 else recheck (tl) (lamm)))

let rec check  : (lambda -> bool) = 
fun lam -> 
 (match lam with 
|P (v, l) -> recheck ([v]) (l)
|_ -> false)

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec recheck  = 
fun v lamm -> 
 (match lamm with 
|P (x, l) -> recheck ((v @ [x])) (l)
|C (l1, l2) -> (recheck (v) (l1) && recheck (v) (l2))
|V x -> 
 (match v with 
|[] -> false
|hd::tl -> if (hd = x) then true
 else recheck (tl) (lamm)))

let rec check  : (lambda -> bool) = 
fun lam -> 
 (match lam with 
|P (v, l) -> recheck ([v]) (l)
|_ -> recheck ([]) (lam))

Total time :0.059583
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_17/sub18.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun lam -> 
let rec eval  : (lambda -> (var list -> var list)) = 
fun lam ll -> 
 (match lam with 
|V v -> 
 (match ll with 
|[] -> ("false" :: ll)
|hd::tl -> if (hd = v) then ll
 else (hd :: eval (V (v)) (tl)))
|P (v, l) -> 
let ll2  = (v :: ll)
 in 
eval (l) (ll2)
|C (l1, l2) -> eval (l2) (eval (l1) (ll)))
 in 

let rec compare  : (var list -> bool) = 
fun ll -> 
 (match ll with 
|[] -> true
|hd::tl -> if (hd = "false") then false
 else compare (tl))
 in 
compare (eval (lam) ([]))

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun lam -> 
let rec eval  : (lambda -> (var list -> var list)) = 
fun lam ll -> 
 (match lam with 
|V v -> 
 (match ll with 
|[] -> ("false" :: ll)
|hd::tl -> if (hd = v) then ll
 else (hd :: eval (V (v)) (tl)))
|P (v, l) -> 
let ll2  = (v :: ll)
 in 
eval (l) (ll2)
|C (l1, l2) -> eval (l2) (eval (if check (l2) then l1
 else l2) (ll)))
 in 

let rec compare  : (var list -> bool) = 
fun ll -> 
 (match ll with 
|[] -> true
|hd::tl -> if (hd = "false") then false
 else compare (tl))
 in 
compare (eval (lam) ([]))

Total time :24.269625
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_17/sub23.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec mklist  = 
fun l lam -> 
 (match lam with 
|P (var, lda) -> mklist ((var :: l)) (lda)
|V var -> l
|C (lda1, lda2) -> 
let l1  = mklist (l) (lda1)
 in 

let l2  = mklist (l) (lda2)
 in 
(l1 @ l2))

let rec checker  = 
fun l var -> 
 (match l with 
|[] -> false
|hd::tl -> if (var = hd) then true
 else checker (tl) (var))

let rec free_check  = 
fun l lam -> 
 (match lam with 
|V var -> checker (l) (var)
|P (var, lda) -> free_check (l) (lda)
|C (lda1, lda2) -> if (free_check (l) (lda1) = true) then free_check (l) (lda2)
 else false)

let rec check  : (lambda -> bool) = 
fun lam -> 
 (match lam with 
|V var -> false
|P (v, lam) -> 
let bound_list  = mklist ([]) (P ((v, lam)))
 in 
free_check (bound_list) (lam)
|C (lda1, lda2) -> 
let b_list1  = mklist ([]) (lda1)
 in 

let b_list2  = mklist ([]) (lda2)
 in 
(free_check (b_list1) (lda1) && free_check (b_list2) (lda2)))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_17/sub25.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string
type bounded = var list

let update_bounded a stk  = (a :: stk)

let rec find_bounded a stk  = 
 (match stk with 
|[] -> false
|hd::tl -> if (hd = a) then true
 else find_bounded (a) (tl))

let rec boundCheck  : (lambda -> (bounded -> bool)) = 
fun lam bd -> 
 (match lam with 
|V v -> find_bounded (v) (bd)
|P (v, l) -> 
let s  = update_bounded (v) (bd)
 in 
boundCheck (l) (s)
|C (l1, l2) -> if boundCheck (l2) (bd) then boundCheck (l2) (bd)
 else false)

let rec check  : (lambda -> bool) = 
fun lam -> boundCheck (lam) ([])

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string
type bounded = var list

let update_bounded a stk  = (a :: stk)

let rec find_bounded a stk  = 
 (match stk with 
|[] -> false
|hd::tl -> if (hd = a) then true
 else find_bounded (a) (tl))

let rec boundCheck  : (lambda -> (bounded -> bool)) = 
fun lam bd -> 
 (match lam with 
|V v -> find_bounded (v) (bd)
|P (v, l) -> 
let s  = update_bounded (v) (bd)
 in 
boundCheck (l) (s)
|C (l1, l2) -> if boundCheck (l2) (bd) then boundCheck (l1) (bd)
 else false)

let rec check  : (lambda -> bool) = 
fun lam -> boundCheck (lam) ([])

Total time :0.061272
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_17/sub27.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun lam -> true

FixML fails to generate a patch
Error occurs : ../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_17/sub3.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases

../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_17/sub4.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun lam -> true

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_17/sub42.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun lam -> true

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_17/sub45.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec test lam  = 
 (match lam with 
|V x -> [("v", x)]
|P (x, l) -> 
let lst  = test (l)
 in 
([("p", x)] @ lst)
|C (l1, l2) -> 
let lst1  = test (l1)
 in 

let lst2  = test (l2)
 in 
(lst1 @ lst2))

let rec find num lst  = 
 (match lst with 
|[] -> []
|hd::tl -> if (hd = num) then find (num) (tl)
 else ([hd] @ find (num) (tl)))

let rec remove lst  = 
 (match lst with 
|[] -> []
|hd::tl -> 
 (match hd with 
|(p, x) -> if (p = "p") then 
let lst1  = find (("v", x)) (tl)
 in 
remove (lst1)
 else if (p = "v") then (hd :: remove (tl))
 else raise Failure ("a")))

let rec order lst  = 
 (match lst with 
|[] -> []
|hd::tl -> 
 (match hd with 
|(p, x) -> if (p = "p") then order (tl)
 else (hd :: order (tl))))

let rec check  : (lambda -> bool) = 
fun lam -> 
let lst1  = test (lam)
 in 

let lst2  = remove (lst1)
 in 

let lst3  = order (lst2)
 in 

 (match lst3 with 
|[] -> true
|_ -> false)

FixML fails to generate a patch

Error occurs : ../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_17/sub57.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases

../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_17/sub58.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec listcheck  : (var -> (var list -> bool)) = 
fun var varl -> 
 (match varl with 
|[] -> false
|hd::tl -> if (var = hd) then true
 else listcheck (var) (tl))

let rec lamfind  : (lambda -> (var list -> bool)) = 
fun lam varl -> 
 (match lam with 
|V v -> listcheck (v) (varl)
|P (v, lm) -> 
let vl  = (varl @ (v :: []))
 in 

let film  = lamfind (lm) (vl)
 in 
film
|C (lm1, lm2) -> 
let film1  = lamfind (lm1) (varl)
 in 

let film2  = lamfind (lm2) (varl)
 in 
(film1 && film2))

let check  : (lambda -> bool) = 
fun lam -> 
 (match lam with 
|V v -> false
|P (v, lm) -> 
let chlm  = lamfind (lm) ((v :: []))
 in 
chlm
|C (lm1, lm2) -> false)

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec listcheck  : (var -> (var list -> bool)) = 
fun var varl -> 
 (match varl with 
|[] -> false
|hd::tl -> if (var = hd) then true
 else listcheck (var) (tl))

let rec lamfind  : (lambda -> (var list -> bool)) = 
fun lam varl -> 
 (match lam with 
|V v -> listcheck (v) (varl)
|P (v, lm) -> 
let vl  = (varl @ (v :: []))
 in 

let film  = lamfind (lm) (vl)
 in 
film
|C (lm1, lm2) -> 
let film1  = lamfind (lm1) (varl)
 in 

let film2  = lamfind (lm2) (varl)
 in 
(film1 && film2))

let check  : (lambda -> bool) = 
fun lam -> 
 (match lam with 
|V v -> false
|P (v, lm) -> 
let chlm  = lamfind (lm) ((v :: []))
 in 
chlm
|C (lm1, lm2) -> lamfind (C ((lm2, lm1))) ([]))

Total time :1.904221
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_17/sub59.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec is_there  = 
fun x arr -> 
 (match arr with 
|[] -> false
|hd::tl -> if (x = hd) then true
 else is_there (x) (tl))

let rec find  = 
fun lam arr -> 
 (match lam with 
|V x -> (is_there (x) (arr), arr)
|P (x, l) -> 
let arr1  = (x :: arr)
 in 

 (match l with 
|V x1 -> find (V (x1)) (arr1)
|P (x1, l1) -> find (P ((x1, l1))) (arr1)
|C (l1, l2) -> 
 (match l1 with 
|V x2 -> 
let (t1, a1)  = find (V (x2)) (arr1)
 in 

let (t2, a2)  = find (l2) (a1)
 in 
((t1 && t2), a2)
|_ -> find (l) (arr1)))
|C (l1, l2) -> 
let (t1, a1)  = find (l1) (arr)
 in 

let (t2, a2)  = find (l2) (a1)
 in 
((t1 && t2), a2))

let rec check  : (lambda -> bool) = 
fun lam -> 
 (match find (lam) ([]) with 
|(true, _) -> true
|(false, _) -> false)

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec is_there  = 
fun x arr -> 
 (match arr with 
|[] -> false
|hd::tl -> if (x = hd) then true
 else is_there (x) (tl))

let rec find  = 
fun lam arr -> 
 (match lam with 
|V x -> (is_there (x) (arr), arr)
|P (x, l) -> 
let arr1  = (x :: arr)
 in 

 (match l with 
|V x1 -> find (V (x1)) (arr1)
|P (x1, l1) -> find (P ((x1, l1))) (arr1)
|C (l1, l2) -> 
 (match l1 with 
|V x2 -> 
let (t1, a1)  = find (V (x2)) (arr1)
 in 

let (t2, a2)  = find (l2) (a1)
 in 
((t1 && t2), a2)
|_ -> find (l) (arr1)))
|C (l1, l2) -> 
let (t1, a1)  = find (l1) (arr)
 in 

let (t2, a2)  = find (l2) (arr)
 in 
((t1 && t2), a2))

let rec check  : (lambda -> bool) = 
fun lam -> 
 (match find (lam) ([]) with 
|(true, _) -> true
|(false, _) -> false)

Total time :0.093376
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_17/sub62.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec doesExist  : ((var * a list) -> bool) = 
fun (var, env) -> 
 (match env with 
|[] -> false
|hd::tl -> if (var = hd) then true
 else doesExist ((var, tl)))

let rec isBound  : ((lambda * a list) -> bool) = 
fun (lam, env) -> 
 (match lam with 
|V v -> if doesExist ((v, env)) then true
 else false
|P (v, l) -> isBound ((l, (env @ [v])))
|C (l1, l2) -> (isBound ((l1, env)) && isBound ((l2, env))))

let rec check  : (lambda -> bool) = 
fun lam -> 
 (match lam with 
|V v -> false
|P (v, l) -> isBound ((l, [v]))
|C (l1, l2) -> false)

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec doesExist  : ((var * a list) -> bool) = 
fun (var, env) -> 
 (match env with 
|[] -> false
|hd::tl -> if (var = hd) then true
 else doesExist ((var, tl)))

let rec isBound  : ((lambda * a list) -> bool) = 
fun (lam, env) -> 
 (match lam with 
|V v -> if doesExist ((v, env)) then true
 else false
|P (v, l) -> isBound ((l, (env @ [v])))
|C (l1, l2) -> (isBound ((l1, env)) && isBound ((l2, env))))

let rec check  : (lambda -> bool) = 
fun lam -> 
 (match lam with 
|V v -> false
|P (v, l) -> isBound ((l, [v]))
|C (l1, l2) -> (check (l1) && check (l2)))

Total time :0.194759
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_17/sub63.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun lam -> 
let rec find x env  = 
 (match env with 
|[] -> false
|hd::tl -> if (hd = x) then true
 else find (x) (tl))
 in 

let rec del x env  = 
 (match env with 
|[] -> []
|v::tl -> if (v = x) then tl
 else (v :: del (x) (tl)))
 in 

let rec free l env  = 
 (match l with 
|V v -> if find (v) (env) then env
 else (v :: env)
|P (v, l1) -> del (v) (free (l1) (env))
|C (l1, l2) -> 
let env1  = free (l1) (env)
 in 
free (l2) (env1))
 in 

let env0  = []
 in 
if (free (lam) (env0) = []) then true
 else false

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun lam -> 
let rec find x env  = 
 (match env with 
|[] -> false
|hd::tl -> if (hd = x) then true
 else find (x) (tl))
 in 

let rec del x env  = 
 (match env with 
|[] -> []
|v::tl -> if (v = x) then tl
 else (v :: del (x) (tl)))
 in 

let rec free l env  = 
 (match l with 
|V v -> if find (v) (env) then env
 else (v :: env)
|P (v, l1) -> del (v) (free (l1) ((v :: env)))
|C (l1, l2) -> 
let env1  = free (l1) (env)
 in 
free (l2) (env1))
 in 

let env0  = []
 in 
if (free (lam) (env0) = []) then true
 else false

Total time :9.629521
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_17/sub68.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec erase  : (var -> (var list -> var list)) = 
fun v lst -> 
 (match lst with 
|[] -> []
|hd::tl -> if (v = hd) then erase (v) (tl)
 else (hd :: erase (v) (tl)))

let rec check_help  : (lambda -> var list) = 
fun lam -> 
let lst  = []
 in 

 (match lam with 
|V v -> (v :: lst)
|P (v, l) -> erase (v) (check_help (l))
|C (l1, l2) -> (check_help (l1) @ check_help (l2)))

let rec check  : (lambda -> bool) = 
fun lam -> 
 (match lam with 
|V v -> false
|P (v, l) -> if (__list_length__ (erase (v) (check_help (l))) = 0) then true
 else false
|C (l1, l2) -> false)

-----------------------------
result
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec erase  : (var -> (var list -> var list)) = 
fun v lst -> 
 (match lst with 
|[] -> []
|hd::tl -> if (v = hd) then erase (v) (tl)
 else (hd :: erase (v) (tl)))

let rec check_help  : (lambda -> var list) = 
fun lam -> 
let lst  = []
 in 

 (match lam with 
|V v -> (v :: lst)
|P (v, l) -> erase (v) (check_help (l))
|C (l1, l2) -> (check_help (l1) @ check_help (l2)))

let rec check  : (lambda -> bool) = 
fun lam -> 
 (match lam with 
|V v -> false
|P (v, l) -> if (__list_length__ (erase (v) (check_help (l))) = 0) then true
 else false
|C (l1, l2) -> (check_help (l1) = check_help (l2)))

Total time :0.144284
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_17/sub74.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun lam -> 
let rec get  = 
fun lam lst1 lst2 -> 
 (match lam with 
|V x -> (lst1, (x :: lst2))
|P (x, e) -> 
let lst'  = (x :: lst1)
 in 
get (e) (lst') (lst2)
|C (e1, e2) -> 
let t  = get (e1) (lst1) (lst2)
 in 
get (e2) (fst (t)) (snd (t)))
 in 

let rec search  = 
fun lst1 lst2 -> 
 (match lst2 with 
|[] -> true
|hd::tl -> 
let rec find p lst  = 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = p) then true
 else find (p) (tl))
 in 
if find (hd) (lst1) then search (lst1) (tl)
 else false)
 in 

 (match lam with 
|V x -> true
|_ -> 
let t  = get (lam) ([]) ([])
 in 
search (fst (t)) (snd (t)))

FixML fails to generate a patch

Error occurs : 
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_18/sub14.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases

../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_18/sub17.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let rec check  : (lambda -> bool) = 
fun lam -> 
 (match lam with 
|V v1 -> true
|P (v2, lam1) -> 
 (match lam1 with 
|V v2 -> true
|P (v3, lam2) -> check (lam2)
|C (lam3, lam4) -> 
let bool1  = check (lam3)
 in 

let bool2  = check (lam4)
 in 
if ((bool1 = bool2) = true) then true
 else false
|C (lam1, lam2) -> 
let bool3  = check (lam1)
 in 

let bool4  = check (lam2)
 in 
if ((bool3 = bool4) = true) then true
 else false
|_ -> false))

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_18/sub20.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let bindlst  = []

let rec check  : (lambda -> bool) = 
fun lam -> 
let rec bindchk  : (lambda -> (var list -> var list)) = 
fun sublam benv -> 
 (match sublam with 
|V x -> benv
|P (x, e) -> bindchk (e) ((x :: benv))
|C (e1, e2) -> bindchk (e2) (bindchk (e1) (benv)))
 in 

let bindlst  = bindchk (lam) ([])
 in 

let lookup  : (var -> (var list -> bool)) = 
fun x blst -> 
let rec lookupproc  : (var -> (var list -> bool)) = 
fun xx lst -> 
 (match lst with 
|[] -> false
|hd::tl -> if (hd = xx) then true
 else lookupproc (xx) (tl))
 in 
lookupproc (x) (blst)
 in 

let rec isbind  : (lambda -> (var list -> bool)) = 
fun lda bindenv -> 
 (match lda with 
|V x -> lookup (x) (bindenv)
|P (x, e) -> isbind (e) (bindenv)
|C (e1, e2) -> if ((isbind (e1) (bindenv) = true) && (isbind (e2) (bindenv) = true)) then true
 else false)
 in 
isbind (lam) (bindlst)

FixML fails to generate a patch

Error occurs : 
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_18/sub25.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases

../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_18/sub38.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check  : (lambda -> bool) = 
fun lam -> 
let myvarlst  = []
and myfreevarlst  = []
 in 

let rec check2 lambda  = 
 (match lambda with 
|V v -> (myfreevarlst @ [v])
|P (v, l) -> 
let dummy1  = (myvarlst @ [v])
 in 
check2 (l)
|C (l1, l2) -> 
let dummy2  = check2 (l1)
 in 
check2 (l2))
 in 

let rec check3 varlst freevarlst  = 
 (match freevarlst with 
|[] -> true
|var::tl -> 
 (match varlst with 
|[] -> false
|var2::tl2 -> if (var = var2) then check3 (tl) (freevarlst)
 else check3 (varlst) (tl2)))
 in 

let dummy  = check2 (lam)
 in 
check3 (myvarlst) (myfreevarlst)

FixML fails to generate a patch

Error occurs : 
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_18/sub4.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases

../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_18/sub43.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string

let check  : (lambda -> bool) = 
fun lam -> 
let rec check1 lambda myvarlst  = 
 (match lambda with 
|V v -> myvarlst
|P (v, l) -> check1 (l) ((v :: myvarlst))
|C (l1, l2) -> (check1 (l1) (myvarlst) @ check1 (l1) ([])))
 in 

let rec check2 lambda myfreevarlst  = 
 (match lambda with 
|V v -> (v :: myfreevarlst)
|P (v, l) -> check2 (l) (myfreevarlst)
|C (l1, l2) -> (check2 (l1) (myfreevarlst) @ check2 (l2) ([])))
 in 

let rec check3 varlst freevarlst  = 
 (match freevarlst with 
|[] -> true
|var::tl -> 
 (match varlst with 
|[] -> false
|var2::tl2 -> if (var = var2) then check3 (tl) (freevarlst)
 else check3 (varlst) (tl2)))
 in 

let varlst  = check1 (lam) ([])
and freevarlst  = check2 (lam) ([])
 in 
check3 (varlst) (freevarlst)

FixML fails to generate a patch
../engine/main.native -fix -submission ../benchmarks_incorrect/All_lambda/k_18/sub5.ml -solution ../benchmarks_correct/All_lambda/sol.ml -entry check -testcases ../testcases/lambda_testcases
-----------------------------
original
-----------------------------

type lambda =
|C of (lambda * lambda)
|P of (var * lambda)
|V of var
and var = string
type v_set = var list

let rec union1  : ((v_set * v_set) -> v_set) = 
fun (s1, s2) -> 
 (match s1 with 
|[] -> s2
|hd::tl -> if __list_mem__ (hd) (s2) then union1 ((tl, s2))
 else union1 ((tl, (hd :: s2))))

let rec find_erase  : (var -> (v_set -> (v_set -> v_set))) = 
fun v s sc -> 
 (match s with 
|hd::tl -> if (hd = v) then (tl @ sc)
 else find_erase (v) (tl) ((hd :: sc))
|[] -> sc)

let rec union2  : ((v_set * v_set) -> v_set) = 
fun (s1, s2) -> 
 (match s1 with 
|[] -> s1
|hd::tl -> if __list_mem__ (hd) (s2) then (hd :: union2 ((tl, s2)))
 else union2 ((tl, s2)))

let rec save  : (lambda -> (v_set -> v_set)) = 
fun lam s -> 
 (match lam with 
|P (_, l) -> save (l) (s)
|C (l1, l2) -> union1 ((save (l1) (s), save (l2) (s)))
|V v -> if __list_mem__ (v) (s) then s
 else (v :: s))

let rec erase  : (lambda -> (v_set -> v_set)) = 
fun lam s -> 
 (match lam with 
|P (v, l) -> erase (l) (find_erase (v) (s) ([]))
|C (l1, l2) -> union2 ((erase (l1) (s), erase (l2) (s)))
|V v -> s)

let check  : (lambda -> bool) = 
fun lam -> 
 (match erase (lam) (save (lam) ([])) with 
|[] -> true
|hd::tl -> false)

let _  = check (P (("a", V ("a"))))

let _  = check (P (("a", P (("a", V ("a"))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("b"))))))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("a"))))))))

let _  = check (P (("a", V ("b"))))

let _  = check (P (("a", C ((V ("a"), P (("b", V ("c"))))))))

let _  = check (P (("a", P (("b", C ((V ("a"), V ("c"))))))))

FixML fails to generate a patch
